<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuzheng&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-12T14:08:49.070Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>liu zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux剑法（第四式）</title>
    <link href="http://example.com/2022/10/12/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%BC%8F%EF%BC%89/"/>
    <id>http://example.com/2022/10/12/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%BC%8F%EF%BC%89/</id>
    <published>2022-10-12T09:37:52.000Z</published>
    <updated>2022-10-12T14:08:49.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h1><p>在linux专用每一个用户都要属于一个组，不能独立于组外，就像是我们人生来就属于一个国家。在Linux中每个文件有所有者、所在组、其他组的概念。接下来我们就看看这些概念。</p><h1 id="所有者"><a href="#所有者" class="headerlink" title="所有者"></a>所有者</h1><p>假如我们现在有一个用户jerry，他创建了一个文件hello.txt，那么我们就说这个文件的所有者是jerry，当然jerry也可以将文件转给别的用户比如jack。一般来讲为文件的创建者，谁创建了文件，谁就成为文件的所有者。当然这并不绝对，我们可以使用指令<strong>chown 用户名 文件名</strong>修改文件的所有者，使用<strong>ls -ahl</strong>查看文件的所有者。</p><p><img src="1.jpg" alt="chown指令和ls -ahl指令"></p><h1 id="所在组"><a href="#所在组" class="headerlink" title="所在组"></a>所在组</h1><p>假如用户jerry属于组一，他建立了一个文件hello.txt，那么我们说hello.txt也属于组一，组一就是hello.txt的所在组，组内的其他成员，比如jack，也对文件有一定的权限，去操作文件。当某个用户创建了一个文件后，这个文件的所在组就是用户的所在组。<strong>ls -ahl</strong>同样可以查看文件的所在组，我们可以使用<strong>chgrp 组名 文件名</strong>来修改文件的所在组。</p><p><img src="2.jpg" alt="chgrp指令和ls -ahl指令"></p><h1 id="其他组"><a href="#其他组" class="headerlink" title="其他组"></a>其他组</h1><p>现在我们有了一个属于组一的文件hello.txt但是这个文件并不属于组二，那么我们就说组二是文件hello.txt的其他组，虽然是其他组，但对文件hello.txt也还有一些权限。我们可以更改一个用户的所在组我们之前也讲过只需要使用<strong>usermod -g 组名 用户名</strong>即可，但我们需要注意组一定存在才可以转移进去，我们可以使用<strong>cat查看/etc/group</strong>来看看都存在那些组。我们还可以做的事情是更改用户登录的初始目录，指令是<strong>usermod -d 目录名 用户名</strong>，这样就可以改变用户登录的初始目录了但要注意的是用户需要有进入到新目录的权限才可以。</p><p><img src="3.jpg" alt="查看用户组并修改"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组管理和权限管理&quot;&gt;&lt;a href=&quot;#组管理和权限管理&quot; class=&quot;headerlink&quot; title=&quot;组管理和权限管理&quot;&gt;&lt;/a&gt;组管理和权限管理&lt;/h1&gt;&lt;p&gt;在linux专用每一个用户都要属于一个组，不能独立于组外，就像是我们人生来就属于一个国家。在</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux剑法（第三式）</title>
    <link href="http://example.com/2022/10/09/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%89%E5%BC%8F%EF%BC%89/"/>
    <id>http://example.com/2022/10/09/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%89%E5%BC%8F%EF%BC%89/</id>
    <published>2022-10-09T12:07:26.000Z</published>
    <updated>2022-10-12T13:43:00.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux基础操作"><a href="#Linux基础操作" class="headerlink" title="Linux基础操作"></a>Linux基础操作</h1><p>使用linux就和使用Windows是一样的我们要掌握一些基础的操作，才能让我们游刃有余，接下来的内容，死记硬背不是上策，少侠还需勤加锻炼，记住，无他，唯手熟尔。</p><h1 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h1><p>首先我们介绍几条简单的命令用来关机：</p><ol><li>shutdown -h now 立刻关机</li><li>shutdown -h 1 1分钟后关机</li><li>shutdown -r now 现在重新启动</li><li>halt 关机，作用和上面一样</li><li>reboot 现在重新启动</li><li>sync 把内存的数据同步到磁盘</li></ol><p><strong>建议在使用这些指令之前先使用sync同步数据。</strong></p><h1 id="用户登录与注销"><a href="#用户登录与注销" class="headerlink" title="用户登录与注销"></a>用户登录与注销</h1><p>我们在登录的时候建议不使用root登录因为root的权限很大，为了避免误操作，我们一般不选择使用root登录，如果我们需要管理员权限时可以使用命令su来提高权限，在提示符下输入logout即可注销用户，但是要注意的是logout在图形运行级别无效，在运行级别3下有效，我知道少侠可能对运行级别有疑惑，别担心我们这就来讲讲运行级别。</p><h1 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h1><p>Linux中有这样几个运行级别：</p><ul><li><p>0：关机</p></li><li><p>1：单用户（可以用于找回密码）</p></li><li><p>2：多用户状态没有网络服务</p></li><li><p>3：多用户状态有网络服务</p></li><li><p>4：系统未使用保留给用户</p></li><li><p>5：图形界面</p></li><li><p>6：系统重启</p></li></ul><p>其中常用的运行指令是3和5，当然我们也可以使用<strong>systemctl set-default graphical.target(或multi-user.target)<strong>指定默认的运行级别，在运行过程中我们可以使用</strong>init+运行级别</strong>来切换运行级别。</p><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都要先向系统管理员申请一个账户，然后用这个账户进入系统，因此我们要知道如何管理Linux系统下的用户。</p><p>首先是添加用户，命令为<strong>useradd 用户名</strong>，这样我们就可以添加一个用户了，当然也可以使用<strong>useradd -d 指定目录 新的用户名</strong>来给新创建的用户指定home目录。我们可以使用<strong>passwd指令</strong>来更改用户的密码，格式为<strong>passwd 用户名</strong>。之后我们就可以使用不同的用户登录了，我们可以在登录后使用<strong>命令pwd查看当前位置</strong>，来判定我们是否真的登录上了新的用户。</p><p>第二就是删除用户，我们需要管理员权限才可以删除用户，删除用户的命令为<strong>userdel 用户名</strong>，这样我们就可以删除指定用户了，但这样直接删除会保留用户的家目录，如果我们不想保留用户的家目录只需要使用<strong>userdel -r 用户名</strong>即可。我们还可以查看我们用户的信息，语法也很简单为<strong>id 用户名</strong>。</p><p>在着就是切换用户了，我们之前也用过切换用户命令<strong>su -用户名</strong>，当我们从低权限切换成高权限用户时需要输入密码，反之不需要，当我们想返回原来的用户时，使用<strong>exit/logout</strong>指令。我们可以使用命令<strong>who am i</strong>查看当前用户信息。</p><h1 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h1><p>类似于一种角色上的分类，系统可以对有相同权限的多个用户进行统一管理，我们可以通过赋予组权限，为组内用户提供权限。我们如果新增一个组可以使用指令<strong>groupadd 组名</strong>，删除一个组就是<strong>groupdel 组名</strong>，在添加用户时直接加到组里使用<strong>useradd -g 用户组 用户名</strong>。当然我们也可以更改成员所在的组，只需要使用<strong>usermod -g 组名 用户名</strong>即可。</p><h1 id="用户和组相关文件"><a href="#用户和组相关文件" class="headerlink" title="用户和组相关文件"></a>用户和组相关文件</h1><p>这里，我们介绍三个文件：</p><ol><li>/etc/passwd文件：它是用户的配置文件，记录用户的各种信息，每行的含义是用户名：加密口令：用户标识号：组标识号：注释性描述：主目录：登录shell</li><li>/etc/shadow文件：它是口令的配置文件，每行的含义是登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</li><li>/etc/group文件：它是组的配置文件，记录Linux包含的组的信息，每行的含义是组名：口令：组标识号：组内用户目录</li></ol><h1 id="找回root密码"><a href="#找回root密码" class="headerlink" title="找回root密码"></a>找回root密码</h1><p>什么？！少侠你把root密码给忘记了，哎呀呀，这这。。。没事我们可以再找回root密码。</p><p>首先我们重启Linux，在这个页面时按e</p><p><img src="1.jpg" alt="找回root密码1"></p><p>然后上下左右移动光标至linux16开头的那句话末尾并输入init=/bin/sh</p><p><img src="2.jpg" alt="找回root密码2"></p><p>之后按下 Ctrl X启动单用户模式，进入单用户模式后我们需要输入：mount -o remount,rw /，按enter，然后输入passwd重新设置密码和确定密码，如果出现passwd就说明密码修改成功如图：</p><p><img src="3.jpg" alt="找回root密码3"></p><p>接着我们要输入touch /.autorelabel，按回车，最后输入exec /sbin/init，按回车。</p><p><img src="4.jpg" alt="找回root密码4"></p><p>至此root密码就找回来了，这一次少侠别再轻易忘记了。</p><h1 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h1><p>想必少侠也感觉到了，我们到现在为止虽然好像没做什么，但大多数都用到了各种指令，没错linux下我们需要熟练的使用这些指令，这样才方便我们的修炼，所以接下来我们要开始接触各种指令，但在此之前我们先了解一个重要的指令，帮助指令，它就像一个罗盘，少侠要是迷茫了可以使用帮助指令看看命令的帮助信息。</p><p>第一个帮助指令是man [命令或配置文件]，比如man ls，我们可以通过这条指令知道ls命令是做什么的，以及它有没有其他的扩展选项，例如ls -a可以显示所有文件包括以“.”开头的隐藏文件。如果帮助信息很多没有显示完，可以使用space(空格键)翻页。（Tips：ls指令的选项可以叠加使用比如ls -la，单列显示所有文件，la选项不区分先后关系，也可以为al。）</p><p><img src="5.jpg" alt="man ls"></p><p>第二个帮助指令时help 命令，它可以获得shell内置命令的帮助信息。比如help cd。</p><p><img src="6.jpg" alt="help cd"></p><h1 id="文件目录指令"><a href="#文件目录指令" class="headerlink" title="文件目录指令"></a>文件目录指令</h1><p>Linux下一切皆文件，所以我们要想成为高手，就要知道怎么操作文件，所以我们接下来了解一下文件目录指令。</p><h2 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a>pwd指令</h2><p>基本语法：pwd，用来显示当前工作目录的绝对路径。</p><p><img src="7.jpg" alt="pwd指令"></p><h2 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h2><p>基本语法：ls [选项] [目录或是文件]，用来显示当前目录文件。</p><p>常用选项：-a，显示当前目录所有文件和目录，包括隐藏的。-l，以列表的方式显示信息，信息会展示的更为全面。</p><p><img src="8.jpg" alt="ls指令"></p><h2 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h2><p>基本语法：cd [参数]，用来切换到指定目录</p><p>cd~或cd，回到自己的家目录 cd..回到当前目录的上一级目录</p><p><img src="9.jpg" alt="cd指令"></p><h2 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a>mkdir指令</h2><p>基本语法：mkdir [选项] 要创建的目录，用来创建目录</p><p>常用选项：-p，创建多级目录</p><p><img src="10.jpg" alt="mkdir指令"></p><h2 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a>rmdir指令</h2><p>基本语法：rmdir（或rm） [选项] 要删除的空目录，用来删除目录</p><p>注意，因为rmdir删除的是空目录，如果目录下有内容是无法删除的，这个时候要使用rm -rf删除。</p><p><img src="11.jpg" alt="rmdir指令和rm -rf"></p><h2 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h2><p>基本语法：touch 文件名称，用来创建空文件</p><p><img src="12.jpg" alt="touch指令"></p><h2 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a>cp指令</h2><p>基本语法：cp [选项] 文件夹(或文件) 目的地址，用来拷贝文件到指定目录</p><p>常用选项：-r 递归复制整个文件夹</p><p><img src="13.jpg" alt="cp指令"></p><p>当我们重复的将一个文件(文件夹)复制到同一个目录时，就会发生覆盖，这个时候我们需要输入y才可以覆盖文件。当然我们也可以使用\cp [选项] 文件夹(或文件) 目的地址，强制覆盖。</p><p><img src="14.jpg" alt="cp指令覆盖问题"></p><h2 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h2><p>基本语法：rm [选项] 要删除的文件或目录，用来移除文件或目录</p><p>常用选项：-r：递归删除整个文件夹。-f：强制删除不提示</p><p><img src="15.jpg" alt="rm指令"></p><h2 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h2><p>基本语法：</p><p>mv oldfilename newfilename，用来重命名</p><p>mv 文件(文件夹)路径 目的路径，用来移动文件</p><p><img src="16.jpg" alt="mv指令"></p><p>我们也可以在移动文件的同时修改文件名称。</p><h2 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h2><p>基本语法：cat [选项] 要查看的文件，用来查看文件内容</p><p>常用选项：-n：显示行号</p><p><img src="17.jpg" alt="cat指令"></p><p>当然文件往往都有很多行所以为了方便浏览，我们可以加上管道指令|more，例如 cat -n pig.txt |more。</p><h2 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h2><p>基本语法：more 要查看的文件</p><p>more指令是一个基于vi编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干个快捷键。如下图：</p><p><img src="18.jpg" alt="more指令快捷键"></p><h2 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h2><p>基本语法：less 要查看的文件</p><p>less指令用分屏来查看文件内容，它和more类似，当比more更为强大，less对显示大型文件具有较高的效率。</p><p>less相较于more而言，还可以使用/ 关键词来进行搜索，输入n向前查找下一个匹配的文本，输入N向后查找前一个匹配的文本。</p><h2 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a>echo指令</h2><p>基本语法：echo [选项] [输出内容]，用来输出内容到控制台</p><p><img src="19.jpg" alt="echo指令"></p><h2 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h2><p>基本语法：</p><p>head 文件，用来显示文件开头部分，默认为头10行</p><p>head -n 5 文件，用来查看文件头5行内容，5是变数 </p><p><img src="20.jpg" alt="head指令"></p><h2 id="gt-指令和-gt-gt-指令"><a href="#gt-指令和-gt-gt-指令" class="headerlink" title="&gt;指令和&gt;&gt;指令"></a>&gt;指令和&gt;&gt;指令</h2><p>基本语法：</p><p>ls -l&gt;文件，列表的内容写入文件中(覆盖写)</p><p>ls -al&gt;&gt;文件，列表的内容追加到文件的末尾</p><p>cat 文件1&gt;文件2，将文件1的内容覆盖到文件2</p><p>echo “内容”&gt;&gt;文件，将内容写入文件</p><h2 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h2><p>基本语法：</p><p>tail 文件，查看文件尾内容，默认为10行</p><p>tail -n 5 文件，查看文件尾5行内容，5是变数</p><p>tail -f 文件，实时追踪该文档的所有更新，指令执行后监控文件，有新内容写入后立马显示。</p><p><img src="21.jpg" alt="tail指令"></p><h1 id="ln指令"><a href="#ln指令" class="headerlink" title="ln指令"></a>ln指令</h1><p>基本语法：ln -s [原文件或目录] [软链接名]，用来给文件创建一个软链接</p><p>软链接就类似于Windows下的快捷方式，我们为一个文件或目录创造一个软链接，当我们访问这个软链接时就相当于访问原文件或目录。</p><p><img src="22.jpg" alt="ln指令"></p><p>我们可以看到虽然我们通过软链接进入了原文件中，但路径还是软链接的路径，这点要注意。如果我们不想要这个软链接了，我们可以使用rm删除它。</p><h2 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a>history指令</h2><p>基本语法：history，用来查看已经执行过的历史指令。</p><p>你也可以在history后加上一个数字，显示你想显示的后几条指令，比如history 10会显示后十条指令。输入！标号，就可以标号对应指令。</p><p><img src="23.jpg" alt="history指令"></p><h1 id="时间日期指令"><a href="#时间日期指令" class="headerlink" title="时间日期指令"></a>时间日期指令</h1><p>Linux中还有其他功能的指令，比如时间日期指令</p><h2 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a>date指令</h2><p>基本语法：</p><p>date，显示当前时间</p><p>date “+%Y”，显示当前年份</p><p>date “+%m”，显示当前月份</p><p>date “+%d”，显示当前是哪一天</p><p>date “+%Y-%m-%d %H:%M:%S”，显示年月日时分秒</p><p>注意，这里指令的大小写是规定好的，一定要按照上述大小写输入。</p><p><img src="24.jpg" alt="date指令"></p><h2 id="date-s指令"><a href="#date-s指令" class="headerlink" title="date -s指令"></a>date -s指令</h2><p>基本语法：date -s 时间(字符串)</p><p>我们可以使用这个指令修改当前系统的时间。</p><h2 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h2><p>基本语法：cal [选项]</p><p>选项：-m：显示星期一作为一周的第一天，-y：显示当前年份的日历。</p><p><img src="25.jpg" alt="cal指令"></p><p>还可以使用cal+年份，显示指定年份的日历。</p><h1 id="查找指令"><a href="#查找指令" class="headerlink" title="查找指令"></a>查找指令</h1><p>我们在使用Linux的过程中，使用查找指令可以大大的方便我们的工作。</p><h2 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h2><p>基本语法：find [搜索范围] [选项]，用来从指定目录下递归地遍历其各个子目录，将满足条件的显示在终端。</p><p>选项：-name&lt;查询方式&gt;，按照指定的用户名查找模式查找文件。-user&lt;用户名&gt;，查找属于指定用户名所有文件。-size&lt;文件大小&gt;，按照指定的文件大小查找文件。</p><p><img src="26.jpg" alt="find指令"></p><h2 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h2><p>基本语法：locate 搜索文件，同样是用来查找文件的，但是locate指令可以快速定位文件路径。</p><p>注意，由于locate指令基于数据库进行查询，所以第一次运行前，要使用updatedb指令创造locate数据库。</p><p><img src="27.jpg" alt="locate指令"></p><h2 id="grep指令和管道符号"><a href="#grep指令和管道符号" class="headerlink" title="grep指令和管道符号|"></a>grep指令和管道符号|</h2><p>基本语法：grep [选项] 查找内容 源文件，用于过滤查找。管道符“|”表示将前一个命令的处理结果输出传递给后面的命令处理。两者多联合使用。</p><p>选项：-n：显示匹配行及行号。-i忽略字母大小写。</p><p><img src="28.jpg" alt="grep指令和|"></p><h2 id="which指令"><a href="#which指令" class="headerlink" title="which指令"></a>which指令</h2><p>基本语法：which 可执行文件名称，用来查看可执行文件的位置</p><p><img src="29.jpg" alt="which指令"></p><h1 id="压缩和解压指令"><a href="#压缩和解压指令" class="headerlink" title="压缩和解压指令"></a>压缩和解压指令</h1><p>我们在处理文件的时候也少不了压缩和解压的过程，Linux为我们提供了这样的指令。</p><h2 id="gzip-gunzip指令"><a href="#gzip-gunzip指令" class="headerlink" title="gzip/gunzip指令"></a>gzip/gunzip指令</h2><p>基本语法：</p><p>gzip 文件，用来压缩文件，只能将文件压缩为.gz格式</p><p>gunzip 文件，用来解压缩文件</p><p><img src="30.jpg" alt="gzip/gunzip指令"></p><h2 id="zip-unzip指令"><a href="#zip-unzip指令" class="headerlink" title="zip/unzip指令"></a>zip/unzip指令</h2><p>基本语法：</p><p>zip [选项] xxx.zip，用来压缩文件和目录</p><p>unzip [选项] xxx.zip，用于解压缩文件</p><p>zip常用选项：-r：递归压缩，即压缩目录</p><p>unzip常用选项：-d&lt;目录&gt;：指定压缩后文件的存放位置</p><p><img src="31.jpg" alt="zip/unzip指令"></p><h2 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h2><p>基本语法：tar [选项] xxx.tar.gz 打包内容，用来打包目录</p><p>选项：-c：产生.tar打包文件。-v：显示详细信息。-f：指定压缩后的文件名。-z：打包同时压缩。-x：解包.tar文件。</p><p><img src="32.jpg" alt="tar指令"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux基础操作&quot;&gt;&lt;a href=&quot;#Linux基础操作&quot; class=&quot;headerlink&quot; title=&quot;Linux基础操作&quot;&gt;&lt;/a&gt;Linux基础操作&lt;/h1&gt;&lt;p&gt;使用linux就和使用Windows是一样的我们要掌握一些基础的操作，才能让我们游刃</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux剑法（第二式）</title>
    <link href="http://example.com/2022/10/05/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%BC%8F%EF%BC%89/"/>
    <id>http://example.com/2022/10/05/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%BC%8F%EF%BC%89/</id>
    <published>2022-10-05T07:57:54.000Z</published>
    <updated>2022-10-12T13:25:51.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h1><p>Linux讲究的是一切皆文件，在Windows下是文件的东西，在Linux中也是，在Windows下不是文件的东西，比如套接字，进程，甚至是硬件设备，在Linux下还是文件，你可以通过访问文件的方式来获取它们的信息，所以说要记住Linux下一切皆文件。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p><img src="1.jpg" alt="Linux目录结构"></p><p>Linux目录结构十分重要，要熟练的掌握。接下来我们来看一看这些目录都是用来做什么的：</p><ol><li>/bin：bin是Binaries(二进制文件)的缩写，这个目录存放着最经常用的命令。</li><li>/sbin：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</li><li>/home：存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名。</li><li>/root：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li>/lib：系统开机所需要最基本的动态连接共享库，就类似于Windows下的DLL文件。几乎所有的应用程序都需要用到这些共享库</li><li>/lost+found：这个目录是一个被隐藏的目录，一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li>/etc：所有的系统管理所需要的配置文件和子目录。</li><li>/usr：这是一个非常重要的目录，用户很多的应用程序和文件都放在这个目录下，类似Windows的program files目录。</li><li>/boot：存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li>/proc：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。不要动它，可能导致系统崩溃。</li><li>/srv：service缩写，该目录存放一些服务启动后需要提取的数据。不要动它，可能导致系统崩溃。</li><li>/sys：这是Linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。不要动它，可能导致系统崩溃。</li><li>/tmp：用来存放一些临时文件。</li><li>/dev：类似Windows的设备管理器，把所有的硬件用文件的形式存储。</li><li>/media：Linux系统会自动识别一些设备，例如光驱，U盘等等，当识别后，Linux会把识别的设备挂载到这个目录下。</li><li>/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt上，然后进入该目录就可以查看里面的内容了。</li><li>/opt：这是主机额外安装软件用到的目录，默认为空。</li><li>/user/local：这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码方式安装的程序。</li><li>/var：这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。</li><li>/selinux：SELinux是一种安全子系统，它能控制程序只访问特定文件，有三种工作模式，可自行设定。</li></ol><h1 id="远程登录linux"><a href="#远程登录linux" class="headerlink" title="远程登录linux"></a>远程登录linux</h1><p>在公司里，linux服务器是开发小组共享的，正式上线的项目是运行在公网之上的，因此程序员需要远程登录到linux进行项目管理或开发，所以我们要知道如何远程登录linux。当然我们远程登录也需要工具，一个是Xshell6，一个是Xftp6。<a href="https://www.xshell.com/zh/free-for-home-school/">戳我下载</a></p><p>安装好后，我们开始使用Xshell，首先我们如果想远程登录linux，就要先知道linux的IP地址，我们可以在linux中断中输入ifconfig来查看IP地址。<img src="2.jpg" alt="查看IP地址"></p><p>之后我们打开Xshell新建一个连接，名称可以随便取，但主机一定是我们刚才拿到的主机号</p><p><img src="3.jpg" alt="建立连接"></p><p>之后会有一个弹窗，我们选择接受并保存。这样我们就可以使用Xshell远程登录linux了。</p><h2 id="远程文件传输"><a href="#远程文件传输" class="headerlink" title="远程文件传输"></a>远程文件传输</h2><p>我们现在已经可以远程登录linux了，但我们知道linux下一切皆文件，文件的使用方法之一就是传输，所以我们还要知道怎么进行远程文件传输，这就要使用另一个工具了Xftp。</p><p>Xftp和Xshell相通，还是建立连接即可。左侧是windows文件系统，右侧是linux文件系统。</p><p><img src="4.jpg" alt="成功建立连接"></p><p>这里有的少侠可能就发现了，这个页插画怎么如此难懂，这是什么文字，少侠稍安勿躁，我们只需要点击上方地球按钮，选择Unicode就可以解决这个问题了。</p><p><img src="5.jpg" alt="解决乱码"></p><h1 id="vi和vim"><a href="#vi和vim" class="headerlink" title="vi和vim"></a>vi和vim</h1><p>我们知道Linux一切皆文件，文件大多数都应该是可以更改的，所以Linux系统内置了vi文本编辑器，vim也是一个文本编辑器，不过vim具有程序编辑的能力，可以看做是Vi的增强版本，可以主动以字体颜色辨别语法的正确性，方便程序设计。代码补完，编译以及错误跳转等功能丰富。</p><h2 id="vi和vim常用的三种模式"><a href="#vi和vim常用的三种模式" class="headerlink" title="vi和vim常用的三种模式"></a>vi和vim常用的三种模式</h2><p>vi和vim有三种常用模式分别是正常模式、插入模式、命令行模式。</p><p>首先是正常模式，以vim打开一个档案就直接进入了一般模式了。在这个模式中可以使用上下左右移动光标，删除字符，复制粘贴等操作处理文件数据。</p><p>之后是插入模式，按下i，I，o，O，A，R，r都可以进入插入模式，但一般习惯按i，按esc可以退出插入模式，回到正常模式。</p><p>最后是命令行模式，在正常模式下，当我们输入“：”就可以切换为命令模式，在这个模式中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等动作。</p><p><img src="6.jpg" alt="三种模式及切换方法"></p><h2 id="vi和vim快捷键"><a href="#vi和vim快捷键" class="headerlink" title="vi和vim快捷键"></a>vi和vim快捷键</h2><p>首先是基本的复制与粘贴操作，我们在正常模式下敲击yy就可以拷贝当前行，之后按p就可以粘贴当前行了，如果需要多行复制可以敲击数字加yy比如敲击5yy就可以复制当前行向下5行。有复制粘贴就会有删除，还是在正常模式下按dd就可以删除当前行，同样也可以进行多行删除操作。同样我们还有撤销操作，在正常模式下按u即可撤销。</p><p>我们还可以查找一个文本文件中的某个单词，我们在<strong>命令行模式</strong>下只需要使用“/关键字”，回车即可查找，输入n就是查找下一个。我们还可以使用<strong>“set nu”</strong>和<strong>“set nonu”</strong>显示和隐藏行号。我们也可以快速的转到最首行快捷键是gg，快速转到最末行<strong>G（shift+g）</strong>当然这个操作要在<strong>正常模式</strong>下进行。还有一个操作就是快速的转到某一行，比如我想转到20行只需要在正常模式下敲击<strong>2+0+shift+g</strong>即可，不过要注意的是<strong>20不要用键盘的小键盘输入</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一切皆文件&quot;&gt;&lt;a href=&quot;#一切皆文件&quot; class=&quot;headerlink&quot; title=&quot;一切皆文件&quot;&gt;&lt;/a&gt;一切皆文件&lt;/h1&gt;&lt;p&gt;Linux讲究的是一切皆文件，在Windows下是文件的东西，在Linux中也是，在Windows下不是文件的东西，</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux剑法（第一式）</title>
    <link href="http://example.com/2022/10/04/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%80%E5%BC%8F%EF%BC%89/"/>
    <id>http://example.com/2022/10/04/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%80%E5%BC%8F%EF%BC%89/</id>
    <published>2022-10-04T05:39:16.000Z</published>
    <updated>2022-10-05T07:54:59.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要习得此剑法？"><a href="#为什么要习得此剑法？" class="headerlink" title="为什么要习得此剑法？"></a>为什么要习得此剑法？</h1><p>当今世界，强者纵横，Linux被广泛使用，自掌门Linus Benedict Torvalds开宗立派之后，便将此剑法广布天下，如今也成为了晋升强者道路上的一门必修功法。Linux安全性高，内核稳定，具有完善的开发和调试工具，如今Linux也被广泛的使用在超级计算机、服务器、PC机、手机、嵌入式系统中，尤其是服务器开发，此剑法可谓上乘之选。而且我们未来学习其他功法，可能也需要懂得此套剑法。少侠，何不现在开始？</p><h1 id="工欲善其事，必先利其器"><a href="#工欲善其事，必先利其器" class="headerlink" title="工欲善其事，必先利其器"></a>工欲善其事，必先利其器</h1><p>在学习剑法之前，必然是选择一柄上好的武器，恰好，我这里有京中著名工匠所铸的长剑剑柄<a href="https://download3.vmware.com/software/WKST-1624-WIN/VMware-workstation-full-16.2.4-20089737.exe">VMware</a>，剑刃<a href="https://pan.baidu.com/s/1u0tuBRRYBqOgHEloVUJ4xA?pwd=whmk">centOS7</a>，还有一个密匙ZF3R0-FHED2-M80TY-8QYGC-NPKYF，一并赠与少侠，但。。。还需要少侠亲自组装一下。不用担心，我给少侠带来了安装说明书，如下：</p><p>1.取出VMware，安装在我们的电脑上，如果你直接安装成功可以去看第二步了，如果你没安装成功，可能是需要开启CPU虚拟化，开启虚拟化首先要根据你的电脑型号上网查找按哪个键进入BIOS，然后重启电脑，在重启的过程中狂按那个键，待进入BIOS界面后进入BIOS后，找到Configuration，选择Intel Virtual Technology（或AMD Virtual Technology）按回车，将光标移至Enabled，然后再回车，最后按F10保存并退出。</p><p>2.安装好VMware后，我们要将centOS7映像文件下载下来。</p><p>3.打开VMware，点击创建新的虚拟机，依次执行下列操作，选中典型、下一步、选中稍后安装操作系统、下一步、选中Linux、在版本的下拉菜单中选择Red Hat Enterprise Linux 7 64位、下一步、为你的剑取一个心仪的名字、选择放在一个喜欢的位置、下一步、下一步。</p><p>4.点击自定义硬件，选择处理器，这个时候我们要先确定自己电脑有几个CPU，总共有几个内核，我们点开任务管理器，点击性能，点击打开资源监视器，我们可以看到一个进程栏和一个任务栏，这证明我们的电脑有两个CPU，把右边拉到最下面可以看到一个CPU15，这证明我们总共有16个内核，也就是一个CPU有8个内核。所以我们可以选择分配给虚拟机2个CPU，每一个CPU分配4个内核，毕竟我们还要给母机本身留一点内核，这样我们就分配给虚拟机了2个CPU和总共8个内核。</p><p><img src="1.jpg" alt="资源监视器"></p><p>5.点击关闭、完成，右键新建好的虚拟机，点击设置，点击CD/DVD，选择使用ISO映像文件，选中下载好的centOS7映像文件，点击确定。</p><p>6.开启创建好的虚拟机，选中Install CentOS7，回车。</p><p><img src="2.jpg" alt="安装CentOS7"></p><p>7.进入之后我们选择中文，点击软件选择，按照下图选择配置，点击完成。</p><p><img src="3.jpg" alt="配置选择"></p><p>8.点击安装位置，选择我要配置分区，点击完成，我们最开始分配给了虚拟机一共20G的内存，现在我们要对这20G内存进行分区，点击加号，添加/boot分区1G，/swap分区2G，/分区17G。将三个分区的设备类型更改为标准分区，将/boot分区和/分区文件系统修改为ext4。</p><p><img src="4.jpg" alt="内存分区"></p><p>9.点开网络和主机名，开启网络连接，点击完成</p><p>10.之后我们开始安装，这个过程中我们可以设置Root密码，创建一个新的用户，因为Linux主张使用普通用户登录，当然你也可以在登录界面点击未登录，输入用户名Root和Root密码登录。安装结束后重启虚拟机，同意许可信息。</p><p>至此安装过程完毕，少侠得到了一柄好剑，江湖之旅即刻开始。</p><h1 id="网络连接的三种模式"><a href="#网络连接的三种模式" class="headerlink" title="网络连接的三种模式"></a>网络连接的三种模式</h1><p><img src="5.jpg" alt="网络连接"></p><p>这一小段，我们认识一下网络的三种连接方式，分别是桥接模式，NAT模式，仅主机模式。首先我们根据图片可以知道，主机A、B、C都处在一个网段之中，所以他们之间可以相互通讯。</p><p>主机A的虚拟机采用的是桥接模式，所以虚拟机和主机处于同一网段，故此A的虚拟机可以和外界比如B的主机，相互连通。但是这样的连通方式存在一个问题，我们要知道，在一个网段中，只能存在255个IP。所以一旦有大量的主机创建了虚拟机，并且选用了桥接模式，就会造成IP冲突。</p><p>我们再看C，C主机的虚拟机是NAT模式，C主机上会生成一个对应的虚拟IP地址(如192.168.100.66 )，虚拟机的IP会和对应的虚拟IP地址相互通讯，C主机的虚拟机IP通过C主机的IP代理来与外部网络通讯，在内网和外网通讯的同时，外网与内网不在同一个网段中。但内网和外网的通讯是单向的，也就是虚拟机网络可以和外网沟通，但外网无法和虚拟机网络沟通。</p><p>最后，仅主机模式就是一个独立的系统，和外部不发生通讯。</p><h1 id="虚拟机克隆"><a href="#虚拟机克隆" class="headerlink" title="虚拟机克隆"></a>虚拟机克隆</h1><p>当我们已经安装了一个Linux系统了，但因为种种原因，我们还需要更多的系统，我们就可以使用虚拟机克隆，我们可以直接使用VMware的克隆操作。注意，在克隆的时候要先关闭Linux系统。</p><p><img src="6.jpg" alt="虚拟机克隆"></p><p>我们右键安装好的Linux系统，找到管理、克隆，之后下一步即可。当然这里面还有一个要注意的地方那就是链接克隆和完整克隆。</p><p><img src="7.jpg" alt="链接克隆和完整克隆"></p><p>链接克隆的意思就好比创建一个引用，我们点击开启连接克隆后的系统和原系统是一样的，只不过我们给原系统起了一个别名。完整克隆的意思是我们真真正正的克隆一个独立的系统和原系统没有瓜葛。</p><h1 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h1><p>当我们在虚拟机中进行操作的时候，可能会有一些危险操作可能会导致系统崩溃，这个时候我们可以使用虚拟机快照，如果系统崩溃可以快速的将Linux系统恢复到我们拍摄快照的时间点。我们右键点击系统，找到快照，点击拍摄快照，这样我们就建立好了一个快照。当我们未来需要恢复的时候可以选择快照管理器，选择回溯到某一个快照的时间节点。</p><p><img src="8.jpg" alt="虚拟机快照"></p><h1 id="虚拟机的迁移和删除"><a href="#虚拟机的迁移和删除" class="headerlink" title="虚拟机的迁移和删除"></a>虚拟机的迁移和删除</h1><p>我们知道虚拟系统在我们主机里面本质上就是一个文件，所以虚拟机的迁移只需要把安装好的虚拟系统这个文件夹整体拷贝或者剪切到目的地即可，删除也很简单只需要在VMware中点击菜单，点击从磁盘中删除即可，或者我们可以直接删除虚拟系统的文件夹，当然如果你选择在VMware中删除虚拟机，要记得先把虚拟机关掉。注意，VMware中的移除，只是将虚拟系统的指向从列表中移除了并不是真正的将虚拟系统从硬盘中删除了。</p><p><img src="9.jpg" alt="虚拟机删除"></p><h1 id="安装VMTools"><a href="#安装VMTools" class="headerlink" title="安装VMTools"></a>安装VMTools</h1><p>VMTools的安装可以让我们更好的在主机中管理VM虚拟机，可以设置Windows和CentOS的共享文件夹。安装方法也很简单，如下：</p><p>1.首先开启我们的Linux系统，点击上方选项卡中的虚拟机，点击安装VMTools或者再次安装VMTools，当然当你安装完虚拟系统后，在下方黄色提示条中会提示你安装VMTools，点击那个安装也可以。</p><p><img src="10.jpg" alt="安装VMTools(1)"></p><p>2.之后我们在Linux的桌面上可以看到一个光盘图标，叫做VMware Tools，我们双击打开</p><p><img src="11.jpg" alt="安装VMTools(2)"></p><p>3.打开后我们可以看到一个压缩文件xx.tar.gz，我们将它拷贝到/opt下（点击其他位置，点击计算机就可以找到opt啦，如果你无法粘贴到/opt下可能是因为你的权限不够需要使用root登录，如果还不可以那粘贴到主文件夹也是可以的）</p><p>4.接下来我们右键点击Linux桌面，打开终端依次输入如下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt    [cd指令的意义是进入一个文件夹中，这里只需要进入xx.tar.gz所在文件夹即可]</span><br><span class="line">tar -zxvf xx.tar.gz (根据你的文件名填写，可以输入VM然后按tab键自动补全)</span><br><span class="line">cd vm(按tab自动补全)</span><br><span class="line">./vmware-install.pl</span><br></pre></td></tr></table></figure><p>之后只要一直按回车，全都使用默认设置即可。</p><p>安装好VMTools后我们来设置共享文件夹，首先我们在Windows系统下找一个地方建立好我们用来共享的文件夹。之后我们右键我们的虚拟系统点击设置，在上方选择选项，点击共享文件夹，点击总是启用，点击添加，添加完成后点击确定即可。之后我们回到Linux中点击其他位置点击计算机点击mnt文件夹，点击hgfs，就可以看到我们的共享文件夹啦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要习得此剑法？&quot;&gt;&lt;a href=&quot;#为什么要习得此剑法？&quot; class=&quot;headerlink&quot; title=&quot;为什么要习得此剑法？&quot;&gt;&lt;/a&gt;为什么要习得此剑法？&lt;/h1&gt;&lt;p&gt;当今世界，强者纵横，Linux被广泛使用，自掌门Linus Benedict</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十七）</title>
    <link href="http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <id>http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/</id>
    <published>2022-09-23T07:05:15.000Z</published>
    <updated>2022-10-03T11:44:09.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="int-9中断例程对键盘输入的处理"><a href="#int-9中断例程对键盘输入的处理" class="headerlink" title="int 9中断例程对键盘输入的处理"></a>int 9中断例程对键盘输入的处理</h1><p>大多数有用的程序都需要处理用户的输入，键盘的输入是最为基本的输入。程序和数据通常需要长期存储，磁盘是最常用的存储设备。BIOS为这两种外设的I/O提供了最基本的中断例程，接下来我们就对它们的应用和相关的问题进行讨论。</p><p>我们之间已经学习过，键盘的输入将引发9号中断，BIOS提供了int 9中断例程。CPU在9号中断发生后，执行int 9中断例程，从60H端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。</p><p>一般的键盘输入，在CPU执行完int 9中断例程后，都放到了键盘缓冲区中，键盘缓冲区有16个字单元，可以储存15个按键的扫描码和对应的ASCII码，接下来我们就从逻辑层面看一下键盘输入的扫描码和对应的ASCII码是如何写入键盘缓冲区的。事实上，键盘缓冲区是用环形队列结构管理的内存区。</p><p>下面想象这样一个场景，我们按下了键盘上的A，B，C，D，E，Shift_A，A。我们来简要的看一下int 9中断例程都做了什么叭！</p><p>1.初始状态下，没有键盘输入，键盘缓冲区空，此时没有任何元素。</p><p><img src="1.jpg" alt="键盘缓冲区内容"></p><p>2.按下A键，引发了键盘中断，CPU执行int 9中断例程，从60H端口读出A键的通码；然后检测状态字节，看看是否有Shift，Ctrl等切换键按下；发现没有切换键按下，就将A键的扫描码1eH和对应的ASCII码，即字母“a”的ASCII码61H，写入键盘缓冲区。缓冲区的字单元中，高位字节存储扫描码，低位字节存储ASCII码。此时缓冲区内容如下。</p><p><img src="2.jpg" alt="键盘缓冲区内容"></p><p>3.按下B键，引发了键盘中断，CPU执行int 9中断例程，从60H端口读出B键的通码；然后检测状态字节，看看是否有切换键按下；发现没有切换键按下，就将B键的扫描码30H和对应的ASCII码，即字母“b”的ASCII码62H，写入键盘缓冲区,此时缓冲区内容如下。</p><p><img src="3.jpg" alt="键盘缓冲区内容"></p><p>4.按下C，D，E键后，缓冲区中的内容如下。</p><p><img src="4.jpg" alt="键盘缓冲区内容"></p><p>5.按下左Shift键，引发键盘中断；int 9中断例程接收左Shift的通码，设置0040:17处的状态字节的第1位为1，表示左Shift按下。</p><p>6.按下A键，引发了键盘中断，CPU执行int 9中断例程，从60H端口读出A键的通码；然后检测状态字节，看看是否切换键按下；发现左Shift被按下，就将A键的扫描码1eH和Shift_A对应的ASCII码，即字母“A”的ASCII码41H，写入键盘缓冲区。此时缓冲区内容如下。</p><p><img src="5.jpg" alt="键盘缓冲区内容"></p><p>7.松开左Shift键，引发键盘中断；int 9中断例程接收左Shift的断码，设置0040:17处的状态字节的第1位为0，表示左Shift松开。</p><p>8.按下A键，引发了键盘中断，CPU执行int 9中断例程，从60H端口读出A键的通码；然后检测状态字节，看看是否切换键按下；发现没有切换键按下，就将A键的扫描码1eH和对应的ASCII码，即字母“a”的ASCII码61H，写入键盘缓冲区。缓冲区的字单元中，高位字节存储扫描码，低位字节存储ASCII码。此时缓冲区内容如下。</p><p><img src="6.jpg" alt="键盘缓冲区内容"></p><h1 id="使用int-16H中断例程读取键盘缓冲区"><a href="#使用int-16H中断例程读取键盘缓冲区" class="headerlink" title="使用int 16H中断例程读取键盘缓冲区"></a>使用int 16H中断例程读取键盘缓冲区</h1><p>BIOS提供了int 16H中断例程供程序员调用。int 16H中断例程中包含的一个最重要的功能是从键盘缓冲区读取一个键盘输入，该功能编号为0。下面的指令从键盘缓冲区读取一个键盘输入，并且将其从缓冲区中删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ah,0</span><br><span class="line">int 16H</span><br></pre></td></tr></table></figure><p>结果是(ah)=扫描码，(al)=ASCII码。接下来我们看一下int16H如何读取键盘缓冲区。</p><p>1.执行上述两条指令后，缓冲区中的内容如下：</p><p><img src="7.jpg" alt="键盘缓冲区内容"></p><p>2.再次执行，缓冲区中内容如下：</p><p><img src="8.jpg" alt="键盘缓冲区内容"></p><p>3.连续执行5次后，缓冲区为空：</p><p><img src="1.jpg" alt="键盘缓冲区内容"></p><p>4.再次执行，int 16H检测到键盘缓冲区，发现缓冲区为空，则循环等待，直到缓冲区中有数据。</p><p>5.按下A键后，缓冲区中的内容如下：</p><p><img src="9.jpg" alt="键盘缓冲区内容"></p><p>6.循环等待的int 16H中断例程检测到键盘缓冲区中有数据，将其读出，缓冲区又为空。</p><p><img src="1.jpg" alt="键盘缓冲区内容"></p><p>ah中内容为1EH，al中内容为61H</p><p>从上面我们可以看出，int 16中断例程的0号功能，进行如下的工作：</p><ol><li>检测键盘缓冲区中是否有数据</li><li>没有则继续做第一步</li><li>读取缓冲区第一个字单元中的键盘输入</li><li>将读取的扫描码送入ah，ASCII码送入al</li><li>将已读取的键盘输入从缓冲区中删除</li></ol><p>可见，BIOS的int 9中断例程和int 16H中断例程是一对相互配合的程序，int 9中断例程向键盘缓冲区中写入，int 16H中断例程从缓冲区中读出。它们写入和读出的时机不同，int 9中断例程是在有键按下的时候向键盘缓冲区中写入数据；而int 16H中断例程是在应用程序对其调用的时候，将数据从键盘缓冲区中读出。我们在编写一般的处理键盘输入的程序的时候，可以调用int 16H从键盘缓冲区中读取键盘的输入。</p><h1 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h1><p>用户通过键盘输入的通常不仅仅是单个字符而是字符串。最基本的字符串输入程序，需要具备下面的功能：</p><ol><li>在输入的同时需要显示这个字符串</li><li>一般在输入回车符后，字符串输入结束</li><li>能够删除已经输入的字符</li></ol><p>接下来我们试着编写一个接收字符串输入的子程序，实现上面3个基本功能。因为在输入的过程中需要显示，子程序的参数如下：</p><p>(dh)、(dl)=字符串在屏幕上显示的行、列位置；ds:si指向字符串的存储空间，字符串以0为结尾符。</p><p>首先，我们要先解决字符的输入和删除，每个新输入的字符都存储在前一个输入的字符之后，而删除是从最后面的字符进行的，这一点可以想象我们平时输入输出的场景。可以知道字符的输入和输出是按照栈的访问规则进行的，即后进先出。这样，我们就可以用栈的方式来管理字符串的存储空间，也就是说字符串的存储空间实际上是一个字符栈。字符栈中的所有字符，从栈底到栈顶，组成一个字符串。第二，我们要在输入回车符后，结束这个字符串，这个很好实现，我们可以在输入回车符后在字符串中加入0，表示字符串结束。最后，我们在输入字符串的同时要显示这个字符串，也就是每次有新的字符输入和删除一个字符的时候，都应该重新显示字符串，即从字符栈的栈底到栈顶，显示所有的字符。</p><p>现在我们可以简单地确定程序的处理过程：</p><ol><li>调用int 16H读取键盘输入</li><li>如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行1</li><li>如果是退格键，就从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行1</li><li>如果是enter键，向字符栈中压入0，返回</li></ol><p>可见整个过程中，字符出栈，入栈，显示的操作很频繁，应该写成子程序。完整的接收字符串输入的子程序，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">getstr:push ax</span><br><span class="line">getstrs:mov ah,0</span><br><span class="line">int 16H</span><br><span class="line">cmp al,20H</span><br><span class="line">jb nochar</span><br><span class="line">mov ah,0</span><br><span class="line">call charstack</span><br><span class="line">jmp getstrs</span><br><span class="line">nochar:cmp ah,0eH</span><br><span class="line">je backspace</span><br><span class="line">cmp ah,1cH</span><br><span class="line">je enther</span><br><span class="line">jmp getstrs</span><br><span class="line">backspace:mov ah,1</span><br><span class="line">call charstack</span><br><span class="line">jmp getstrs</span><br><span class="line">enter:mov al,0</span><br><span class="line">mov ah,0</span><br><span class="line">call charstack</span><br><span class="line">mov ah,2</span><br><span class="line">call charstack</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line">charstack:jmp short charstart</span><br><span class="line">table dw charpush,charpop,charshow</span><br><span class="line">top dw 0</span><br><span class="line">charstart:push bx</span><br><span class="line">push dx</span><br><span class="line">push di</span><br><span class="line">push es</span><br><span class="line">cmp ah,2</span><br><span class="line">ja sret</span><br><span class="line">mov bl,ah</span><br><span class="line">mov bh,0</span><br><span class="line">add bx,bx</span><br><span class="line">jmp word ptr table[bx]</span><br><span class="line">charpush:mov bx,top</span><br><span class="line">mov [si][bx],al</span><br><span class="line">inc top</span><br><span class="line">jmp sret</span><br><span class="line">charpop:cmp top,0</span><br><span class="line">je sret</span><br><span class="line">dec top</span><br><span class="line">mov bx,top</span><br><span class="line">mov al,[si][bx]</span><br><span class="line">jmp sret</span><br><span class="line">charshow:mov bx,0b800H</span><br><span class="line">mov es,bx</span><br><span class="line">mov al,160</span><br><span class="line">mov ah,0</span><br><span class="line">mul dh</span><br><span class="line">mov di,ax</span><br><span class="line">add dl,dl</span><br><span class="line">mov dh,0</span><br><span class="line">add di,dx</span><br><span class="line">mov bx,0</span><br><span class="line">charshows:cmp bx,top</span><br><span class="line">jne noempty</span><br><span class="line">mov byte ptr es:[di],&#x27; &#x27;</span><br><span class="line">jmp sret</span><br><span class="line">noempty:mov al,[si][bx]</span><br><span class="line">mov es:[di],al</span><br><span class="line">mov byte ptr es:[di+2],&#x27; &#x27;</span><br><span class="line">inc bx</span><br><span class="line">add di,2</span><br><span class="line">jmp charshows</span><br><span class="line">sret:pop es</span><br><span class="line">pop di</span><br><span class="line">pop dx</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h1 id="应用int-13H中断例程对磁盘进行读写"><a href="#应用int-13H中断例程对磁盘进行读写" class="headerlink" title="应用int 13H中断例程对磁盘进行读写"></a>应用int 13H中断例程对磁盘进行读写</h1><p>我们主要以3.5英寸软盘为例，3.5英寸软盘分为上下两面，每面80个磁道，每个磁道又分为18个扇面，每个扇面区的大小为512字节。所以3.5英寸软盘大约是1.44MB。磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘，只能以扇区为单位对磁盘进行读写。在读写扇区的时候，要给出面号，磁道号和扇区号。面号和磁盘号从0开始，而扇区号从1开始。BIOS提供了一些中断例程可以访问磁盘，比如int 13H。如果我们想读取0面0道1扇区的内容到0:200，那么程序是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200H</span><br><span class="line">mov al,1</span><br><span class="line">mov ch,0</span><br><span class="line">mov cl,1</span><br><span class="line">mov dl,0</span><br><span class="line">mov dh,0</span><br><span class="line">mov ah,2</span><br><span class="line">int 13H</span><br></pre></td></tr></table></figure><p>其中，(ah)表示int 13H的功能号，(al)表示读取的扇区数，(ch)表示磁道号，(cl)表示扇区号，(dh)表示磁头号(对于软盘即面号，因为一个面用一个磁头来读写)，(dl)表示驱动器号软驱从0开始，0：软驱A，1：软驱B，硬盘从80H开始，80H：硬盘C，81H：硬盘D。如果操作成功(ah)=0，(al)=读入的扇区数，如果操作失败(ah)=出错代码。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此，汇编的学习告一段落，感谢各位能耐心阅读！更新完整个系列后有一种如释重负的感觉，好像完成了一件大事一样，虽然只是学完了一本书。博主也只是一个在校大学生，刚刚开始写博客，所有内容都是一点点看书，选择性记录的，虽然看起来还是有点像搬运，而且很古板粗糙。。。不过至少整个过程还是有收获滴！接下来，博主也会慢慢的写一写其他的系列，最后再次感谢，可以耐心看本系列的朋友们，我们下个系列见！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十六）</title>
    <link href="http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <id>http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/</id>
    <published>2022-09-23T07:04:03.000Z</published>
    <updated>2022-10-02T12:20:03.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="描述了单元长度的标号"><a href="#描述了单元长度的标号" class="headerlink" title="描述了单元长度的标号"></a>描述了单元长度的标号</h1><p>我们之前，一直在代码段中使用标号来标记指令、数据、段的起始地址。比如，下面的代码将code段中的a标号处的8个数据累加，结果储存到b标号处的字中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">a: db 1,2,3,4,5,6,7,8</span><br><span class="line">b: dw 0</span><br><span class="line">start:mov si,offset a</span><br><span class="line">mov bx,offset b</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov al,cs:[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add cs:[bx],ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>程序中，code、a、b、start、s都是标号。这些标号仅仅表示了内存单元的地址。我们还可以使用另一种符号，这种符号不仅可以表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。上面程序还可以写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">start:mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov al,a[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add b,ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>在code段中使用的标号a、b后面没有”:”，它们是同时描述内存单元长度和内存地址的标号。标号a，描述了地址code:0，和从这个地址开始，以后的内存单元都是字节单元；而标号b描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元。</p><p>因为这种标号包含了对单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。比如，对于程序中的”b dw 0”：</p><p>指令：mov ax,b 相当于：mov ax,cs:[8]</p><p>指令中，标号b代表了一个内存单元，地址为code:8，长度为两个字节。如果使用指令mov al,b就会引起编译错误，因为b代表的内存单元是字单元。我们称这种标号为数据标号，它标记了存储数据的单元的地址和长度。</p><h1 id="在其他段中使用数据标号"><a href="#在其他段中使用数据标号" class="headerlink" title="在其他段中使用数据标号"></a>在其他段中使用数据标号</h1><p>一般来说，我们不会在代码段里面定义数据，而是将数据定义到其他段中，在其他段中我们也可以使用数据标号来描述存储数据的单元的地址和长度。不过需要注意的是在后面加有“：”的地址标号，只能在代码段中使用，不能在其他段中使用。下面的程序将data段中a标号处的8个数据累加，结果存储到b标号处的字中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov al,a[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add b,ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mob ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>之前我们说将我们定义的段和相关的寄存器使用伪指令assume联系起来，比如上面的程序中我们就讲cs和code段，ds和data段联系在了一起。之所以这样做是因为我们后来在代码段中使用了数据标号，也就是说当我们将数据定义到其他段中后，想要在代码段使用数据标号就必须使用伪指令assume将段和段寄存器联系起来，否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中，当然这种联系是编译器需要的，但绝对不是说，我们因为编译器的工作需要，用assume指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。所以我们为了程序可以正确访问data段，我们会在代码段的开始使用指令，设置ds指向data段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure><p>我们可以将标号当做数据来定义，此时，编译器将标号所表示的地址当作数据的值，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>数据标号c处存储的两个字型数据为标号a、b的偏移地址相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw offset a,offset b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dd a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>数据标号c处存储的两个双字型数据为标号a、b的偏移地址和段地址相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw offset a,seg a,offset b,seg b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>seg操作符功能为获取某一个标号的段地址。</p><h1 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h1><p>接下来我们通过一个问题引入这个小节的学习，我们现在要编写一个子程序，以十六进制的形式在屏幕中间显示给定的字节型数据。首先一个字节需要两个十六进制数来表示，那我们可以将一个字节的高四位和低四位分开，分别用它们的值得到对应的数码字符。比如2BH，我们可以得到高四位的2和低四位的11，但我们怎么能得到对应的数码字符呢？</p><p>最简单的方法就是一个一个比较，0就是0,1就是1……10就是A,11就是B，但这样有太麻烦了，有太多的比较指令和转移指令了。我们要在0-15和0-F之间找到一种映射关系。</p><p>0-9和字符“0”-“9“的关系显而易见：数值+30H=对应字符的ASCII值，同样我们也可以知道10-15和”A“-”F“之间的对应关系：数值+37H=对应字符的ASCII值。现在我们就可以将数值转换为字符了，因为映射关系存在差异，我们要判断数值是否大于9。</p><p>虽然已经简化很多了，但人嘛，总是追求最简单，最省力的办法，因为0-15和字符“0”-“F”之间没有一致的映射关系存在，所以我们应该在它们之间建立新的映射关系。具体做法是建立一张表，表中依次存放字符“0”-“F”,我们可以通过数值0-15直接查找到对应的字符。子程序如下，其中使用al传送要显示的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">showbyte:jmp short show</span><br><span class="line">table db &#x27;0123456789ABCDEF&#x27;</span><br><span class="line">show:push bx</span><br><span class="line">push es</span><br><span class="line">mov ah,al</span><br><span class="line">shr ah,1</span><br><span class="line">shr ah,1</span><br><span class="line">shr ah,1</span><br><span class="line">shr ah,1;右移4位，ah中得到高四位的值</span><br><span class="line">and ah,00001111b;al中为低四位的值</span><br><span class="line">mov bl,ah</span><br><span class="line">mov bh,0</span><br><span class="line">mov ah,table[bx];用高四位的值作为相对于table的偏移，取得对应的字符</span><br><span class="line">mov bx,0B800H</span><br><span class="line">mov es,bx</span><br><span class="line">mov es:[160*12+40*2],ah</span><br><span class="line">mov bl,al</span><br><span class="line">mov bh,0</span><br><span class="line">mov al,table[bx];用低四位的值作为相对于table的偏移，取得对应的字符</span><br><span class="line">mov es:[160*12+40*2+2],al</span><br><span class="line">pop es</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>可以看到我们在子程序中，使用了一个表建立了两个集合之间的关系，这样做的目的一般有以下三个：</p><ol><li>为了算法的清晰和简洁</li><li>为了加快运算速度</li><li>为了使程序易于扩充</li></ol><p>我们的程序通过给出的数据进行比较而得到的结果的问题，转化为用给出的数据作为查表的依据，通过查表得到结果的问题。具体的查表方法，是用查表的依据数据，直接计算出所要查找的元素在表中的位置。像这种可以通过依据数据，直接计算出所要找的元素的位置的表，我们称其为直接定址表。</p><h1 id="程序入口地址的直接定址表"><a href="#程序入口地址的直接定址表" class="headerlink" title="程序入口地址的直接定址表"></a>程序入口地址的直接定址表</h1><p>我们可以在直接定址表中存储子程序的地址，从而方便地实现不同子程序的调用。假设我们现在有四个子程序a，b，c，d，我们可以将这四个子程序的入口地址存储到一个表中，它们在表中的位置和功能号相对应。对应关系为：功能号*2=对应功能子程序在地址表中的偏移。程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setscreen:jmp short set</span><br><span class="line">table dw a,b,c,d</span><br><span class="line">set:push bx</span><br><span class="line">cmp ah,3</span><br><span class="line">ja sret</span><br><span class="line">mov bl,ah</span><br><span class="line">mov bh,0</span><br><span class="line">add bx,bx</span><br><span class="line">call word ptr table[bx]</span><br><span class="line">sret:pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>我们通过使用直接定址表，根据功能号调用对应子程序的做法，使程序结构清晰，便于扩充，如果我们未来想要加入一个新的功能只需要在地址表中加入它的入口地址就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十五）</title>
    <link href="http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/</id>
    <published>2022-09-23T07:03:55.000Z</published>
    <updated>2022-10-02T08:50:41.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h1><p>我们知道CPU不仅仅只有运算功能，它还有I/O（Input/Output，输入/输出）能力，比如我们打开文本编辑器，按一下键盘，然后我们就可以看到屏幕出现了我们按下的按键，是CPU将从键盘上的键所对应的字符送到显示器上的。要及时处理外设的输入，显然需要解决两个问题：</p><ol><li>外设的输入可能随时发生，CPU怎么知道呢？</li><li>CPU从何处得到外设的输入？</li></ol><p>这一篇我们就以键盘输入为例，讨论这两个问题。</p><h1 id="接口芯片和端口"><a href="#接口芯片和端口" class="headerlink" title="接口芯片和端口"></a>接口芯片和端口</h1><p>第14篇我们讲过，PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片内部有若干个寄存器，CPU将这些寄存器当做端口来访问。外设的输入不直接进入内存和CPU而是先进入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。CPU还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。可见，CPU通过端口和外部设备进行联系。</p><h1 id="外中断信息"><a href="#外中断信息" class="headerlink" title="外中断信息"></a>外中断信息</h1><p>我们知道外设的输入被放到了端口里，那CPU如何及时的知道并处理呢？CPU提供中断机制来满足这种需求，前面说过，CPU内部有需要处理的事情发生的时候，将产生中断信息，引发中断过程。中断信息来自CPU内部。还有一种中断信息，来自于CPU外部，当CPU外部有需要处理的事情发生时，比如说外设的输入到达。这个时候相关芯片会向CPU发出相应的中断信息。CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。在PC系统中，外中断源一共分为一下两种。</p><h2 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h2><p>可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。当CPU检测到可屏蔽中断信息时，如果IF=1，则CPU在执行完当前指令后响应中断，引发中断过程，如果IF=0,则不响应可屏蔽中断。</p><p>我们来回忆一下内中断所引发的中断过程：</p><ol><li>取中断类型码N</li><li>标志寄存器入栈，IF=0，TF=0</li><li>CS、IP入栈</li><li>(IP)=(n×4)，(CS)=(n×4+2)</li></ol><p>由此转去执行中断处理程序。</p><p>可屏蔽中断所引发的中断过程，除在第1步的是实现上有所不同外，基本上和内中断一样。因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；而内中断的中断类型码是在CPU内部生成的。</p><p>现在我们就可以解释为什么中断过程中要设置IF为0了，因为在进入中断处理程序之后，禁止其他的可屏蔽中断。当然，如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置为1。8086CPU提供了两条指令设置IF分别是：</p><ol><li>sti，设置IF=1</li><li>cli，设置IF=0</li></ol><h2 id="不可屏蔽中断"><a href="#不可屏蔽中断" class="headerlink" title="不可屏蔽中断"></a>不可屏蔽中断</h2><p>不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前的指令后，立即响应，引发中断过程。对于8086CPU，不可屏蔽中断的中断过程类型码固定为2，所以中段过程中，不需要取中断类型码。所以不可屏蔽中断的中断过程为：</p><ol><li>标志寄存器入栈，IF=0，TF=0</li><li>CS、IP入栈</li><li>(IP)=(8)，CS=(0AH)</li></ol><p>几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件（比如说键盘输入）发生时，相关芯片向CPU发出可屏蔽中断信息。不可屏蔽中断是在系统中有必须处理的紧急情况发生时来通知CPU的中断信息。我们主要讨论可屏蔽信息。</p><h1 id="PC机键盘的处理过程"><a href="#PC机键盘的处理过程" class="headerlink" title="PC机键盘的处理过程"></a>PC机键盘的处理过程</h1><p>我们接下来看一下键盘输入的处理过程，并以此来体会一下PC机处理外设输入的基本方法。</p><h2 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h2><p>键盘上的每一个键就相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60H。当我们松开这个键的时候，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也会被送到端口60H中。</p><p>一般来说将按下一个键时产生的扫描码叫做通码，松开一个键时产生的扫描码叫做断码，扫描码的长度为一个字节，通码的第7位为0，断码的第7位为1，即断码=通码+80H。</p><h2 id="引发9号中断"><a href="#引发9号中断" class="headerlink" title="引发9号中断"></a>引发9号中断</h2><p>当键盘的输入到达60H端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。CPU检测到该中断信息后，如果IF=1，则响应中断，引发中断过程，转去执行int 9中断例程。</p><h2 id="执行int-9中断例程"><a href="#执行int-9中断例程" class="headerlink" title="执行int 9中断例程"></a>执行int 9中断例程</h2><p>BIOS提供了int 9中断例程，用来进行基本的键盘输入处理，主要工作如下：</p><ol><li>读出60H端口中的扫描码</li><li>如果是字符键的扫描码，将该扫描码和它所对应的字符码，也就是ASCII码送入内存中的BIOS键盘缓冲区；如果是控制键(比如Ctrl)和切换键(比如CapsLock)的扫描码，则将其转变为状态字节(用二进制位记录控制键和切换键状态的字节)写入内存中储存状态字节的单元。</li><li>对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。</li></ol><p>BIOS键盘缓冲区是系统启动后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区。该内存区可以储存15个键盘输入，因为int 9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，低位字节存放字符码。0040:17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下：</p><p><img src="1.jpg" alt="键盘状态字节各位记录的信息"> </p><h1 id="安装新的int-9中断例程"><a href="#安装新的int-9中断例程" class="headerlink" title="安装新的int 9中断例程"></a>安装新的int 9中断例程</h1><p>接下来我们要安装一个新的int 9中断例程，使原来的int 9中断例程功能得到扩展。我们的任务是在DOS下，按F1键后改变当前屏幕的显示颜色，其他键照常处理。首先我们分别思考几个问题：</p><p>1.改变屏幕的显示颜色</p><p>改变从B800H开始的4000个字节中的所有奇地址单元中的内容，当前屏幕的显示颜色即发生改变。程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0B800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,1</span><br><span class="line">mov cx,2000</span><br><span class="line">s:inc byte ptr es:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>2.其他键照常处理</p><p>可以调用原int 9中断处理程序，来处理其他的键盘输入</p><p>3.原int 9中断例程入口地址的保存</p><p>因为在编写新的int 9中断例程中要调用原int 9中断例程，所以，要保存原int 9中断例程的入口地址。要保存在哪里？显然不能保存在安装程序中，因为安装程序返回后地址将丢失。我们将地址保存在0:200单元处。</p><p>4.新int 9中断例程的安装</p><p>我们可以将新的int 9中断例程安装在0:204处。</p><p>完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,128</span><br><span class="line">push cs</span><br><span class="line">pop ds</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,offset int9;设置ds:si指向源地址</span><br><span class="line">mov di,204H;设置es:di指向目的地址</span><br><span class="line">mov cx,offset int9end-offset int9;设置cx为传输长度</span><br><span class="line">cld;设置传输方向为正</span><br><span class="line">rep movsb</span><br><span class="line">push es:[9*4]</span><br><span class="line">pop es:[200H]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop es:[202H]</span><br><span class="line">cli</span><br><span class="line">mov word ptr es:[9*4],204H</span><br><span class="line">mov word ptr es:[9*4],0H</span><br><span class="line">sti</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">int9:push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">in al,60H</span><br><span class="line">pushf</span><br><span class="line">call dword ptr cs:[200H]</span><br><span class="line">cmp al,3bH</span><br><span class="line">jne int9ret</span><br><span class="line">mov ax,0b800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,1</span><br><span class="line">mov cx,2000</span><br><span class="line">s:inc byte ptr es:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">int9ret:pop es</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line">int9end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这一篇我们通过对键盘输入的处理，讲解了CPU对外设输入的通常处理方法。即：</p><ol><li>外设的输入送入端口</li><li>向CPU发出外中断(可屏蔽中断)信息</li><li>CPU检测到可屏蔽中断信息，如果IF=1，CPU在执行完当前指令后响应中断，执行响应的中断处理程序</li><li>可在中断例程中实现对外设输入的处理</li></ol><p>端口和中断机制，是CPU进行I/O的基础。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十四）</title>
    <link href="http://example.com/2022/09/22/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://example.com/2022/09/22/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/</id>
    <published>2022-09-22T15:26:07.000Z</published>
    <updated>2022-09-23T07:01:38.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>我们前面讲过，各种存储器都和CPU的地址线、数据线、控制线相连。CPU在操控它们的时候，把它们都当作内存来看待，把它们总地看做一个由若干存储单元组成的逻辑存储器，这个逻辑存储器我们称其为内存地址空间。</p><p>在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有一下三种芯片：</p><ol><li>各种接口卡上的接口芯片，它们控制接口卡进行工作</li><li>主板上的接口芯片，CPU通过它们对部分外设尽心访问</li><li>其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。</li></ol><p>这些芯片都有一组可以由CPU读写的寄存器。这些寄存器，它们在物理上可能处于不同的芯片中，但是它们在以下两点上相同：</p><ol><li>都和CPU的总线相连，当然这种连接是通过它们所在的芯片进行的</li><li>CPU对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令。</li></ol><p>可见，从CPU的角度，将这些寄存器都当作端口，对它们统一编址，从而建立了一个统一的端口地址空间。每一个端口都在地址空间中有一个地址。</p><p>CPU可以从以下三个地方直接读写数据：</p><ol><li>CPU内部的寄存器</li><li>内存单元</li><li>端口</li></ol><p>这篇我们就讨论一下端口的读写。</p><h1 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h1><p>在访问端口的时候，CPU通过端口地址定位端口。因为端口所在的芯片和CPU通过地址总线相连，所以，端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口。则端口地址的范围为0~65535。</p><p>对于端口的读写就不能使用mov、push、pop等内存读写指令了，端口的读写指令只有两条：in和out，分别对应从端口读取数据和向端口写入数据。</p><p>我们看一下CPU执行内存访问指令和端口访问指令时，总线上的信息：</p><p>（1）访问内存：</p><p>mov ax,ds:[8]    </p><p>假设执行前(ds)=0，那么执行时与总线相关的操作如下所示：</p><ol><li>CPU通过地址线将地址信息8发出</li><li>CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据</li><li>存储器将8号单元中的数据通过数据线送入CPU</li></ol><p>（2）访问端口：</p><p>in al，60H</p><p>这条指令代表从60H端口读入一个字节，那么执行时与总线相关的操作如下：</p><ol><li>CPU通过地址线将地址信息60H发出</li><li>CPU通过发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据</li><li>端口所在的芯片将60H端口中的数据通过数据线送入CPU</li></ol><p>注意，在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位端口时用ax。</p><p>对0~255以内的端口进行读写时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20H</span><br><span class="line">out 20H,al</span><br></pre></td></tr></table></figure><p>对255~65535以内的端口进行读写时,端口号放在dx中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h;将端口号3f8h送入dx</span><br><span class="line">in al,dx;从3f8h端口读入一个字节</span><br><span class="line">out dx,al;向3f8h端口写入一个字节</span><br></pre></td></tr></table></figure><h1 id="CMOS-RAM芯片"><a href="#CMOS-RAM芯片" class="headerlink" title="CMOS RAM芯片"></a>CMOS RAM芯片</h1><p>下面，我们通过对CMOS RAM芯片的读写体会一下对端口的访问。首先我们介绍一下CMOS RAM芯片，这个芯片其中包含一个实时钟和一个有128个存储单元的RAM存储器（早期的计算机为64个字节）。该芯片靠电池供电。所以，关机后其内部的实时钟仍可以工作，RAM中信息不会丢失。128个字节的RAM中，内部实时钟占用0~0dH来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息。这个芯片内部有两个端口，端口地址为70H和71H。CPU通过这两个端口来读写CMOS RAM。端口70H为地址端口，存放要访问的CMOS RAM单元地址；71H为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。可见，CPU对CMOS RAM的读写分两步进行，比如要读取CMOS RAM的2号单元：</p><ol><li>将2送入端口70H</li><li>从端口71H读出2号单元的内容</li></ol><h1 id="shl和shr指令"><a href="#shl和shr指令" class="headerlink" title="shl和shr指令"></a>shl和shr指令</h1><p>shl是逻辑左移指令，它的功能是：</p><ol><li>将一个寄存器或内存单元中的数据向左移位</li><li>将最后移出的一位写入CF中</li><li>最低位用0补充</li></ol><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000B</span><br><span class="line">shl al,1</span><br></pre></td></tr></table></figure><p>执行后(al)=10010000B，CF=0。注意如果移动的位数大于1时，必须将移动位数放在cl中。CF值只看最后一位被移出的数字，比如移出3位，那么CF的值就看第三位被移出的值是多少就是多少。可以看出将X逻辑左移一位，就相当于执行X=X*2。</p><p>shr是逻辑右移指令，它的功能和shl相反是：</p><ol><li>将一个寄存器或内存单元中的数据向右移位</li><li>将最后移出的一位写入CF中</li><li>最高位用0补充</li></ol><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">shr al,1</span><br></pre></td></tr></table></figure><p>执行后(al)=01000000B，CF=1。同样如果移动的位数大于1时，必须将移动位数放在cl中。可以看出将X逻辑右移一位，就相当于执行X=X/2。</p><h1 id="CMOS-RAM中存储的时间信息"><a href="#CMOS-RAM中存储的时间信息" class="headerlink" title="CMOS RAM中存储的时间信息"></a>CMOS RAM中存储的时间信息</h1><p>在CMOS RAM中，存放着当前的时间：年、月、日、时、分、秒。这6个信息的长度都为1个字节，存放单元为：</p><p>秒：0    分：2    时：4    日：7    月：8    年：9</p><p>这些数据以BCD码的方式存放，BCD码是以4位二进制数表示十进制数码的编码方式，比如，数值26，用BCD码表示就是：0010(2) 0110(6)，可见，一个字节可以表示两个BCD码，高4位表示十位，低4位表示个位。现在我们要做这样的一件事：在屏幕中间显示当前的月份。</p><p>首先，这个程序要先从CMOS RAM的8号单元取出月份的BCD码，那我们要先向端口70H中写入地址信息，然后再端口71H中取出信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,8</span><br><span class="line">out 70H,al</span><br><span class="line">inal,71H</span><br></pre></td></tr></table></figure><p>我们拿到了BCD码后，要以十进制的形式显示到屏幕上，我们可以看出，BCD码值=十进制数码值，则BCD码值+30H=十进制数对应的ASCII码，为了实现这个功能，我们要做这样的两件事：</p><p>1.将从CMOS RAM的8号单元中读出的一个字节，分为两个表示BCD码值的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ah,al;al中为从CMOS RAM的8号单元中读出的数据</span><br><span class="line">mov cl,4</span><br><span class="line">shr ah,cl;ah中为月份的十位数码值</span><br><span class="line">and al,00001111b;al中为月份的个位数码值</span><br></pre></td></tr></table></figure><p>2.显示(ah)+30H和(al)+30H对应的ASCII码字符。</p><p>完整的程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov al,8</span><br><span class="line">out 70H,al</span><br><span class="line">in al,71H</span><br><span class="line">mov ah,al</span><br><span class="line">mov cl,4</span><br><span class="line">shr ah,cl</span><br><span class="line">and al,00001111B</span><br><span class="line">add ah,30H</span><br><span class="line">add al,30H</span><br><span class="line">mov bx,0b800H</span><br><span class="line">mov es,bx</span><br><span class="line">movbyte ptr es:[160*12+40*2],ah</span><br><span class="line">mov byte ptr es:[160*12+40*2+2],al</span><br><span class="line">mov 4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十三）</title>
    <link href="http://example.com/2022/09/20/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2022/09/20/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/</id>
    <published>2022-09-20T14:27:26.000Z</published>
    <updated>2022-09-23T04:50:51.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h1><p>本篇我们将介绍另一种重要的内中断，由int指令引发的中断。</p><p>int指令的格式为：int N，N为中断类型码，它的功能是引发中断过程。当CPU执行一条int指令时就相当于引发一个N号中断的中断过程，执行过程如下：</p><ol><li>取中断类型码N</li><li>标志寄存器入栈，IF=0,TF=0</li><li>CS、IP入栈</li><li>(IP)=(N×4)，(CS)=(N×4+2)</li></ol><p>从此处转去执行N号中断的中断处理程序。</p><p>可以在程序中使用int指令调用任何一个中断的中断处理程序。比如我们修改上一章中的程序，将结束时使用的int指令改为int 0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,offset do0end-offset do0</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200H</span><br><span class="line">mov word ptr es:[0*4+2],0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 0</span><br><span class="line">do0:</span><br><span class="line">jmp short do0start</span><br><span class="line">db &quot;OVERFLOW!&quot;</span><br><span class="line">do0start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,202H</span><br><span class="line">mov ax,0B800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,12*160+36*2</span><br><span class="line">mov cx,9</span><br><span class="line">s:mov al,[si]</span><br><span class="line">mov es:[di],al</span><br><span class="line">inc si</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>我们执行这个程序:</p><p><img src="1.jpg" alt="int指令引发0号中断"></p><p>我们可以看到在屏幕中间出现了”OVERFLOW!”，程序中本来是没有除法出现的，那么按理来讲就不会触发0号中断处理程序，但现在0号中断处理程序被调用了，这印证了我们之前说到的int指令可以根据类型中断码调用任何一个中断的中断处理程序。</p><h1 id="编写供应用程序调用的中断例程"><a href="#编写供应用程序调用的中断例程" class="headerlink" title="编写供应用程序调用的中断例程"></a>编写供应用程序调用的中断例程</h1><p>前面我们已经写过0号中断例程了，现在我们讨论如何编写可以供程序调用的中断例程的编写方法，现在有这样一个场景：</p><p>功能：将一个全是字母，以0结尾的字符串，转化为大写。</p><p>参数：ds:si指向字符串的首地址。</p><p>应用举例：将data段中的字符串转化为大写。</p><p>首先和我们之前做的一样要先将我们的中断例程安装到内存之中，这样才可以供应用程序调用，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset capital</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,offset capitalend-offset capital</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[7cH*4],200H</span><br><span class="line">mov word ptr es:[7cH*4+2],0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">capital:push cx</span><br><span class="line">push si</span><br><span class="line">change:mov cl,[si]</span><br><span class="line">mov ch,0</span><br><span class="line">jcxz ok</span><br><span class="line">and byte ptr [si],11011111B</span><br><span class="line">inc si</span><br><span class="line">jmp short change</span><br><span class="line">ok:pop si</span><br><span class="line">pop cx</span><br><span class="line">iret</span><br><span class="line">capitalend:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里需要注意的是在中断例程capital中使用了寄存器si和cx，编写中断例程和编写子程序是一样的要注意寄存器冲突的问题，这点非常重要。执行完安装程序后，我们就可以使用中断类型码7C来实现字符串转大写的操作啦，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;conversation&#x27;,0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">int 7cH</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="对int、iret和栈的深入理解"><a href="#对int、iret和栈的深入理解" class="headerlink" title="对int、iret和栈的深入理解"></a>对int、iret和栈的深入理解</h1><p>我们在学习这部分内容前，先思考一个问题：我们怎么才可以用中断例程7cH中断例程完成loop指令的功能。我们先思考loop指令，loop的执行需要两个信息，循环次数和到s的位移，所以，7cH中断例程要完成loop指令的功能，也需要这两个信息作为参数，我们用cx存放循环次数，用bx存放位移。现在我们想要在屏幕中间显示80个“!”,我们先给出完整代码然后分析一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,0b800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,160*12</span><br><span class="line">mov bx,offset s-offset se</span><br><span class="line">mov cx,80</span><br><span class="line">s:mov byte ptr es:[di],&#x27;!&#x27;</span><br><span class="line">add di,2</span><br><span class="line">int 7cH</span><br><span class="line">se:nop</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>上面的程序中，用int 7ch调用7ch中断例程进行转移，用bx传递转移的位移。为了模拟loop指令，7ch中断例程应该具有以下两个功能：</p><ol><li>dec cx</li><li>如果(cx)≠0，转到标号s处执行，否则向下执行。</li></ol><p>我们根据这两个功能分析一下7cH中断例程如何实现到目的地址的转移，转到标号s这显然是要使用标号s的地址设置CS和IP，但中断例程怎么才能拿到标号s的段地址和偏移地址呢？还记得吗？当CPU执行int指令后会将CS和IP压入栈中，这里的CS就是当前程序段的段地址，IP是int指令的下一条指令的偏移地址。可见，在中断例程中，可以从栈中取得标号s的段地址和标号se的偏移地址，而用标号se的偏移地址加上bx中存放的转移位移就可以得到标号s的偏移地址。</p><p>现在我们知道，可以从栈中直接和间接的获得标号s的段地址和偏移地址，那么我们要怎么用它们设置CS:IP呢？我们可以使用iret指令，我们将栈中的se的偏移地址加上bx中的转移位移，则栈中的se的偏移地址就变成了s的偏移地址。我们再用iret指令，用栈中的内容设置CS、IP，从而实现转移到标号s处。7cH中断例程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lp:push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">dec cx</span><br><span class="line">jcxz lpret</span><br><span class="line">add [bp+2],bx</span><br><span class="line">lpret:pop bp</span><br><span class="line">iret</span><br></pre></td></tr></table></figure><p>因为要访问栈，使用了bp，在程序开始处将bp入栈保存，结束时出栈恢复。当要修改栈中se的偏移地址的时候，栈中的情况为：栈顶处是bp原来的数值，下面是se的偏移地址，再下面是s的段地址，再下面是标志寄存器的值。而此时，bp中为栈顶的偏移地址，所以((ss)*16+(bp)+2)处为se的偏移地址，将它加上bx中的转移位移就变为s的偏移地址，最后用iret出栈返回，CS:IP即从标号s处开始执行指令。如果(cx)=0，则不需要修改栈中se的偏移地址，直接返回即可。CPU从标号se处向下执行指令。</p><h1 id="BIOS和DOS所提供的中断例程"><a href="#BIOS和DOS所提供的中断例程" class="headerlink" title="BIOS和DOS所提供的中断例程"></a>BIOS和DOS所提供的中断例程</h1><p>在系统板的ROM中存放着一套程序，称为BIOS（基本输入输出系统），BIOS中主要包含一下几部分内容。</p><ol><li>硬件系统的检测和初始化程序</li><li>外部中断和内部中断的中断例程</li><li>用于对硬件设备进行I/O操作的中断例程</li><li>其他和硬件系统相关的中断例程</li></ol><p>操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程时候经常需要用到的功能。程序员在编程的时候，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作。和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。</p><h1 id="BIOS和DOS中断例程的安装过程"><a href="#BIOS和DOS中断例程的安装过程" class="headerlink" title="BIOS和DOS中断例程的安装过程"></a>BIOS和DOS中断例程的安装过程</h1><p>我们通过之前的学习知道中断例程都需要先安装到内存中才可以使用，但是BIOS和DOS中断例程是怎么安装到内存中的呢？我们来简单的讲述一下这个过程：</p><ol><li>开机后，CPU一加电，初始化(CS)=0FFFFH，(IP)=0，自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。</li><li>初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。注意，对于BIOS所提供的中断例程，只需要将入口地址登记在中断向量表中即可，因为它们是固化到ROM中的程序，一直在内存中存在。</li><li>硬件系统检测和初始化完成后，调用int 19H进行操作系统的引导。从此将计算机交由操作系统控制。</li><li>DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存并建立相应的中断向量。</li></ol><h1 id="BIOS中断例程应用"><a href="#BIOS中断例程应用" class="headerlink" title="BIOS中断例程应用"></a>BIOS中断例程应用</h1><p>下面我们举一个例子，来看一下BIOS中断例程的应用。</p><p>int 10H中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。一般来说，一个供程序员调用的中断例程中往往包含多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。BIOS和DOS提供的中断例程，都用ah来传递内部子程序的编号。</p><p>下面看一下int 10H中断例程的设置光标位置功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ah,2;置光标</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov dh,5;dh中放行号</span><br><span class="line">mov dl,12;dl中放列号</span><br><span class="line">int 10H</span><br></pre></td></tr></table></figure><p>(ah)=2表示调用第10H号中断例程的2号子程序，功能为设置光标位置，可以提供光标所在行号（80×25 字符模式下：0-24）、列号（80×25字符模式下：0-79），和页号作为参数。</p><p>(bh)=0，(dh)=5，(dl)=12，设置光标到第0页，第五行，第十二列。</p><p>bh中页号的含义：内存地址空间中，B8000H-BFFFFH共32KB的空间，为80*25彩色字符模式的显示缓冲区。一屏的内容在显示缓存区中共占4000个字节。显示缓冲区分为8页，每页4KB，显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。也就是说，通常情况下，B8000H-B8F9FH中的4000个字节的内容将出现在显示器上。</p><p>再看一下int 10H中断例程的在光标位置显示字符功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ah,9;在光标位置显示字符</span><br><span class="line">mov al,&#x27;a&#x27;;字符</span><br><span class="line">mov dl,7;颜色属性</span><br><span class="line">mov dh,0;第0页</span><br><span class="line">mov cx，3;字符重复个数</span><br><span class="line">int 10H</span><br></pre></td></tr></table></figure><p>(ah)=9表示调用第10h号中断例程的9号子程序，功能为在光标位置显示字符，可以提供要显示的字符、颜色属性、页号、字符重复个数作为参数。</p><p>bl中的颜色属性的格式如下：</p><p><img src="2.jpg" alt="颜色属性的格式"></p><p>可以看出，和显存中的属性字节和格式相同。注意，闪烁的效果必须在全屏DOS方式下才能看到。</p><h1 id="DOS中断例程应用"><a href="#DOS中断例程应用" class="headerlink" title="DOS中断例程应用"></a>DOS中断例程应用</h1><p>int 21H中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。我们前面一直使用的是int 21H中断例程的4cH号功能，即程序返回功能，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4cH;程序返回</span><br><span class="line">mov al,0;返回值</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure><p>(ah)=4cH表示第21H号中断例程的4cH号子程序，功能为程序返回，可以提供返回值作为参数。我们前面使用这个功能的时候经常写做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure><p>我们看一下int 21H中断例程在光标位置显示字符串的功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ds:dx 指向字符串;要显示的字符串需用&quot;$&quot;作为结束符,但&quot;$&quot;本身不显示,只起到边界的作用</span><br><span class="line">mov ah,9;功能号9,表示在光标位置显示字符串</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure><p>(ah)=4cH表示第21H号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。</p><p>接下来给大家看一个应用中断例程的例子，在屏幕的5行12列显示字符串“Welcome to masm!”具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &#x27;Welcome to masm&#x27;,&#x27;$&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ah,2</span><br><span class="line">mov bh,0</span><br><span class="line">mov dh,5</span><br><span class="line">mov dl,12</span><br><span class="line">int 10H</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov dx,0</span><br><span class="line">mov ah,9</span><br><span class="line">int 21H</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>上述程序在屏幕的5行12列显示字符串“Welcome to masm!”，直到遇到’$’(不显示’$’，’$’只起到边界作用)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十二）</title>
    <link href="http://example.com/2022/09/18/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2022/09/18/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/</id>
    <published>2022-09-18T07:51:23.000Z</published>
    <updated>2022-09-21T05:37:05.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h1><p>任何一个通用的CPU都具有一个能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊的信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息我们可以称它为：中断信息。中断的意思是指，CPU不再接着向下执行，而是转头去处理这个特殊信息。</p><h1 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h1><p>什么情况下会产生中断信息呢？我们给出以下四种情况：</p><ol><li>除法错误，比如执行div指令产生的除法溢出</li><li>单步执行</li><li>执行into指令</li><li>执行int指令</li></ol><p>CPU在接收到这些信息的时候需要去处理它们，不同的信息有不同的处理方式，所以CPU要先知道中断信息的来源，所以中断信息中必须包含识别来源的编码。8086CPU用称为中断类型码的数据来标识中断信息的来源。中断类型码是一个字节型数据，可以表示256种中断信息的来源。之后我们的学习里，我们将中断信息的来源，简称为中断源。那么上述4种中断源，在8086CPU中的中断类型码如下：</p><ol><li>除法错误：0</li><li>单步执行：1</li><li>执行into指令：4</li><li>执行int指令：int指令的格式是int idata，其中idata是一个字节型立即数，它是int指令提供给CPU的中断类型码。</li></ol><h1 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h1><p>CPU收到中断信息后，需要对中断信息进行处理。至于如何处理中断信息，可以由我们编程决定，我们所编写出来处理中断信息的程序称为中断处理程序。一般来讲，需要对不同的中断信息编写不同的处理程序。</p><p>CPU在收到中断信息后，应该转去执行该中断信息的处理程序，那就要想办法修改CS:IP指向中断处理程序的第一条指令，所以首要问题是，CPU在接收到中断信息后，如何根据中断信息确定其处理程序的入口。如何根据8位的中断类型码得到中断处理程序的段地址和偏移地址呢？</p><h1 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h1><p>CPU用8位中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表又是啥子东西？中断向量表就是中断向量的列表。那中断向量又是啥子东西？？所谓中断向量，就是中断处理程序的入口地址，所以中断向量表就是中断处理程序的入口地址列表。</p><p>中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口。</p><p><img src="1.jpg" alt="中断向量表"></p><p>可以看到，当CPU知道了中断类型码，就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到中断处理程序的入口地址。可是。。CPU怎么找到中断向量表呢？中断向量表被存放在内存中，8086CPU规定内存0000:0000~0000:03FF的1024个单元内必须存放着中断向量表，只要是8086CPU那么内存的这个区域就一定是中断向量表。中断向量表中的每一个表项大小占两个字，高地址字存放段地址，低地址字存放偏移地址。</p><h1 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h1><p>现在我们知道了可以使用中断类型码，在中断向量表里面找到中断处理程序的入口，并用其修改CS:IP，使CPU执行中断处理程序。用中断类型码在中断向量表里面找到中断处理程序，设置CS:IP的过程是CPU硬件自动完成的。CPU硬件完成这一系列工作的过程被称为中断过程。</p><p>CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令，所以在中断过程中，在设置CS:IP之前还应该将原来的CS和IP中的值保存起来。所以整个中断过程应该是这样的：</p><ol><li>从中断信息中取得中断信息码</li><li>标志寄存器的值入栈</li><li>设置标志寄存器的第8位TF和第9位IF的值为0（下一篇详细介绍）</li><li>CS的内容入栈</li><li>IP的内容入栈</li><li>从内存地址为中断类型码×4和中断类型码×4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS</li></ol><h1 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a>中断处理程序和iret指令</h1><p>由于CPU随时都有可能检测到中断程序，所以中断处理程序必须一直储存在内存的某段空间之中。编写中断处理程序的步骤有以下四点：</p><ol><li>保存用到的寄存器</li><li>处理中断</li><li>恢复用到的寄存器</li><li>用iret指令返回</li></ol><p>iret指令的功能用汇编语法描述为pop IP，pop CS，popf。iret通常和硬件自动完成的中断过程配合使用，它实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作。iret指令执行后CPU回到执行中断处理程序前的执行点继续执行程序。</p><h1 id="除法错误中断的处理"><a href="#除法错误中断的处理" class="headerlink" title="除法错误中断的处理"></a>除法错误中断的处理</h1><p>我们接下来通过0号中断，即除法错误中断的处理，来体会一下前面的内容。</p><p>当CPU执行div等除法指令时，如果发生了除法溢出的错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序。就像这样：</p><p><img src="2.jpg" alt="除法错误中断的处理"></p><p>可能因为DOSBox是一个模拟器，这种虚拟模式下的DOS系统的中断处理程序与其它方式进入的DOS系统的中断处理程序并不相同。所以没有显示我们想要的错误提示。</p><h1 id="编程处理0号中断"><a href="#编程处理0号中断" class="headerlink" title="编程处理0号中断"></a>编程处理0号中断</h1><p>现在我们改写一下0号中断处理程序的功能，让它可以在屏幕中间显示”OVERFLOW!”,然后返回操作系统。</p><p>我们叫这个程序为do0好了，首先我们要考虑的问题是因为0号中断随时都可能发生，所以我们编写的中断处理程序需要放在内存当中，可是具体应该是哪里呢？前面讲到，内存0000:0000~0000:03FF，大小为1KB的空间是系统存放中断处理程序的入口地址的中断向量表。8086支持256个中断，但实际上系统要处理的中断事件远没有256个，所以在中断向量表里很多单元都是空的。这些空间只用来存放中断处理程序的入口地址，DOS系统和其他程序不会随便使用这块空间，所以可以用这块空间来存放我们的中断处理程序。当然这也限制我们的中断处理程序不能超过256字节。我们打算将do0传送到0000:0200，将do0传送到0000:0200还不算完，我们还要将0000:0200登记在中断向量表的对应表项中，因为是0号中断，所以中断程序的段地址应该在0000:0002字单元中，偏移地址应该在0000:0000字单元中。</p><p>综上所述我们要做这样几件事：</p><ol><li>编写可以显示”OVERFLOW!”的中断处理程序do0</li><li>将do0送入内存0000:0200处</li><li>将do0的入口地址0000:0200储存在中断向量表0号表项中</li></ol><p>所以程序的框架应该是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:do0安装程序</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:显示字符串&quot;OVERFLOW!&quot;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这个程序执行过后将我们写好的中断处理程序复制到了内存的0000:0200处，将do0的入口地址储存在中断向量表中了。接下来我们一点点将程序补完吧！</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>我们可以使用之前说的串传送指令movsb，do0的代码送入0000:0200，程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:设置es:di指向目的地址</span><br><span class="line">设置ds:si指向原地址</span><br><span class="line">设置cx为传输长度</span><br><span class="line">设置传输方向为正</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:显示字符串&quot;OVERFLOW!&quot;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>我们看一下程序中我们应该可以对应上的数据：</p><ol><li>传送的原始位置，段地址：code，偏移地址：offset do0</li><li>传送的目的位置：0000:0200</li><li>传送的长度：do0部分代码长度</li><li>传送的方向：正向</li></ol><p>那么我们就可以将程序补充成这样子滴：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,do0部分代码的长度</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:显示字符串&quot;OVERFLOW!&quot;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>现在我们面临了一个问题，我们怎么知道do0部分的代码长度呢？最简单的方法是，计算一下do0中所有指令码的字节长度，但这样做太麻烦了，而且写成确定的数字也不利于我们以后的更改。所以我们可以让编译器为我们代劳计算do0的长度。这样代码又变成了这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,offset do0end-offset do0</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:显示字符串&quot;OVERFLOW!&quot;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0end：nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>“-“是编译器识别的运算符号，编译器可以用它进行两个常数的减法。就好比mov ax,8-4会被编译器翻译成mov ax,4一样。</p><p>接下来我们来补全do0代码。</p><h1 id="do0"><a href="#do0" class="headerlink" title="do0"></a>do0</h1><p>我们已经分析好do0的工作了所以这里直接给出代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,offset do0end-offset do0</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:jmp short do0start</span><br><span class="line">db &quot;OVERFLOW!&quot;</span><br><span class="line">do0start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,202H;设置ds:si指向字符串</span><br><span class="line">mov ax,0B800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,12*160+36*2;设置es:di指向显存空间的中间位置</span><br><span class="line">mov cx,9;设置cx为字符串长度</span><br><span class="line">s:mov al,[si]</span><br><span class="line">mov es:[di],al</span><br><span class="line">inc si</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里我们来剖析一下代码：</p><p>首先，“OVERFLOW！”没有被存储在一个数据段里，而是和do0一同储存在了代码段里，这是因为如果将字符串存在数据段里，待程序执行完毕，数据段内容会被释放，这样do0程序以后就找不到字符串了，所以我们将字符串一并的存放在代码段中。</p><p>其次，因为do0程序开始处的“OVERFLOW!”不是可以执行的代码，所以在它之前要加上一个jmp指令，跳转到正式的do0程序。</p><p>最后，do0程序执行过程中必须要能找到“OVERFLOW!”，那么它在哪里呢？首先来看段地址，肯定是code段了和do0在一个段地址，再看偏移地址，0000:0200处指令为jmp short do0start，这条指令占两个字节所以，“OVERFLOW!”的偏移地址为202H。</p><h1 id="设置中断向量"><a href="#设置中断向量" class="headerlink" title="设置中断向量"></a>设置中断向量</h1><p>下面要将do0的入口地址0000:0200写入0号表项中。0号表项地址为0000:0000，其中0000:0000字单元放偏移地址，0000:0002放段地址，所以程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200H</span><br><span class="line">mov word ptr es:[0*4+2],0</span><br></pre></td></tr></table></figure><h1 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h1><p>基本上，CPU在执行完一条指令后，如果检测到标志寄存器TF位为1，则产生单步中断，引发中断过程。单步中断的类型码为1，它引发的中断过程如下：</p><ol><li>取得中断类型码1</li><li>标志寄存器入栈，TF、IF设置为0</li><li>CS、IP入栈</li><li>(IP)=(1×4)，(CS)=(1×4+2)</li></ol><p>如上所述，每执行完一条指令，CPU就要转去执行一次1号中断处理程序，CPU为什么要这样做呢？</p><p>我们在使用debug的T命令时，有没有想过这样的问题，debug凭什么可以让程序执行完一条指令后显示各个寄存器的值？我们知道程序的运行就是CS:IP指向程序入口，然后CPU自动向下读取，如果没有外加其他功能，CPU应该是一加上电，它就从预设的地址开始执行下去，不会出现执行一条停一下的情况，可是在debug中，CPU却是这么做的。其实debug是用到了CPU的一个功能实现的，这个功能支持着T命令的工作。</p><p>下面我们就简要的考虑一下debug到底是如何利用CPU所提供的单步中断的功能的。首先，debug提供了单步中断的中断处理程序，功能为显示所有寄存器内容并且等待后续输入命令。然后，在使用t命令执行指令时，debug将TF设置为1，使得CPU工作于单步中断方式下，然后CPU执行完当前指令后，检测到TF为1，引发单步中断，执行单步中断处理程序。</p><p>但是单步中断处理程序也是一条条指令呀，那执行一条指令就单步中断一次，执行一次单步中断处理程序，这不是没完没了了嘛，CPU当然不会允许这种事情发生啦，CPU会在进入中断处理程序之前，设置TF为0，从而避免这种情况的出现，这就是为什么在中断过程中有TF=0这个步骤。我们再来看一遍中断过程：</p><ol><li>取得中断类型码N</li><li>标志寄存器入栈，TF、IF设置为0</li><li>CS、IP入栈</li><li>(IP)=(N×4)，(CS)=(N×4+2)</li></ol><p>最后，CPU提供单步中断功能的原因，就是为了实现单步跟踪程序的执行过程。</p><h1 id="响应中断的特殊情况"><a href="#响应中断的特殊情况" class="headerlink" title="响应中断的特殊情况"></a>响应中断的特殊情况</h1><p>一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就会响应中断，引发中断过程。但是在某些情况下CPU执行完当前的指令后，即便是发生了中断，也不会响应。比如：</p><p>在执行完向SS寄存器传送数据的指令后，即便发生了中断，CPU也不会响应。这样做的原因是，SS:SP联合指向栈顶，而对它们的设置应该连续完成。如果在执行完设置SS的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器的值、CS和IP的值。而SS改变，SP没改变，那SS:SP指向的位置就是错误的。所以CPU在执行设置完SS的指令后，不响应中断。这给连续设置SS和SP提供了一个时机，我们应该利用这个时机，将设置SS和SP的指令连续存放，也就是应该这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov ax，0</span><br><span class="line">mov sp,0</span><br></pre></td></tr></table></figure><p>相信有些细心的小伙伴在学习过程中会发现，用T命令跟踪程序时，往往设置SP的指令会被跳过，但是SP还是被正确设置了，先在我想你心里已经有了答案！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十一）</title>
    <link href="http://example.com/2022/09/12/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/09/12/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</id>
    <published>2022-09-12T06:09:31.000Z</published>
    <updated>2022-09-18T07:36:56.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h1><p>CPU内部的寄存器中，有一种特殊的寄存器，它具有一下三种作用：</p><ul><li>用来存储相关指令的某些执行成果</li><li>用来为CPU执行相关指令提供行为依据</li><li>用来控制CPU的相关工作方式</li></ul><p>它叫做标志寄存器flag，其中储存的信息通常被叫做程序状态字(PSW)，flag寄存器和其他寄存器不一样，其他寄存器都是整个寄存器具有一个含义，而flag是按位起作用的，每一位都有特定的含义。</p><p><img src="1.jpg" alt="flag寄存器的结构"></p><p>flag寄存器的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义，其余位都具有特殊含义。</p><h1 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h1><p>我们知道flag寄存器的结构后，就分别来介绍一下用到的标志位，首先是ZF标志位。</p><p>flag寄存器中第6位：ZF，零标志位。它记录着相关指令执行后，其结果是否为0，如果为0，则ZF为1，反之ZF为0。这很好理解，只要执行的指令得到的结果是0，那么ZF就是1，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">and ax,0</span><br></pre></td></tr></table></figure><p>这两条指令执行完后ZF就是1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">or ax,0</span><br></pre></td></tr></table></figure><p>这两条指令执行完后ZF就是0。</p><p>注意，在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如add，sub，mul，div，inc，or，and等它们多为运算指令；有的指令对标志寄存器是没有影响的，比如mov，pop，push等它们大多数为传送指令。</p><h1 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h1><p>我们介绍的第二个朋友就是PF标志位。</p><p>flag寄存器中第2位：PF，奇偶标志位，它记录相关指令执行后，其结果的所有bit位中1的个数是奇数个还是偶数个，如果为偶数，那么PF就为1，反之为0，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,1</span><br><span class="line">add AL,10</span><br></pre></td></tr></table></figure><p>这两条指令执行完后，结果为00001011B，其中有三个1，所以ZF就是0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,1</span><br><span class="line">or AL,2</span><br></pre></td></tr></table></figure><p>这两条指令执行完后，结果为00000011B，其中有两个1，所以ZF就是1。</p><p>(Tips：0也是偶数哦)</p><h1 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h1><p>接下来是第三位朋友SF标志位。</p><p>flag寄存器中第7位SF，符号标志位。它记录相关指令执行后，其结果是否为负数，如果为负数，那么SF为1，反之为0，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,10000001B</span><br><span class="line">add AL,1</span><br></pre></td></tr></table></figure><p>这两条指令执行完后，结果为10000010B，如果进行的是有符号数计算，那么SF为1，代表结果为负。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,10000001B</span><br><span class="line">add AL,01111111B</span><br></pre></td></tr></table></figure><p>这两条指令执行完后，结果为0，如果进行的是有符号数计算，那么SF为0，代表结果为正。</p><p>计算机中通常用补码来表示有符号数据，一个数据可以被看成有符号数字也可以被看成无符号数字，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,10000001B</span><br><span class="line">add AL,1</span><br></pre></td></tr></table></figure><p>结果为(AL)=10000010B。我们可以认为add指令进行了一次无符号数运算，那么add指令就相当于计算了129+1，结果为130(10000010B)；当然我们也可以认为add指令进行了一次有符号数运算，那么add指令就相当于计算-127+1，结果为-126(10000010B)。</p><p>SF标志，就是CPU对有符号数运算结果的一种记录，记录了数据的正负，我们进行有符号数计算时，可以将SF标志作为判断数据正负的依据，当我们进行无符号数计算的时候，SF标志没有什么使用价值，因此我们要根据进行的计算，去观察SF标志。</p><h1 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h1><p>接下来介绍大哥，CF标志位。</p><p>flag寄存器第0位CF，进位标志位。一般情况下，进行无符号数计算的时候，注意是无符号数，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p><p>对于位数为N的无符号数来说，其对应的二进制信息的最高位，为N-1位，也就是它的最高有效位，而我们假象出来的第N位，就是相对于最高有效位的更高位。</p><p><img src="2.jpg" alt="最高有效位和假想最高位"></p><p>我们知道，当两个数据相加时，就有可能产生从最高有效位向更高位的进位。比如98H+98H，将产生进位。由于这个进位值在8位数中无法保存，我们之前只是简单的说这个进位丢失了，但其实CPU在运算时，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。8086CPU就使用flag的CF位来记录这个进位值，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov AL,98H</span><br><span class="line">add AL,AL</span><br><span class="line">add AL,AL</span><br></pre></td></tr></table></figure><p>第一条add指令执行后，(AL)=30H，CF=1，CF记录了从最高有效位向更高位的进位值，第二条add指令执行后，(AL)=60H，CF=0。</p><p>同样当进行减法运算时，也可能向更高位借位。比如，两个97H-98H，将产生借位，借位后就相当于计算197H-98H。CF标志为也可以记录这个值，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov AL,97H</span><br><span class="line">sub AL,98H</span><br><span class="line">sub AL,AL</span><br></pre></td></tr></table></figure><p>第一条sub指令执行后，(AL)=FFH，CF=1，CF记录了向更高位的借位值，第二条sub指令执行后，(AL)=0H，CF=0。</p><p>哦对了，inc指令不会影响CF的值，要记住。</p><h1 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h1><p>flag寄存器第11位OF，溢出标志位。在仔细了解它之前我们先来了解一下溢出的问题。</p><p>在进行有符号计算的时候，如果结果超过了机器所能表示的范围称为溢出。那么什么是机器能表示的范围呢？比如说，指令运算的结果用8位寄存器或内存单元来存放，比如，add AL,3，那么对于8位的有符号数据，机器所能表示的范围是-128到127。同理，对于16位有符号数据，机器能表示的范围为-32768到32767。如果运算结果超过了机器所能表达的范围，将产生溢出。注意我们现在所讲的溢出，是针对有符号数而言，下面我们看个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,98</span><br><span class="line">add AL,99</span><br></pre></td></tr></table></figure><p>执行后将产生溢出。因为add AL,99进行的有符号数运算是：98+99=197，而结果197超出了机器能表示的8位有符号数的范围，这就发生了溢出，如果在进行有符号数运算时发生溢出，那么运算结果就不正确，就例子而言，add指令运算完的结果是(AL)=0C5H，因为进行的是有符号数计算，所以AL中存储的是有符号数，C5H是-59的补码，如果我们用add指令进行的是有符号数运算，那我们就得到了98+99=-59，这太夸张了！造成这样的原因是实际结果197无法在8位寄存器中存放，由于这样的事情存在，所以CPU要对指令执行以后是否产生了溢出进行记录。</p><p>现在我们回过头来看一下OF标志，如果指令执行以后发生了溢出OF=1反之OF=0，我们要注意，CF是对无符号数有意义的标志位，而OF是对有符号数有意义的标志位，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,0F0H</span><br><span class="line">add AL,88H</span><br></pre></td></tr></table></figure><p>两条指令执行后：CF=1，OF=1。对于无符号数运算来讲，0F0H+88H有进位，所以CF=1；对于有符号数运算来讲，0F0H+88H发生溢出，所以OF=1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,0F0H</span><br><span class="line">add AL,78H</span><br></pre></td></tr></table></figure><p>两条指令执行后：CF=1，OF=0。对于无符号数运算来讲，0F0H+78H有进位，所以CF=1；对于有符号数运算来讲，0F0H+78H没发生溢出，所以OF=0。</p><p>我们可以看出，CF和OF所表示的进位和溢出，分别是对无符号数计算和有符号数计算而言的，它们之间没有任何关系。</p><h1 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h1><p>adc指令是带进位的加法指令，它利用了CF位上记录的进位值，我们来看一下它的格式：</p><p>adc 操作对象1，操作对象2</p><p>它的功能是：操作对象1=操作对象1+操作对象2+CF，比如说adc  ax,bx，实现的功能是(ax)=(ax)+(bx)+CF，我们看一下例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adc ax,1</span><br></pre></td></tr></table></figure><p>因为sub bx,ax发生了借位，这时CF=1，之后adc指令就计算了：(ax)+1+CF=2+1+1=4，所以(ax)=4。</p><p>为什么要加上CF的值呢？CPU为什么提供了这样的指令呢？我们先来回看一下CF的值的含义，adc指令使用到的CF的值的含义是由adc指令前面的指令决定的，也就是说，关键在于所加上的CF值是被什么设置的，如果CF是被sub设置的那么就是借位值，如果是add设置的那就是进位值，所以CF存在的意义就是用来进行高位数数据计算，比如add ax,bx也可以被看做add AL,BL，adc ah,bh它们是完全等价的。我们看一个例子：</p><p>计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中，很显然add指令做不到计算这样大的数据，所以我们打算先计算低16位相加，然后计算高16位相加再加上CF的值。也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001EH</span><br><span class="line">mov bx,0F000H</span><br><span class="line">add bx,1000H</span><br><span class="line">adc ax,0020H</span><br></pre></td></tr></table></figure><p>我们可以根据这个思路计算更大的数据相加。</p><h1 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h1><p>sbb指令是带借位的减法指令，它利用了CF位上记录的借位值，我们来看一下它的格式：</p><p>sbb 操作对象1，操作对象2</p><p>它的功能是：操作对象1=操作对象1-操作对象2-CF，比如说sbb  ax,bx，实现的功能是(ax)=(ax)-(bx)-CF。同样的我们也可以根据我们之前的思路，进行高位数数据的运算。这里我们不再赘述。</p><h1 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h1><p>cmp指令是比较指令，cmp的功能相当于减法指令，只是不保存结果，cmp指令执行后将对标志寄存器产生影响，其他的指令通过识别这些被影响的标志寄存器位来得知比较结果。老样子我们看一下cmp指令的格式：</p><p>cmp 操作对象1，操作对象2</p><p>cmp指令的功能是这样的，计算操作对象1-操作对象2但并不保存结果，仅仅根据计算的结果对标志寄存器进行设置，比如cmp ax,ax它首先计算了(ax)-(ax)结果为0，但并不在ax中保存，仅根据0来设置flag中的相关位，这条指令执行后，ZF=1,PF=1,SF=0,CF=0,OF=0。</p><p>所以我们可以看出来cmp指令给了我们很多信息：</p><p><img src="3.jpg" alt="cmp指令提供的信息1"></p><p>和add，sub指令一样，CPU执行cmp指令的时候也包含两种含义：对无符号数进行比较，对有符号数进行比较，上面我们讲的是对无符号数进行的比较，下面我们看一下对有符号数的比较：</p><p>我们以cmp ah,bh为例，如果(ah)=(bh)，则(ah)-(bh)=0，所以：ZF=1，反之ZF=0，所以我们根据ZF的值可以知道两个数据是否相等。接下来我们再来看(ah)&lt;(bh)会发生什么，在这个情况下，(ah)-(bh)显然可能引起SF=1，即结果为负，但是我们不能因为SF=1就说明(ah)&lt;(bh)，例如：(ah)-(bh)=34-(-96)=82H(-126)，我们不能因为计算后SF=1就说34&lt;-96这显然是不合理的。当运算发生溢出以后我们逻辑上的得到的结果(130)和实际的结果(-126)是不一样的，所以单单根据SF去判断比较较结果是不可靠的，还要结合OF一起判断，下面我们就来看看SF和OF到底给我们提供了什么样的信息：</p><p><img src="4.jpg" alt="cmp指令提供的信息2"></p><h1 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h1><p>我们在之前的学习过程中，学到过一个条件转移指令jcxz指令，它通过检测(CX)是否为0，来判断是否进行条件转移，当然除了jcxz之外，CPU还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的标志位，这些指令通常和cmp组合使用就像是call和ret的关系。</p><p>因为cmp有两种比较，无符号数比较和有符号数比较，所以和cmp组合的转移动指令也有两种，根据无符号数的比较结果进行转移的条件转移指令(它们检测ZF和CF的值)，根据有符号数的比较结果进行转移的的条件转移指令(它们检测SF、OF、ZF的值)。</p><p>下面是常用的根据无符号数的比较结果进行转移的条件转移指令：</p><p><img src="5.jpg" alt="常用的根据无符号数的比较结果进行转移的条件转移指令"></p><p>这些指令很常用，而且很好记忆，它们的第一个字母j表示jump，之后的e代表equal，ne就是not equal，b是below，a是above。</p><p>当然了，这些指令的含义都是和cmp结合的时候才拥有的，它们做的事情只是检测相关标志位，符合条件就跳转，比如有这样一段程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">add ax,0</span><br><span class="line">je s</span><br><span class="line">inc ax</span><br><span class="line">s:inc ax</span><br></pre></td></tr></table></figure><p>执行过后，(ax)=1，因为add ax,0执行过后设置了ZF=1，je指令检测到ZF=1后跳转到S处，这里就不能说谁等于谁，也就是说je指令没有什么含义，因此我们一般将cmp和这些跳转指令一起使用，它们组合起来就像是高级语言中的IF一样起到一个条件判断的作用。有符号数比较跳转指令的原理就和无符号数比较跳转指令相同了，有兴趣可以查阅相关的指令手册。</p><h1 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h1><p>接下来介绍的是flag寄存器的第10位DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。DF=0每次操作后si、di递增；DF=1每次操作后si、di递减。知道了DF的作用后，我们还得知道串传送指令，我们来看一下movsb指令，首先是movsb的格式就是movsb，当执行movsb指令时就相当于做了这样几件事：</p><ol><li>((es)×16+(di))=((ds)×16+(si))</li><li>如果DF=0则(si)=(si)+1,(di)=(di)+1</li><li>如果DF=1则(si)=(si)-1,(di)=(di)-1</li></ol><p>它实现了将DS:SI指向的内存字节单元的内容送入ES:DI中，然后根据DF的值将SI和DI递增1或者递减1。还有另一个指令，movsw指令，它实现了DS:SI指向的内存字单元的内容送入ES:DI中，然后根据DF的值将SI和DI递增2或者递减2。</p><p>movsb和movsw都是串传送操作的一个步骤，一般来说这两个指令都会和rep指令配合使用，rep指令的格式是rep movsb，它做的事情就像是一个循环即s:movsb；loop s。可见rep的作用是根据CX的值，重复执行后面的串传送指令，因为每执行一次movsb指令si和di都会递增或递减一个单位，所以rep movsb可以循环实现(CX)个字符的传送。同理也有rep movsw。</p><p>因为DF标志位决定了串传送指令执行后，si和di改变的方向，所以CPU给程序员提供了相应修改DF位的指令，让程序员可以修改串传送的方向，这两个指令分别是cld指令(将DF置为0)，std指令(将DF置为1)。</p><h1 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h1><p>pushf的格式很简单就是pushf，它做的事情是将标志寄存器的值压栈，popf的格式也是popf，它做的事情是从栈中弹出数据，送入标志寄存器。这两个指令为直接访问标志寄存器提供了一种方法。</p><h1 id="标志寄存器在Debug中的表示"><a href="#标志寄存器在Debug中的表示" class="headerlink" title="标志寄存器在Debug中的表示"></a>标志寄存器在Debug中的表示</h1><p>最后的最后，我们要了解一下标志寄存器在Debug中怎么表示的，这样方便我们在程序调试的时候，观察这些标志位的变化。</p><p><img src="6.jpg" alt="标志寄存器在debug中显示位置"></p><p>当我们开始debug之后执行r指令，我们可以看到在IP寄存器之后有一串字符，这串字符就表示了几个标志位的值，但是这一些值我也分不清那个是那个标志位呀！没关系，我们给出了标志位中值的表示：</p><p><img src="7.jpg" alt="debug对我们已知的标志位的表示"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十）</title>
    <link href="http://example.com/2022/09/06/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <id>http://example.com/2022/09/06/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%EF%BC%89/</id>
    <published>2022-09-06T15:33:49.000Z</published>
    <updated>2022-09-09T08:13:44.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h1><p>我们书接上回，上一篇我们学习了一些转移指令的原理，接下来我们继续学习一些新的转移指令：</p><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移，当CPU执行ret指令时，进行下面两步操作：(IP)=((SS)×16+(SP))；(SP)=(SP)+2。用汇编语法来解释ref指令相当于进行了pop IP。</p><p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移，当CPU执行retf指令时，进行下面四步操作：(IP)=((SS)×16+(SP))；(SP)=(SP)+2；(CS)=((SS)×16+(SP))；(SP)=(SP)+2。用汇编语法来解释ref指令相当于进行了pop IP，pop CS。</p><h1 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h1><p>call指令也是一种转移指令，当CPU执行call指令的时候，进行两步操作：将下一条指令的IP或CS和IP压入栈中；转移。call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。接下来我们仔细介绍一下。</p><h2 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h2><p>首先，看一下call指令的格式：call 标号，将下一条指令IP压入栈中后，转到标号处执行指令。也就是这么一个过程：(SP)=(SP)-2；((SS)×16+(SP))=(IP)；(IP)=(IP)+16位位移。其中16位位移的计算方法是：位移=标号处偏移地址-call指令下一条指令的偏移地址，结果用补码表示，在编译程序编译时算出。当然了16位位移是有取值范围的，取值范围是-32768~32767，用补码表示。用汇编语法来解释call指令相当于进行了push IP；jmp near ptr 标号。</p><h2 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h2><p>首先，还是看一下call指令的格式：call far ptr 标号，将下一条指令CS和IP压入栈中后，转到标号处执行指令。也就是这么一个过程：(SP)=(SP)-2；((SS)×16+(SP))=(CS)；(SP)=(SP)-2；((SS)×16+(SP))=(IP)；(IP)=(IP)+16位位移；(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址。这样的call指令实现了段间转移，用汇编语法来解释call指令相当于进行了push CS；push IP；jmp far ptr 标号。</p><h2 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h2><p>这个call指令的格式是：call 16位reg。它的过程是：(SP)=(SP)-2；((SS)×16+(SP))=(IP)；(IP)=(16位reg)，用汇编语法来解释call指令相当于进行了push IP；jmp 16位reg。</p><h2 id="转移地址在内存中的call指令"><a href="#转移地址在内存中的call指令" class="headerlink" title="转移地址在内存中的call指令"></a>转移地址在内存中的call指令</h2><p>call指令中的转移地址也可以在内存之中，它也分为两种格式：</p><h3 id="call-word-ptr-内存单元地址"><a href="#call-word-ptr-内存单元地址" class="headerlink" title="call word ptr 内存单元地址"></a>call word ptr 内存单元地址</h3><p>用汇编语言解释这句指令的话，那么当CPU执行这句指令的时候，相当于进行了：push IP；jmp word ptr 内存单元地址。</p><h3 id="call-dword-ptr-内存单元地址"><a href="#call-dword-ptr-内存单元地址" class="headerlink" title="call dword ptr 内存单元地址"></a>call dword ptr 内存单元地址</h3><p>用汇编语言解释这句指令的话，那么当CPU执行这句指令的时候，相当于进行了：push CS；push IP；jmp dword ptr 内存单元地址。</p><h1 id="call和ret的配合使用"><a href="#call和ret的配合使用" class="headerlink" title="call和ret的配合使用"></a>call和ret的配合使用</h1><p>我们学会了ret指令也学会了call指令，学这两个指令的目的是为了实现子程序的机制，什么是子程序呢？直观的来说就是我们在高级语言中写的函数，怎么样是不是一下子就感受到这两个指令的强大了，事不宜迟，我们马上开始。  我们先来看一个程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code内存中的情况（假设程序从内存1000:0处装入）</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 8 dup (0)1000:0000 00 00 00 00 00 00 00 00</span><br><span class="line">db 8 dup (0)1000:0008 00 00 00 00 00 00 00 00</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack1001:0000 B8 00 10</span><br><span class="line">mov ss,ax1001:0003 8E D0</span><br><span class="line">mov sp,161001:0005 BC 10 00</span><br><span class="line">mov ax,10001001:0008 B8 E8 03</span><br><span class="line">call s1001:000B E8 05 00</span><br><span class="line">mov ax,4c00H1001:000E B8 00 4C</span><br><span class="line">int 21H1001:0011 CD 21</span><br><span class="line">s:add ax,ax1001:0013 03 C0</span><br><span class="line">ret1001:0015 C3</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>程序中给出了内存中的情况，我们结合内存的情况一点点分析整个程序做的事情。从start开始前三行执行后，栈的情况如下：</p><p>1000:0000 00 00 00 00 00 00 00 00</p><p>此时SS:SP指向栈底，当call指令读入后，(IP)=000EH，CPU指令缓冲器中的代码为：E8 05 00（call s）</p><p>程序执行完call s后，栈的情况变为</p><p>1000:0000 00 00 00 00 00 00 0E 00</p><p>此时SS:SP指向0E也就是倒数第二个字节，然后(IP)=(IP)+0005=0013H。之后CPU从CS:0013H处(即标号s处)开始执行，ret指令读入后(IP)=0016H，CPU指令缓存器中的代码为：C3 （ret）</p><p>程序执行完C3后，栈的情况变为</p><p>1000:0000 00 00 00 00 00 00 0E 00</p><p>此时SS:SP指向栈底，之后CPU回到CS:000EH处（即call指令后面的指令处）继续执行。</p><p>怎么样，是不是有点像我们在高级程序中做的那个样子，写一个函数，当我们需要它的时候就调用它，不需要的时候我们就不调用它。我们给出一个子程序的源程序的框架：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">main:</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  call sub1         调用子程序sub1</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  mov ax,4C00H</span><br><span class="line">  int 21H</span><br><span class="line">sub1:</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  call sub2调用子程序sub2</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ret子程序返回</span><br><span class="line">sub2:</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ret子程序返回</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure><p>怎么样现在的汇编语言是不是更有我们高级程序语言的模样啦！</p><h1 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h1><p>我们这里介绍一下mul指令，mul是乘法指令，在使用mul做乘法时要注意两点：</p><ol><li>两个相乘的数：要不都是8位，要不都是16位。如果都是8位那么一个默认放在AL中，另一个默认放在8位reg或者内存字节单元中。如果都是16位那么一个默认放在AX中，另一个默认放在16位reg或者内存字单元中。</li><li>结果：如果8位乘法，结果默认在AX中；如果是16位乘法那么，结果高位默认在dx中，低位在ax中。</li></ol><p>格式如下：</p><ul><li>mul reg</li><li>mul 内存单元</li></ul><p>内存单元可以通过不同的寻址方式给出，比如：</p><p>mul byte ptr ds:[0] 含义是(AX)=(AL)×((DS)×16+0);mul word ptr [BX+SI+8]含义是(AX)=(AX)×((DS)×16+(BX)+(SI)+8)结果的低16位;(DX)=(AX)×((DS)×16+(BX)+(SI)+8)结果的高16位。</p><h1 id="参数与结果传递的问题"><a href="#参数与结果传递的问题" class="headerlink" title="参数与结果传递的问题"></a>参数与结果传递的问题</h1><p>在高级语言中，我们都知道一个函数由返回值类型，函数名称、参数列表组成，我们将参数交给函数，函数在进行了指定的操作后，将结果交付给我们。在我们的汇编语言中也会使用这种模块化的程序设计。</p><p>我们现在思考这样的问题，现在我们有一个数N，设计一个子程序计算N的三次幂。这样一来我们就有了两个问题，参数N应该存放在哪里？得到的结果要存放在哪？很显然，可以用寄存器来存储，可以将参数放到BX中；因为子程序中要计算N的3次幂，所以可以使用多个mul指令，为了方便，可将结果存放到dx和ax中，我们来看程序，这个程序计算了data段第一组数据的3次方，结果保存到后一组的dword单元中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">dw 1,2,3,4,5,6,7,8</span><br><span class="line">dd 0,0,0,0,0,0,0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,16</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov bx,[si]</span><br><span class="line">call cube</span><br><span class="line">mov [di],ax</span><br><span class="line">mov [di].2,dx</span><br><span class="line">add si,2</span><br><span class="line">add di,4</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">cube:mov ax,bx</span><br><span class="line">mul bx</span><br><span class="line">mul bx </span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="批量数据的传递"><a href="#批量数据的传递" class="headerlink" title="批量数据的传递"></a>批量数据的传递</h1><p>上面的程序中子程序cube只有一个参数，放在bx中。如果有两个参数，那么可以使用两个寄存器来放，可是如果需要传递3个，4个，N个怎么办？显然一味地使用寄存器是不可靠的。这种时候，我们将批量的数据放到内存之中，然后将它们所在的内存空间的首地址放在寄存器中，传递给需要的子程序，同样需要返回多个数据，我们也这样做。我们写一个将字符串转为大写的程序，体验一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &#x27;conversation&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,12</span><br><span class="line">call capital</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">capital:and byte ptr [si],11011111B</span><br><span class="line">inc si</span><br><span class="line">loop capital</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>除了使用寄存器传递参数，我们还有更通用的做法，使用栈来传递参数，我们接下来结合C语言的函数调用来看一下使用栈传递参数的思想，我们设定一个场景，我们要设计一个子程序计算(a-b)的3次幂，a和b是字型数据，我们来看用到的程序片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">push ax</span><br><span class="line">mov ax,3</span><br><span class="line">push ax</span><br><span class="line">call difcube</span><br><span class="line">difcube:push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">mov ax,[bp+4]</span><br><span class="line">sub ax,[bp+6]</span><br><span class="line">mov bp,ax</span><br><span class="line">mul bp</span><br><span class="line">mul bp</span><br><span class="line">pop bp</span><br><span class="line">ret 4</span><br></pre></td></tr></table></figure><p>其中ret idata的含义用汇编语法描述为：</p><p>pop IP；add sp,idata</p><p>我们来看看栈的变化，假设栈的初始情况如下：</p><p>1000:0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </p><p>此时SS:SP指向栈底。</p><p>当执行mov ax,1~push ax指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 00 00 00 00 03 00 01 00 </p><p>此时SS:SP指向03。</p><p>当执行call difcube指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 00 00 XP XI 03 00 01 00 </p><p>此时SS:SP指向XI(XIXPH即为call指令的下一条指令IP)。</p><p>执行push bp指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 XB XA XI XP 03 00 01 00 </p><p>此时SS:SP指向XB。</p><p>执行mov bp,sp后，SS:BP指向1000:8</p><p>之后执行mov ax,[bp+4]将栈中a的值送入ax中，sub ax,[bp+6]减去栈中b的值，mov bp,ax将ax中的值赋给bp，mul bp计算三次幂。</p><p>执行pop bp指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 XB XA XI XP 03 00 01 00 </p><p>此时SS:SP指向XI。</p><p>执行ret 4指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 XB XA XI XP 03 00 01 00 </p><p>此时SS:SP指向栈底。</p><p>我们接下来通过一个C语言程序编译后的汇编语言程序，看一下栈在参数传递中的应用，在高级语言中，局部变量也在栈中储存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    c=a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">    add(a,b,c);</span><br><span class="line">    c++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的汇编程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mov bp,sp</span><br><span class="line">sub sp,6</span><br><span class="line">mov word ptr [bp-6],0001</span><br><span class="line">mov word ptr [bp-4],0002</span><br><span class="line">mov word ptr [bp-2],0000</span><br><span class="line">push [bp-2]</span><br><span class="line">push [bp-4]</span><br><span class="line">push [bp-6]</span><br><span class="line">call ADDR</span><br><span class="line">add sp,6</span><br><span class="line">inc word ptr [bp-2]</span><br><span class="line">ADDR:</span><br><span class="line">push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">mov ax,[bp+4]</span><br><span class="line">add ax,[bp+6]</span><br><span class="line">mov [bp+8],ax</span><br><span class="line">mov sp,bp</span><br><span class="line">pop bp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>尝试画出栈的情况变化，理解栈在参数传递中的作用。</p><h1 id="寄存器冲突问题"><a href="#寄存器冲突问题" class="headerlink" title="寄存器冲突问题"></a>寄存器冲突问题</h1><p>现在你已经学会了子程序的编写，那么我们思考一个问题当我们循环调用一个子程序时，且子程序中使用了寄存器CX会发生什么？这个问题，我们之前遇到过类似的，当使用嵌套循环时也会出现这样的问题，内层循环更改了寄存器CX使得，外层循环出现了问题。同样，我们的子程序修改了CX使得循环出现了问题，我们要如何解决呢？没错还是使用栈来解决，我们在进入子程序后，立马将CX的值压入栈中，待程序完成后从栈中取出CX的值，不只是CX，只要是主程序用到，子程序重复使用的寄存器，我们都要这样处理一下，当然了要注意出栈入栈的顺序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（九）</title>
    <link href="http://example.com/2022/09/02/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <id>http://example.com/2022/09/02/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B9%9D%EF%BC%89/</id>
    <published>2022-09-02T02:13:13.000Z</published>
    <updated>2022-09-09T07:26:50.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li><li>nop占用一个字节，不进行任何动作</li></ol><p>话不多说我们马上开始。</p><h1 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h1><p>还记得我们之前学习过的jmp指令嘛，就是那个可以用来修改CS，IP的指令。jmp指令就是转移指令的一种，概括的来讲，转移指令就是可以控制CPU执行内存中某处代码的指令。8086CPU的转移行为有以下两种：</p><ul><li>只修改IP时，称为段内转移，比如：jmp AX。</li><li>同时修改CS和IP时，称为段间转移，比如：jmp 1000:0。</li></ul><p>由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。</p><ul><li>短转移IP的修改范围是-128~127。</li><li>近转移IP的修改范围是-32768~32767。</li></ul><p>8086CPU的转移指令可以分为以下几类：</p><ul><li>无条件转移指令（如jmp指令）</li><li>条件转移指令</li><li>循环指令（如loop指令）</li><li>过程</li><li>中断</li></ul><p>这些转移指令的前提条件可能不同，但是其中的原理都大相径庭，我们会在这一章中学习无条件转移指令jmp来理解CPU执行转移指令的基本原理。</p><h1 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h1><p>我们先引入一段简单的程序来介绍操作符offset：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,offset start</span><br><span class="line">s:mov ax,offset s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>现在我们来解释一下上面的程序offset操作符取到了标号处的偏移地址，例如offset得到了start和s的偏移地址分别是0和3，所以指令mov ax,offset start就等同于mov ax,0。</p><h1 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h1><p>jmp为无条件转移指令，可以修改IP也可以同时修改CS和IP。jmp指令要给出两种信息：</p><ol><li>转移的目的地址</li><li>转移的距离（段间转移，段内短转移，段内近转移）</li></ol><p>不同的给出目的地址的方法，不同的转移位置就对应着不同的jmp指令格式。</p><h2 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h2><p>jmp short 标号（转到标号处执行指令），这种格式的jmp指令实现的是段内短转移，之前说过这种转移的方式对IP的修改范围在-128~127，也就是说它最多可以向前跳转最多可以越过128个字节，向后跳转最多可以越过127个字节。short符号就说明了这个jmp指令进行的是一次短转移，标号就代表了这次跳转的目的地，待jmp指令执行完成之后，CS:IP应该指向标号处的指令。我们举一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">jmp short s</span><br><span class="line">add ax,1</span><br><span class="line">s:inc ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>上述程序运行后，ax中的值为1，这是因为执行jmp short s后，越过了add ax,1,IP指向了标号s处的指令inc ax。也就是说实际上程序只对ax进行了一次加1的工作。接下来我们看看jmp short s对应的机器指令，在此之前我们先看看别的汇编指令与其对应的机器指令：</p><p><img src="1.jpg" alt="汇编指令与其对应的机器指令"></p><p>可以看到一般的汇编指令其中的idata，无论它是一个数据还是内存单元的偏移地址，都会在它对应的机器指令中出现，因为CPU执行的是机器指令，它必须要处理这些数据或者地址。</p><p>现在我们回过头，使用debug将我们的程序翻译成机器指令看一下：</p><p><img src="2.jpg" alt="我们的程序与其对应的机器指令"></p><p>我们可以看到debug将jmp short s中的s表示为inc ax,1的偏移地址也就是0008H，并将jmp short s表示为jmp 0008，很合理的行为，但是我们看一下jmp short s对应的机器指令，我们发现它并不像是一般指令做的那样，它的机器码是EB 03,程序的0008H没有出现在机器指令中，这就意味着CPU在执行jmp short s的时候，它并不知道转移的目的地，那它是怎么知道到底要向哪里转移的呢？</p><p>我们修改一下程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">mov bx,0</span><br><span class="line">jmp short s</span><br><span class="line">add ax,1</span><br><span class="line">s:inc ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>然后再一次的使用debug将程序翻译成机器指令：</p><p><img src="3.jpg" alt="修改后的程序与其对应的机器指令"></p><p>OH！jmp指令对应的机器指令还是E8 03。这就说明了CPU在执行jmp指令的时候不需要转移的目的地址。这两次jmp指令转移的目的地址是不同的，如果机器指令中含有转移的目的地址，那么它们的机器指令也应该不同。可事实上它们的机器指令相同，这就说明jmp指令对应的机器指令中不包含转移的目的地址。</p><p>可是CPU不是上仙啊，你不告诉它转移的目的地址它也没办法工作呀，我们使用debug跟踪一下程序结合之前学习CPU执行程序的过程，仔细的看看CPU执行到jmp指令后到底发生了什么吧：</p><ol><li>(CS)=076AH，(IP)=0006H，CS:IP指向EB 03</li><li>读取指令码EB 03进入指令缓冲器</li><li>(IP)=(IP)+2=0008H，CS:IP指向add ax,1</li><li>CPU执行指令缓冲器的指令EB 03</li><li>指令EB 03执行后，(IP)=000BH，CS:IP指向inc ax</li></ol><p>从上面的整个过程我们知道了，CPU将指令EB 03读入后，本来已经将CS:IP指向了add ax,1，下一条指令应该执行</p><p>add ax,1，但在jmp指令执行完后IP变成了000BH，所以EB 03这条机器指令一定修改了IP。没错这条指令确实修改了IP，但是根据什么呢？03！只有03可能了，EB太大了这个数字不可能是修改的关键，没错就是03指导CPU如何修改IP，它们没有告诉CPU目的地址是多少，但却说出了需要转移的位移，03也就是从当前位置向后移动3个字节。那03是如何得到的呢，其实是编译器根据汇编指令中的标号计算出来的，我们给出一个公式：位移=标号处偏移地址-jmp指令下一条指令的偏移地址。对于修改后的程序来讲0003H=000BH-0008H。</p><p>实际上，jmp short 标号的功能为：(IP)=(IP)+8位位移。因为8位位移的取值范围是-128~127所以要使用补码来表示。</p><p>还有一种和jmp short 标号功能相近的指令格式。jmp near ptr 标号，它的功能是(IP)=(IP)+16位位移，实现了段内近转移。16位位移的取值范围是-32768~32767，也是使用补码表示。</p><p>这些位移得来的计算方法相同都是：位移=标号处偏移地址-jmp指令下一条指令的偏移地址。在编译程序编译时算出。</p><h2 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h2><p>我们刚才介绍了一个机器指令中不包含目的地址的jmp指令，那现在我们介绍一个机器指令中包含的目的地址jmp far ptr 标号 实现的是段间转移，又称远转移。功能如下：(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址。far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。我们举一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,0</span><br><span class="line">mov bx,0</span><br><span class="line">jmp far ptr s</span><br><span class="line">db 256 dup(0)</span><br><span class="line">s:add ax,1</span><br><span class="line">inc ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>我们使用debug将程序翻译成机器指令：</p><p><img src="4.jpg" alt="修改后的程序与其对应的机器指令"></p><p>可以看到jmp far ptr s的机器指令，为EA 0B 01 6A 07这其中就包含了目的地址，高地址的076AH为转移的段地址，低地址的010B是偏移地址。</p><h2 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h2><p>我们还是先来看一下指令的格式：jmp 16位reg，它的功能是(IP)=(16位reg)，当然了这已经是我们的老朋友了，我们就不多介绍了。</p><h2 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h2><p>转移指令中的转移地址还可以在内存之中，转移地址在内存中的jmp指令有两种格式：</p><h3 id="jmp-word-ptr-内存单元地址（段内转移）"><a href="#jmp-word-ptr-内存单元地址（段内转移）" class="headerlink" title="jmp word ptr 内存单元地址（段内转移）"></a>jmp word ptr 内存单元地址（段内转移）</h3><p>功能：从内存单元地址处开始存放着一个字，是转移的目的地址的偏移地址，也就是(IP)=(内存单元地址)。内存单元地址可用寻址方式的任一格式给出。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br><span class="line"></span><br><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">jmp word ptr [bx]</span><br></pre></td></tr></table></figure><p>这两种方式最终的结果相同，(IP)=0123H</p><h3 id="jmp-dword-ptr-内存单元地址（段间转移）"><a href="#jmp-dword-ptr-内存单元地址（段间转移）" class="headerlink" title="jmp dword ptr 内存单元地址（段间转移）"></a>jmp dword ptr 内存单元地址（段间转移）</h3><p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址，也就是(CS)=(内存单元地址+2)，(IP)=(内存单元地址)。内存单元地址可用寻址方式的任一格式给出。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">mov word ptr [bx+2],0</span><br><span class="line">jmp dword ptr [bx]</span><br></pre></td></tr></table></figure><p>这两种方式最终的结果相同，(CS)=0000H，(IP)=0123H，CS:IP指向0000:0123。</p><h1 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h1><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围为-128~127。我们来看一下它的格式：jcxz 标号，如果(CX)=0，转移到标号处执行。也就是当(CX)=0时，(IP)=(IP)+8位位移。位移计算方法也是老方法：位移=标号处偏移地址-jcxz指令下一条指令的偏移地址，结果用补码表示，在编译程序编译时算出。当(CX)不等于0时，程序什么也不会做，直接继续向下执行。所以从功能上来讲可以理解成if((CX)==0)jmp short 标号;。</p><p>这里我们给出一个jcxz指令的一种应用场景，在汇编语言编程中，当我们要处理一个字符串的时候，我们在结尾通常会有一个0标志着整个字符串至0为止，这个时候我们就可以使用jcxz指令和循环等方法结合，从字符串的第一个字符开始处理，直至遇到字符串结尾的0。或许char数组以\0结尾的原因也和jcxz指令有些许关系呢，如果小伙伴感兴趣，可以自行查找相关资料，这里不多讨论。</p><h1 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h1><p>loop指令是循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围为-128~127。我们来看一下它的格式：loop 标号（(CX)=(CX)-1，如果(CX)不等于0，转移到标号处执行）。位移计算方法也是老方法：位移=标号处偏移地址-jcxz指令下一条指令的偏移地址，结果用补码表示，在编译程序编译时算出，这些都是大同小异的。当(CX)=0时，程序什么也不会做，直接继续向下执行。所以从功能上我们可以理解为(CX)–；if((CX)!=0)jmp short 标号;。</p><h1 id="根据位移进行转移的意义"><a href="#根据位移进行转移的意义" class="headerlink" title="根据位移进行转移的意义"></a>根据位移进行转移的意义</h1><p>相信有的小伙伴会疑问，为什么要算一下位移，然后通过位移再去确定最终的目的地址呢？其实这种设计，方便了程序段在内存中的浮动装配。我们看一段程序：</p><p><img src="5.jpg" alt="使用位移进行转移的意义"></p><p>这段程序无论装在内存的哪里都可以正确执行，因为loop s在执行时只涉及s的位移（-4，前移四个字节，补码表示为FCH），而不是s的地址。如果loop s的机器码中包含的是s的地址，等s处的指令不在目的地址处，程序的执行就会出错。而loop s的机器码中包含的是转移的位移，就不存在这个问题了，因为无论s处的指令实际地址是多少，loop指令的转移地址是不变的。</p><h1 id="编译器对转移位移超界的检测"><a href="#编译器对转移位移超界的检测" class="headerlink" title="编译器对转移位移超界的检测"></a>编译器对转移位移超界的检测</h1><p>注意，根据我们所学的转移指令发现，它们都有一个转移的范围，如果源程序中出现了超出转移范围的话，在编译阶段，编译器将报错。在我们之前使用的形如jmp 2000:0100的转移指令，这些都会引发编译报错，不过我们之前都是在debug中使用的，汇编编译器不认识而已。所以以后要小心源程序中不要出现这样的指令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（八）</title>
    <link href="http://example.com/2022/08/31/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <id>http://example.com/2022/08/31/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AB%EF%BC%89/</id>
    <published>2022-08-31T15:40:26.000Z</published>
    <updated>2022-09-02T02:12:03.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h1><p>这一篇可以算的上是一篇总结性的文章。我们知道，计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含其中：</p><ol><li>处理的数据在哪里？</li><li>要处理的数据有多长？</li></ol><p>这两个问题，在机器指令中必须给明确或者隐含的说明，要不然是没有办法工作的，所以我们这篇文章就在8086CPU的基础上进行讨论。</p><h1 id="bx、si、di、bp"><a href="#bx、si、di、bp" class="headerlink" title="bx、si、di、bp"></a>bx、si、di、bp</h1><p>前面三个寄存器我们都已经见过啦，我们来总结一下它们的用法：</p><ol><li>在8086CPU中只有这四个寄存器可以用在[…]中来进行内存单元的寻址。</li><li>在[…]中，这4个寄存器可以单个出现，或者只能以这四种组合出现：bx和si、bx和di、bp和si、bp和di。</li><li>只要在[…]中使用寄存器bp且指令中没有显性的给出段地址，那么段地址就默认在SS中。</li></ol><h1 id="机器指令：我的数据在哪里？"><a href="#机器指令：我的数据在哪里？" class="headerlink" title="机器指令：我的数据在哪里？"></a>机器指令：我的数据在哪里？</h1><p>绝大部分的机器指令都是进行数据处理的指令，处理大致分为三类：读取、写入、运算。但从机器指令这一层来讲，它并不关心数据的值是多少，而关心指令执行前一刻，它要处理的数据在哪里？在指令执行前，所要处理的数据可以在三个地方：CPU内部、内存、端口。</p><h1 id="汇编语言中数据位置的表达"><a href="#汇编语言中数据位置的表达" class="headerlink" title="汇编语言中数据位置的表达"></a>汇编语言中数据位置的表达</h1><p>在汇编语言中如何表达数据的位置呢？我们有三个概念来表达数据的位置。</p><p>1.立即数（idata）</p><p>对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），在汇编语言中成为：立即数（idata），在汇编指令中直接给出，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add bx,2000H</span><br><span class="line">or bx,00100000B</span><br><span class="line">mov AL,&#x27;a&#x27;</span><br></pre></td></tr></table></figure><p>2.寄存器</p><p>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx</span><br><span class="line">mov ds,ax</span><br><span class="line">push bx</span><br><span class="line">mov ds:[0],bx</span><br><span class="line">push ds</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,ax</span><br></pre></td></tr></table></figure><p>3.段地址（SA）和偏移地址（EA）</p><p>指令要处理的数据在内存中，在汇编指令中可以使用[X]的格式给出EA,SA在某个段寄存器中，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br><span class="line">mov ax,[di]</span><br><span class="line">mov ax,[bx+8]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line"></span><br><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bp+8]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+si+8]</span><br><span class="line"></span><br><span class="line">mov ax,ds:[bp]</span><br><span class="line">mov ax,es:[bx]</span><br><span class="line">mov ax,cs:[bx+si]</span><br><span class="line">mov ax,ss:[bx+si+8]</span><br></pre></td></tr></table></figure><p>存放段地址的寄存器可以是默认的，1到4条指令的段地址默认在ds中，5到8条指令的段地址默认在ss中，当然存放段地址的寄存器也可以显性给出，就像9到12条指令所做的。</p><h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p>当数据存放在内存中，我们有很多方式给顶这个内存单元的偏移地址，这种定位内存单元的方法一般被称为寻址方式。我们用一张图片来总结一下这些寻址方式。</p><p><img src="1.jpg" alt="寻址方式"></p><h1 id="指令要处理的数据有多长？"><a href="#指令要处理的数据有多长？" class="headerlink" title="指令要处理的数据有多长？"></a>指令要处理的数据有多长？</h1><p>8086CPU可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明到底是字操作还是字节操作，我们有如下方式处理：</p><p>1.通过寄存器名指明要处理的数据的尺寸，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">mov bx,ds:[0]</span><br><span class="line">mov ds,ax</span><br><span class="line">inc ax</span><br><span class="line"></span><br><span class="line">mov AL,1</span><br><span class="line">mov AL,BL</span><br><span class="line">mov AL,ds:[0]</span><br><span class="line">inc AL</span><br></pre></td></tr></table></figure><p>其中1到4条指令指明了是字操作，5到8条指明了是对字节操作。</p><p>2.用操作符 X ptr 指明内存单元的长度，X在汇编指令中可以为word或byte，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br><span class="line">inc word ptr ds:[0]</span><br><span class="line">add word ptr [bx],2</span><br><span class="line"></span><br><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">inc byte ptr [bx]</span><br><span class="line">inc byte ptr ds:[0]</span><br><span class="line">add byte ptr [bx],2</span><br></pre></td></tr></table></figure><p>其中1到4条指令指明了是字操作，5到8条指明了是对字节操作。在没有寄存器指明数据尺寸时，使用操作符指明时非常必要的，如果没有指明是无法正常工作的。</p><p>3.其他方法</p><p>有些指令默认了访问的是字节单元还是字单元，比如push [1000H]就不需要指明访问单元是字单元还是字节单元，push指令只进行字操作。</p><h1 id="寻址方式的综合应用"><a href="#寻址方式的综合应用" class="headerlink" title="寻址方式的综合应用"></a>寻址方式的综合应用</h1><p>我们通过一个问题来体验一下各种寻址方式的作用。</p><p>1982年，DEC公司有一条数据如下：</p><p>公司名称：DEC</p><p>总裁姓名：Ken Oslen</p><p>排       名：137</p><p>收       入：40（40亿美元）</p><p>著名产品：PDP</p><p>这些数据在内存中存放方式如下：</p><p><img src="2.jpg" alt="DEC公司数据"></p><p>根据图片可以知道，数据被存放在seg段中从偏移地址60H起始的位置，从seg:60+0开始存放了3个字节的公司名称；从seg:60+3开始存放了9个字节的总裁姓名；从seg:60+C开始存放了一个字型数据，排名；从seg:60+E开始存放了一个字型数据，公司的收入；从seg:60+10开始存放了3个字节的著名产品。</p><p>直到1988年DEC公司的信息有了如下变化：</p><ol><li>Ken Olsen在富豪榜上上升到了38位。</li><li>DEC的收入增加了70亿美元。</li><li>该公司的著名产品已变为VAX系列计算机。</li></ol><p>我们的任务就是把过时的数据修改掉。</p><p>我们直接看code段的关键代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov ax,seg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,60H</span><br><span class="line">mov word ptr [bx+0CH],38</span><br><span class="line">add word ptr [bx+0EH],70</span><br><span class="line">mov si,0</span><br><span class="line">mov byte ptr [bx+10H+si],&#x27;V&#x27;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx+10H+si],&#x27;A&#x27;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx+10H+si],&#x27;X&#x27;</span><br></pre></td></tr></table></figure><p>为了让大家对这段代码有更好的理解，我们用C语言写一下该程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">company</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> cn[<span class="number">3</span>];</span><br><span class="line">    <span class="type">char</span> hn[<span class="number">9</span>];</span><br><span class="line">    <span class="type">int</span> pm;</span><br><span class="line">    <span class="type">int</span> sr;</span><br><span class="line">    <span class="type">char</span> cp[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">company</span> <span class="title">dec</span>=</span>&#123;<span class="string">&quot;DEC&quot;</span>,<span class="string">&quot;Ken Oslen&quot;</span>,<span class="number">137</span>,<span class="number">40</span>,<span class="string">&quot;PDP&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    dec.pm=<span class="number">38</span>;</span><br><span class="line">    dec.sr=dec.sr+<span class="number">70</span>;</span><br><span class="line">    dec.cp[i]=<span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">    i++;</span><br><span class="line">    dec.cp[i]=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    i++;</span><br><span class="line">    dec.cp[i]=<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将两种代码的一些部分对应起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr [bx+0CH],38dec.pm=38;</span><br><span class="line">add word ptr [bx+0EH],70dec.sr=dec.sr+70;</span><br><span class="line">mov si,0   </span><br><span class="line">mov byte ptr [bx].10H[si],&#x27;V&#x27;dec.cp[i]=&#x27;V&#x27;;</span><br><span class="line">inc si    i++;</span><br><span class="line">mov byte ptr [bx].10H[si],&#x27;A&#x27;     dec.cp[i]=&#x27;A&#x27;;</span><br><span class="line">inc si   i++;</span><br><span class="line">mov byte ptr [bx].10H[si],&#x27;X&#x27;dec.cp[i]=&#x27;X&#x27;;</span><br></pre></td></tr></table></figure><p>怎么样是不是很直观，根据对比的结构，我们可以得知8086CPU提供如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便。一个结构化的数据包含了多个数据项，而且数据项的类型又不相同。这个时候我们就可以使用[bx+si+idata]来访问结构体中的数据。用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每一个元素。所以汇编语言提供了更为贴切的书写格式如[bx].idata、[bx].idata[si]。</p><p>在C语言中我们又可以看到，如dec.cp[i]，dec是一个变量名，指明了结构体变量的地址，cp是结构体中的一个变量，指明了数据项cp的地址，而i用来定位cp中的每一个字符。所以看看dec.cp[i]和[bx].10H[si]是不是很像呢？</p><h1 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h1><p>div指令是除法指令，使用div要注意如下事情：</p><ol><li>除数：有8位和16位，在一个reg或内存单元中。</li><li>被除数：默认放在AX或者DX和AX中，如果除数是8位，被除数为16位，默认存放在AX中；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。注意！被除数的位数一定是除数的两倍。</li><li>结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</li></ol><p>div指令的格式是这样的：div reg 或 div 内存单元</p><p>我们举几个例子来看一下div指令：</p><p>div byte ptr ds:[0]</p><p>首先，我们根据操作符确定了除数是8位的，所以被除数是16位的，被存放在AX中了，执行后商被存储在AL中，余数被存放在AH中。用符号表达就是 (AL)=(AX)/((ds)×16+0)的商， (AH)=(AX)/((ds)×16+0)的余数。</p><p>div  word ptr es:[0]</p><p>首先，我们还是根据操作符确定了除数是16位的，所以被除数就是32位的，需要AX和DX共同存储，其中DX存储了高16位，AX存储了低16位，执行时DX中的数据要先乘10000H（左移四位）再加上AX中的数据才能组成被除数，例如被除数是8b1d7eecH那么就意味着(DX)=8b1dH,(AX)=7eecH，所以被除数就等于(DX)×10000H+(AX)。用符号表达就是 (AX)=[(DX)×10000H+(AX)]/((es)×16+0)的商， (DX)=[(DX)×10000H+(AX)]/((es)×16+0)的余数。</p><h1 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a>伪指令dd</h1><p>前面我们用db和dw定义字节型数据和字型数据，dd是用来定义dword（双字）型数据的，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">db 1</span><br><span class="line">dw 1</span><br><span class="line">dd 1</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>在data段定义了3个数据：</p><p>第一个数据为01H,在data:0处，占1个字节；</p><p>第一个数据为0001H,在data:1处，占1个字；</p><p>第一个数据为00000001H,在data:3处，占2个字。</p><h1 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h1><p>dup是一个操作符，在汇编语言中和db、dw、dd等一样，也是编译器识别处理的符号。它是和db、dw、dd等数据定义伪指令配合使用的，用来数据的重复。例如：</p><p>db 3 dup(0) 就是定义了三个字节，它们的值都是0，相当于db 0,0,0</p><p>db 3 dup(1,2,3) 就是定义了九个字节，它们的值是0,1,2,0,1,2,0,1,2，相当于db 0,1,2,0,1,2,0,1,2</p><p>可见dup的使用格式如下：</p><p>db 重复的次数 dup （重复的字节型数据）</p><p>dw 重复的次数 dup （重复的字型数据）</p><p>dd 重复的次数 dup （重复的双字型数据）</p><p>dup是一个非常实用的操作符，比如要定义一个200个字节大小的栈段，原本你需要使用dw声明100个字型数据，但现在你可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack segment</span><br><span class="line">db 200 dup(0)</span><br><span class="line">stack ends</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（七）</title>
    <link href="http://example.com/2022/08/31/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>http://example.com/2022/08/31/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%83%EF%BC%89/</id>
    <published>2022-08-30T23:47:28.000Z</published>
    <updated>2022-09-01T12:17:00.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li></ol><p>话不多说我们马上开始。</p><h1 id="AND和OR指令"><a href="#AND和OR指令" class="headerlink" title="AND和OR指令"></a>AND和OR指令</h1><p>今天的开场比较直接，我们要学习一下and和or指令，因为我们想有一种更为灵活的定位内存地址的方法和相关的编程方法，话不多说开干！</p><p>我们来看一下and指令，and指令是逻辑与指令，按位进行与运算，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,01100011B</span><br><span class="line">and AL,00111011B</span><br></pre></td></tr></table></figure><p>这两个指令运行后的结果是(AL)=00100011B，可以通过and指令设定操作对象的相应位为0，其余位不变。</p><p>比如AND AL，10111111B 设置了AL的第6位为0。AND AL，11111110B设置了AL的第0位为0。</p><p>之后我们来看一下or指令，or指令是逻辑或指令，按位进行或运算，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,01100011B</span><br><span class="line">or AL,00111011B</span><br></pre></td></tr></table></figure><p>这两个指令运行后的结果是(AL)=00111011B，可以通过and指令设定操作对象的相应位为1，其余位不变。</p><p>比如OR AL，01000000B 设置了AL的第6位为0。OR AL，00000001B设置了AL的第0位为0。</p><h1 id="以字符的形式给出数据"><a href="#以字符的形式给出数据" class="headerlink" title="以字符的形式给出数据"></a>以字符的形式给出数据</h1><p>在上一篇我们定义了很多数据，但这些数据都是数字，在我们编程的过程中肯定会有用到字符的时候，所以在汇编语言中我们用’……’的方式指明数据是以字符的形式给出的，编译器将这些数据转化为对应的ASCII码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;unIX&#x27;</span><br><span class="line">db &#x27;foRK&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:  mov AL,&#x27;a&#x27;</span><br><span class="line">mov BL,&#x27;b&#x27;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>上述代码中，db’ unIX’相当于“db 75H,6EH,49H,58H”。这样我们就以字符的形式给出了一组数据。</p><h1 id="大小写转换问题"><a href="#大小写转换问题" class="headerlink" title="大小写转换问题"></a>大小写转换问题</h1><p>现在考虑这个问题，我们定义两个段，分别是codesg和datasg，我们在datasg中声明两个字符串’BaSiC’和’iNfOrMaTiOn’，我们要把第一个字符串转化为大写，第二个字符串转化为小写。那么我们要如何操作呢？</p><p>我们先来分析一下，我们知道在ASCII码标准中小写字母的ASCII码比大写字母的ASCII码大20H，所以只要大写字母减去20H，小写字母加上20H就可以实现大小写字母的转化。知道这点后，我们只要将第一个字符串中的小写字母转化为大写字母，第二个字符串的大写字母变小写字母就可以了，所以我们的程序还要能判断那个字母是大写的那个是小写的。OK！就这么干。呃呃，等会儿，这里有人知道怎么判断一个字母是大写还是小写嘛。。。。呃呃，这可有点难办。我们还没学怎么去判断呢。。那看来我们要从新找一个规律了。</p><table><thead><tr><th align="center">二进制</th><th align="center">十六进制</th><th align="center">大写字符</th><th align="center">二进制</th><th align="center">十六进制</th><th align="center">小写字符</th></tr></thead><tbody><tr><td align="center">01000001</td><td align="center">41</td><td align="center">A</td><td align="center">01100001</td><td align="center">61</td><td align="center">a</td></tr><tr><td align="center">01000010</td><td align="center">42</td><td align="center">B</td><td align="center">01100010</td><td align="center">62</td><td align="center">b</td></tr><tr><td align="center">01000011</td><td align="center">43</td><td align="center">C</td><td align="center">01100011</td><td align="center">63</td><td align="center">c</td></tr><tr><td align="center">01000100</td><td align="center">44</td><td align="center">D</td><td align="center">01100100</td><td align="center">64</td><td align="center">d</td></tr><tr><td align="center">01000101</td><td align="center">45</td><td align="center">E</td><td align="center">01100101</td><td align="center">65</td><td align="center">e</td></tr><tr><td align="center">01000110</td><td align="center">46</td><td align="center">F</td><td align="center">01100110</td><td align="center">66</td><td align="center">f</td></tr><tr><td align="center">01000111</td><td align="center">47</td><td align="center">G</td><td align="center">01100111</td><td align="center">67</td><td align="center">g</td></tr><tr><td align="center">01001000</td><td align="center">48</td><td align="center">H</td><td align="center">01101000</td><td align="center">68</td><td align="center">h</td></tr><tr><td align="center">01001001</td><td align="center">49</td><td align="center">I</td><td align="center">01101001</td><td align="center">69</td><td align="center">i</td></tr><tr><td align="center">01001010</td><td align="center">4A</td><td align="center">J</td><td align="center">01101010</td><td align="center">6A</td><td align="center">j</td></tr><tr><td align="center">01001011</td><td align="center">4B</td><td align="center">K</td><td align="center">01101011</td><td align="center">6B</td><td align="center">k</td></tr><tr><td align="center">01001100</td><td align="center">4C</td><td align="center">L</td><td align="center">01101100</td><td align="center">6C</td><td align="center">l</td></tr><tr><td align="center">01001101</td><td align="center">4D</td><td align="center">M</td><td align="center">01101101</td><td align="center">6D</td><td align="center">m</td></tr><tr><td align="center">01001110</td><td align="center">4E</td><td align="center">N</td><td align="center">01101110</td><td align="center">6E</td><td align="center">n</td></tr><tr><td align="center">01001111</td><td align="center">4F</td><td align="center">O</td><td align="center">01101111</td><td align="center">6F</td><td align="center">o</td></tr><tr><td align="center">01010000</td><td align="center">50</td><td align="center">P</td><td align="center">01110000</td><td align="center">70</td><td align="center">p</td></tr><tr><td align="center">01010001</td><td align="center">51</td><td align="center">Q</td><td align="center">01110001</td><td align="center">71</td><td align="center">q</td></tr><tr><td align="center">01010010</td><td align="center">52</td><td align="center">R</td><td align="center">01110010</td><td align="center">72</td><td align="center">r</td></tr><tr><td align="center">01010011</td><td align="center">53</td><td align="center">S</td><td align="center">01110011</td><td align="center">73</td><td align="center">s</td></tr><tr><td align="center">01010100</td><td align="center">54</td><td align="center">T</td><td align="center">01110100</td><td align="center">74</td><td align="center">t</td></tr><tr><td align="center">01010101</td><td align="center">55</td><td align="center">U</td><td align="center">01110101</td><td align="center">75</td><td align="center">u</td></tr><tr><td align="center">01010110</td><td align="center">56</td><td align="center">V</td><td align="center">01110110</td><td align="center">76</td><td align="center">v</td></tr><tr><td align="center">01010111</td><td align="center">57</td><td align="center">W</td><td align="center">01110111</td><td align="center">77</td><td align="center">w</td></tr><tr><td align="center">01011000</td><td align="center">58</td><td align="center">X</td><td align="center">01111000</td><td align="center">78</td><td align="center">x</td></tr><tr><td align="center">01011001</td><td align="center">59</td><td align="center">Y</td><td align="center">01111001</td><td align="center">79</td><td align="center">y</td></tr><tr><td align="center">01011010</td><td align="center">5A</td><td align="center">z</td><td align="center">01111010</td><td align="center">7A</td><td align="center">z</td></tr></tbody></table><p>我们掏出来我们的小对照表，我们再来分析分析。从十六进制的角度我们已经走不通了，那我们来看看二进制吧！</p><p>我们观察到大写字母的二进制ASCII码的第五位一定是0，小写字母的二进制ASCII码的第五位一定是1，而且大小写字母的二进制ASCII码也只有这个区别除了这个第五位，其他位都是一样的，所以我们只要将数据的第五位变成1就可以将大写字母变成小写字母，同样我们只要把数据的第五位变成0就可以将小写字母变为大写字母，那如何将一个二进制数据的某一位变成1或者0呢？当然是AND和OR啦！我们来看具体代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,5</span><br><span class="line">S: mov AL,[bx]</span><br><span class="line">and AL,11011111B</span><br><span class="line">mov [bx],AL</span><br><span class="line">INC bx</span><br><span class="line">loop S</span><br><span class="line">mov bx,5</span><br><span class="line">mov cx,11</span><br><span class="line">S0: mov AL,[bx]</span><br><span class="line">or AL,00100000B</span><br><span class="line">mov [bx],AL</span><br><span class="line">INC bx</span><br><span class="line">loop S0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h1><p>相信小伙伴们，知道[bx]的含义后，肯定也能猜到[bx+idata]的含义，没错[bx+idata]也代表一个内存单元，它的偏移地址是(bx)+idata。我们举个例子，mov ax，[bx+200]，这条指令的含义是将一个内存单元中的内容送入寄存器AX中，这个内存单元长度为2个字节，偏移地址为寄存器BX中的数值加上200，段地址在ds中，物理地址为（ds）×16+（bx）+200。当然了我们更习惯这样写：mov ax，[200+bx]、mov ax,200[bx]或者mov ax,[bx].200。</p><h1 id="用-bx-idata-的方式进行数组的处理"><a href="#用-bx-idata-的方式进行数组的处理" class="headerlink" title="用[bx+idata]的方式进行数组的处理"></a>用[bx+idata]的方式进行数组的处理</h1><p>相信仔细研究过高级语言中数组的小伙伴们看到这个标题就已经隐隐约约的能体会到[bx+idata]如何进行数组的处理的了，那我们来好好的讨论一下到底是怎么进行数组处理的。我们稍微改一下问题条件，这次我们提供的两个字符串是’BaSiC’和’MinIX’，也是将他们分别转变成大写字符串和小写字符串。</p><p>我们来分析分析，首先字母’B’的地址是datasg:0,而字母’M’的地址是datasg:5,恰好这两个字符串还都是五个字符，所以我们可以这样做，来看具体代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;MinIX&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,5</span><br><span class="line">S: mov AL,0[bx]</span><br><span class="line">and AL,11011111B</span><br><span class="line">mov 0[bx],AL</span><br><span class="line">mov AL,5[bx]</span><br><span class="line">or AL,00100000B</span><br><span class="line">mov 5[bx],AL</span><br><span class="line">inc bx</span><br><span class="line">loop S</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>我们在写一个C语言的来对比一下，体会一下用[bx+idata]的方式进行数组的处理，来看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> a[<span class="number">5</span>]=<span class="string">&quot;BaSiC&quot;</span>;</span><br><span class="line"><span class="type">char</span> b[<span class="number">5</span>]=<span class="string">&quot;MinIX&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=a[i]&amp;<span class="number">0xDF</span>;</span><br><span class="line">        b[i]=b[i]|<span class="number">0x20</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言：a[i],b[i]  汇编语言：0[bx],5[bx]</p><p>相信大家经过对比可以体会到两种语言的相似之处，它们都有起始地址和偏移地址。[bx+idata]的方式为高级语言实现数组提供了便利机制。</p><h1 id="bx-si-和-bx-di"><a href="#bx-si-和-bx-di" class="headerlink" title="[bx+si]和[bx+di]"></a>[bx+si]和[bx+di]</h1><p>寄存器si和di是8086CPU中和bx功能相近的寄存器，si和di不能被分成两个8位寄存器使用。通过之前的学习我们可以使用[bx(si或di)]和[bx(si或di)+idata]的方式来指明一个内存单元，我们还有更灵活的方式：[bx+si]和[bx+di]。我们举个例子：mov ax，[bx+si]，这条指令的含义是将一个内存单元中的内容送入寄存器AX中，这个内存单元长度为2个字节，偏移地址为寄存器BX中的数值加上寄存器si中的数值，段地址在ds中，物理地址为（ds）×16+（bx）+（si）。当然了我们更习惯这样写：mov ax,[bx][si]。</p><h1 id="bx-si-idata-和-bx-di-idata"><a href="#bx-si-idata-和-bx-di-idata" class="headerlink" title="[bx+si+idata]和[bx+di+idata]"></a>[bx+si+idata]和[bx+di+idata]</h1><p>终极版本，我们可以使用[bx+si+idata]和[bx+di+idata]指定内存单元，我们举个例子：mov ax，[bx+si+200]，这条指令的含义是将一个内存单元中的内容送入寄存器AX中，这个内存单元长度为2个字节，偏移地址为寄存器BX中的数值加上寄存器si中的数值再加上200，段地址在ds中，物理地址为（ds）×16+（bx）+（si）+200。当然了我们更习惯这样写：mov ax,[bx+200+si]、mov ax,[200+bx+si]、mov ax,200[bx][si]、mov ax,[bx].200[si]、mov ax,[bx][si].200。</p><h1 id="总结不同寻址方式"><a href="#总结不同寻址方式" class="headerlink" title="总结不同寻址方式"></a>总结不同寻址方式</h1><p>我们比较一下前面用到的几种定位内存地址的方法，就可以发现：</p><p>1.[idata]用一个常量表示地址，这样可以用来直接定位一个内存单元。</p><p>2.[bx]用一个变量表示内存地址，这样可以用来间接定位一个内存单元。</p><p>3.[bx+idata]用一个变量和常量表示地址，这样可以用来在一个起始地址的基础上用变量间接的定位一个内存单元。</p><p>4.[bx+si]用两个变量表示地址。</p><p>5.[bx+si+idata]用两个变量和一个常量表示地址。</p><p>我们创建两个场景体验不同的寻址方法带来的便利。</p><h2 id="bx-idata-1"><a href="#bx-idata-1" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h2><p>我们来思考这个问题，现在我们声明6个单词，我们的任务是将单词的第一个字母变为大写字母：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;1. file          &#x27;</span><br><span class="line">db &#x27;2. edit          &#x27;</span><br><span class="line">db &#x27;3. search        &#x27;</span><br><span class="line">db &#x27;4. view          &#x27;</span><br><span class="line">db &#x27;5. options       &#x27;</span><br><span class="line">db &#x27;6. help          &#x27;</span><br><span class="line">datasg ends</span><br></pre></td></tr></table></figure><p>每个单词占用16个字节大小，不足的位置使用空格添补，这6个单词因为是连续存储进去的，可以将这6个单词看成一个6行16列的二位数组。按照要求，我们需要修改每一个单词的第一个字母，即二维数组的每一行的第4列。那我们完全可以使用[bx+idata]来定位这一列，使用BX+16来换行。我们来看具体代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;1. file          &#x27;</span><br><span class="line">db &#x27;2. edit          &#x27;</span><br><span class="line">db &#x27;3. search        &#x27;</span><br><span class="line">db &#x27;4. view          &#x27;</span><br><span class="line">db &#x27;5. options       &#x27;</span><br><span class="line">db &#x27;6. help          &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,6</span><br><span class="line">s:mov AL,[bx+3]</span><br><span class="line">and AL,11011111B</span><br><span class="line">mov [bx+3],AL</span><br><span class="line">add bx,16</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="bx-si"><a href="#bx-si" class="headerlink" title="[bx+si]"></a>[bx+si]</h2><p>我们再思考这个问题，现在我们再声明4个字符串，我们的任务是把所有字母都变为大写字母：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm             &#x27;</span><br><span class="line">db &#x27;dec             &#x27;</span><br><span class="line">db &#x27;dos             &#x27;</span><br><span class="line">db &#x27;vax             &#x27;</span><br><span class="line">datasg ends</span><br></pre></td></tr></table></figure><p>每个字符串占用16个字节大小，不足的位置使用空格添补，这4个字符串因为是连续存储进去的，可以将这4个字符串看成一个4行16列的二位数组。按照要求，我们需要修改每一个行的前三列，即二维数组的每一行的前三列。那我们可以使用[bx+si]来定位我们用si定位列，bx定位行，进行一次嵌套循环，我们来看一下具体代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm             &#x27;</span><br><span class="line">db &#x27;dec             &#x27;</span><br><span class="line">db &#x27;dos             &#x27;</span><br><span class="line">db &#x27;vax             &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s0:mov si,0</span><br><span class="line">mov cx,3</span><br><span class="line">s:mov AL,[bx+si]</span><br><span class="line">and AL,11011111B</span><br><span class="line">mov [bx+si],AL</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">add bx,16</span><br><span class="line">loop s0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>不知道大家会不会感觉哪里不太对，没错这个代码的逻辑是错误的，我们在两个循环中使用了一个循环计数器，这就导致了我们在内部循环中将外部循环的数值，多一个计数器又不可能，因为loop指令默认的计数器是cx，怎么办？</p><p>我们可以选择使用另一个寄存器来存储外部循环的计数，但万一别的寄存器也被用了呢？万一没有多余的寄存器给我暂存这种数据呢？所以使用另一个寄存器的方案不太可行，那我们可不可以使用内存来存储这个数据呢？我们只需要开辟一段内存空间来存储这个数据就好，只需要在数据段添加一句“dw 0”。</p><p>问题虽然被解决了但如果我们要同时保存多个这样的数据呢？那我们就要记住数据到底放到了哪个单元中，这太麻烦了，我们怎么优化一下这个方案呢？想想我们学到现在能使用的好像只有栈了，没错，一般来讲，我们在需要暂存数据的时候，我们都应该使用栈。这样我们只需要使用PUSH指令和POP指令就可以很方便存取数据。我们看一下最后改进好的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg，ss:stacksg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm             &#x27;</span><br><span class="line">db &#x27;dec             &#x27;</span><br><span class="line">db &#x27;dos             &#x27;</span><br><span class="line">db &#x27;vax             &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,stacksg</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,datasg</span><br><span class="line">mov ds,0</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s0:push cx</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,3</span><br><span class="line">s:mov AL,[bx+si]</span><br><span class="line">and AL,11011111B</span><br><span class="line">mov [bx+si],AL</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">add bx,16</span><br><span class="line">pop cx</span><br><span class="line">loop s0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（六）</title>
    <link href="http://example.com/2022/08/29/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://example.com/2022/08/29/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AD%EF%BC%89/</id>
    <published>2022-08-29T15:18:59.000Z</published>
    <updated>2022-08-31T06:07:48.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li></ol><p>话不多说我们马上开始。</p><h1 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h1><p>在学习这一章之前，我们也写了不少程序了，但这些程序都是只使用了一个段的，就好像一个程序只有Main函数。这种写程序的手法是很低端的，一点都不符合我们高端程序员的身份，更何况万一我的程序需要其他地方放数据怎么办？在上一篇中，我们讲到了要使用一段安全的空间，但是那段空间只有256个字节大小，万一我们需要的空间大于256个字节怎么办？其实在操作系统的管控下，程序可以取得任意容量的内存，操作系统会为我们安排好。</p><p>程序获取空间的手段有两种，一种是在加载程序时为程序分配好，另一种是在程序执行的过程中向系统申请。第二种就是我们在高级语言中使用的malloc或者new函数等等，这里不多讨论。我们之前在源程序中定义段来进行内存空间的获取，这就是我们为了程序加载过程中得到所需空间做的准备。</p><p>大多数有用的程序，都要处理数据，使用栈等等操作，为了设计上看起来清晰，我们也会定义很多段来做不同的事情，就像是我们会写很多函数而不是把代码全都堆放在Main中。我们慢慢的去体验由一个段的程序到多个段的程序这个过程。</p><h1 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h1><p>试想这样一个问题，现在我们有这样8个数据，分别是0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H。我们要做这样一件事情将他们累加起来放在AX中。之前我们也做过类似的事情，只不过那个时候我们还没有要求将特定的数据累加起来。自从学会loop指令后，总是想用一下看看，没错这次的问题是使用loop指令来完成，但这就代表着我们在累加前，要想办法把这8个数据存放在一组地址连续的内存单元中，就像是我们在高级语言中会做的那样，把他们放在数组中。但问题是我们要上那找到再这样一组内存单元呢？我们不能自己随便找一段内存单元就把它们丢进去了，这样太不负责任了，我们应该告诉系统我们需要一个地方来放这些数据，由系统分配给我们。那具体我们要怎么做呢？来看看代码叭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>首先，解释一下什么是“dw”，dw即“define word”翻译过来就是定义字型数据，在这里dw定义了8个字型数据，大小16个字节，那么这些数据存在哪里了呢？数据既然是跟着代码一起被加载到内存中的，那肯定是在代码段中啦，因为dw定义数据的位置在整个代码段的最上面，所以这8个数据的偏移地址就是0,2,4,6,8,A,C,E。所以在循环中bx每次加2来累加这8个字型数据。</p><p>在编写完成程序以后我们编译、连接，等等先别急，我们用debug追踪一下看看，debug使用U指令！</p><p><img src="1.jpg" alt="debug使用U指令！"></p><p>啊！什么？这是什么？！这不是我的代码啊！哎别急别急，你仔细看看这些汇编指令对应的机械码，是不是看起来很眼熟，没错这16个字节对应的就是程序所定义的字型数据，它们也是程序的一部分。我们跳过这个部分，从0B3D:0010后面看。</p><p><img src="2.jpg" alt="其实在这里呐"></p><p>所以我们想要正确的运行程序就要手动的使用r指令将寄存器IP改为10H。但我们的程序要怎么直接运行呢？总不能让所有人都会使用debug，都手动更改IP吧！当然不需要这样我们只需要对源程序进行小小的改动就可以解决这个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H</span><br><span class="line">start:mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>注意啦！我们在程序的第一条指令前面加了一个标号，并且在伪指令end后面也加上了同名标号。这里我们就要再一次的讨论end的作用啦，end除了可通知编译器程序到此结束外，还可以通知编译器程序到底从哪里进入。正如修改后的代码所做，伪指令end告诉编译器这个程序要从start后面开始，”mov bx,0“才是第一条指令。</p><p>我们之前说过，一个程序运行首先由一个其他程序装载到内存中将CPU的控制权递交给程序，根据第一条指令的段地址和偏移地址来设置寄存器CS和寄存器IP，最后程序运行完将CPU的控制权归还。可问题是，怎么才能知道那一条才是程序的第一条指令呢？我们知道一个可执行文件由描述信息和程序组成，程序就是我们写的代码，描述信息就是处理伪指令后得到的信息，我们在上面在这个程序中使用end告知编译器程序的起始位置与程序的结束位置，在编译后end start就变成了入口地址，储存在描述信息中，所以可以知道程序第一条指令的位置。所以我们若要CPU从何处开始执行程序，只要使用”end 标号“指明就好。</p><h1 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h1><p>我们再来思考这样的问题还是上述8个数据：0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H。现在我们希望将它们逆序存放，我们要怎么做呢？我们来慢慢想，想要逆序一组数据，使用栈是一个非常好的选择，只需要将所有数据入栈，再出栈就可以实现逆序了，那么我们就需要一段可以用来当做栈的内存空间，同样我们不可以自己取用，要通过程序来得到这个空间。来看看代码叭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">code segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">start: movax,cs</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,30H</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>注意啦我们定义了16个字型数据，并将它们所占用的32个字节大小的空间作为栈使用，也就是说我们打算使用CS:10~CS:2F这段内存空间作为栈使用，初始情况下栈为空SS:SP要指向栈底，所以我们设置寄存器SP内容为30H。这样我们就的到了32个字节大小的栈。我们描述dw的作用时，可以说它定义了数据，同时也可以说它开辟了空间，看程序员具体希望得到的东西到底是空间还是数据。</p><h1 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h1><p>我们已经知道怎么把数据、代码、栈放入一个段中啦！但这样做会有两个问题，一是这样写整个程序会很乱，二是一个段的大小不可以超过64KB（这是8086模式的限制，不是所有处理器都这样）。所以我们应该考虑怎么把这些东西放到不同的段里面。其实很简单我们只需要定义多个段然后放进去不就好了嘛（额好废的废话。。），我们量来看具体代码叭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: movax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20H</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>怎么样是不是真的很简单！下面我们对程序仔细的说明一下：</p><h2 id="定义多个段的方法"><a href="#定义多个段的方法" class="headerlink" title="定义多个段的方法"></a>定义多个段的方法</h2><p>很简单，我们从程序中就可以看出，定义一个段的方法和前面所讲的定义代码段的方法一样，只不过不同的段，我们要命不同的名。</p><h2 id="对段地址与偏移地址的取用"><a href="#对段地址与偏移地址的取用" class="headerlink" title="对段地址与偏移地址的取用"></a>对段地址与偏移地址的取用</h2><p>现在程序里面有多个段了，我们访问数据就需要知道这些数据的地址，可是我们如何知道这些数据的地址呢？首先，在程序中段名就相当于一个标号，它就代表了段地址，比如data就代表了数据段的段地址，stack就代表了栈段的段地址。其次偏移地址，这些数据在自己的段中偏移地址都是从0开始的，就类似一个数组，数组名代表数组的起始位置，其中的数据的偏移地址就是自己的标号（当然数组的偏移地址不会是简单的0,1,2·····还要根据数组类型计算）。</p><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><p>首先，思考这样一个问题，我们定义一个段，如果段中的数据占N个字节，则程序加载后该段占用的实际空间为多少？我们一点点思考，一个段内可以根据段地址被分为一个个小段，这些小段每个大小为16字节。哪怕一个小段里面只存储了1字节大小的数据，其余都是空的那么也需要一整个小段。所以确定一个段到底占用多大空间，我们要先确定有多少个小段 ，这个很简单就是N/16+1，这里N/16的意思是向下取整的意思，先确定有多少个装满了的小段，加上1就是所用的全部小段，确定有多少个小段之后再乘16就是占用的空间大小了。所以答案是（N/16+1）×16。</p><p>想明白这个问题，我们另一个问题，现有如下程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">push ds:[0]</span><br><span class="line">push ds:[2]</span><br><span class="line">pop ds:[2]</span><br><span class="line">pop ds:[0]</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 0123H,0456H</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>假设code段的段地址为X，那么data段的段地址为多少？stack段的段地址为多少？</p><p>其实博主看到这个问题时候也是一头雾水，这可怎么办？我也不知道code段占用多大的空间啊，那我怎么知道要加多少才可以。后来博主在网上找到了答案，当你使用debug跟踪一个程序时，寄存器CX最开始会存储整个源程序无论是代码段还是栈段或者其他段的整体大小（这里博主试验了一下，使用d指令查看程序占用大小为8，寄存器CX中也确实存储了0008H）。</p><p><img src="3.jpg" alt="CX中存储源程序大小"></p><p>所以当我们使用debug跟踪问题提供的程序以后，可以看到(CX)=0044H，也就是68个字节，我们可以把这68个字节看成一个大段它使用了5个小段来存储内容，其中stack和data使用了1个段（这是根据stack和data中数据占用大小计算的出的，和上一个问题相同），这样代码段就使用了3个段，根据程序从上到下的顺序可以知道代码段的段地址加上3就是data段的段地址，加上4就是stack段的段地址，所以答案是data段的段地址为X+3，stack段的段地址为X+4。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学习到这里，我们已经掌握了很多汇编知识了，所以在这里写一个总结（其实是有个事情我不知道写在哪里好随便插在总结里叭），汇编语言的学习是为了让我们深刻的理解计算机硬件，对于计算机的运作有深刻的认知，但要记住汇编语言也是人类创造出来方便人类的语言，它并不是计算机的母语，汇编语言最后还是会转变为二进制代码，变成高电平，低电平来工作的，所以我们写下的代码不代表CPU会根据我们的认知来运作，不是说我们定义一个栈CPU就会承认它是个段，SS:SP才决定了哪里是栈段，其余的也是如此。最后，汇编语言的旅程才刚刚开始，加油叭！少年！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（五）</title>
    <link href="http://example.com/2022/08/24/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://example.com/2022/08/24/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%94%EF%BC%89/</id>
    <published>2022-08-23T16:52:41.000Z</published>
    <updated>2022-09-06T13:48:42.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li></ol><p>话不多说我们马上开始。</p><h1 id="对前言更新的解释"><a href="#对前言更新的解释" class="headerlink" title="对前言更新的解释"></a>对前言更新的解释</h1><p>相信小伙伴们都发现了，我们的老伙伴前言终于更新啦！！这次更新了两条第一条是使用()，第二条是idata，我们一一说明。</p><p>首先是(地址或寄存器名称)，为了描述上的简洁以后我们就都用(地址或寄存器名称)来表示一个内存单元或者寄存器中的内容啦。比如(ax)就代表寄存器ax中的内容，(20000H)代表20000H处内存单元中存放的内容。至于()所得到的内容到底是字型数据还是字节型数据要根据具体的运算决定，()中可以出现三种元素：</p><ol><li>寄存器名</li><li>段寄存器名</li><li>地址（注意这里的地址是且必须是一个物理地址）</li></ol><p>所以(AX)、(DS)、(AL)、(20000H)、((ds)×16+(bx))都是正确的使用方式，但(2000:0)这样是不被允许的。学会了这个我们举一个应用的实际例子，对于PUSH AX的过程我们可以这样描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(SP)=(SP)-2</span><br><span class="line">((SS)×16+(SP))=(AX)</span><br></pre></td></tr></table></figure><p>其次是idata，这个很简单，“[0]”偏移地址过去用此类形式表示，我们使用idata代替0,1,2,3这样的常量。</p><p>(Tips:寄存器DS不可以直接使用mov指令对其赋值。)</p><h1 id="BX-与内存单元的描述"><a href="#BX-与内存单元的描述" class="headerlink" title="[BX]与内存单元的描述"></a>[BX]与内存单元的描述</h1><p>相信看到”[]”有的小伙伴已经展开回忆了，我们先来复习一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[0]</span><br><span class="line">MOV AL,[0]</span><br></pre></td></tr></table></figure><p>这就是[]最基本的使用方法了，CPU在执行这两条指令的时候从寄存器DS中取出段地址，在[]中取出偏移地址，组成物理地址后再进行其他的处理。这两条指令分别完成了这样两件事：</p><p>第一条指令将一个长度为2的内存单元中的内容放在了寄存器AX中。</p><p>第二条指令将一个长度为1的内存单元中的内容放在了寄存器AL中。</p><p>注意这其中的不同点，对于不同大小的寄存器，CPU送入的数据大小也不相同。是的，我们在完整的描述一个内存单元需要两种信息：</p><ol><li>内存单元的地址</li><li>内存单元的大小</li></ol><p>其中内存单元的地址会由寄存器DS与[address]指明，内存单元的大小会由具体的操作对象指出。[BX]也是指出偏移地址的作用，只不过[BX]的意思是偏移地址在寄存器BX中。</p><h1 id="试着用用-BX"><a href="#试着用用-BX" class="headerlink" title="试着用用[BX]"></a>试着用用[BX]</h1><p>这里我们通过一段代码理解[BX]。(Tips:inc指令代表自增1，当还有一个dec指令代表自减1。)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000H  </span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,[bx]</span><br><span class="line">inc bx</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],ax</span><br><span class="line">inc bx</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],ax</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],al</span><br></pre></td></tr></table></figure><p>其中0地址字单元内容为00BEH，2100:2-2100:7为空，试着写出程序运行完后的21000H-21007H单元中的内容。</p><p>答案：</p><p>21000H~21006H BE 00 BE 00 BE BE BE  21007H为空。</p><p>看完这段代码相信你也学到了一招，可以使用[BX]与inc指令实现偏移地址的改变。</p><h1 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h1><p>loop n. 循环。相信学习过C，JAVA等高级语言的小伙伴对循环一定不陌生，循环为我们简化代码做出了极大地贡献，在汇编语言中也是如此。先给大家剧个透loop指令有点像do····while。先来看一段使用loop指令的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line">code segment</span><br><span class="line">mov ax,2</span><br><span class="line">mov cx,11</span><br><span class="line">s:add ax,ax</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>可能有的小伙伴已经可以猜的八九不离十了，没错这段代码计算了2的12次幂。</p><p>我们来根据这段代码讲述一下loop指令到底怎么工作的，当程序运行至loop时，首先做了(cx)=(cx)-1，然后判断cx中的值，不为0则跳转标号(也就是程序中的S)处执行，若为0则结束loop指令继续向下执行。标号S在程序运行阶段会变成一个地址，loop指令在判断CX的值不为0后，loop s(地址)将寄存器IP设置为S。了解了loop的工作机理后，我们发现寄存器CX的值会影响loop指令的执行结果，是的，通常我们用loop指令实现循环，会用寄存器CX存放循环次数，当然这也不是绝对的，不同场合，我们会有不同的处理方式。注意哦！loop指令不会跳过内部的程序段，它一定是先执行一次在去执行loop指令，这点和do····while很像。</p><h1 id="Debug和MASM对指令的不同处理"><a href="#Debug和MASM对指令的不同处理" class="headerlink" title="Debug和MASM对指令的不同处理"></a>Debug和MASM对指令的不同处理</h1><p>这里的内容是为了下面的学习顺利进行所提供的预备知识。</p><p>还记得吗？我们在Debug中写过这样的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure><p>这条指令表示将DS:0处的数据送入AX中，但是在汇编源程序中，MASM会把它看做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br></pre></td></tr></table></figure><p>OMG!这可不好，这完全是两种意思。那我们要在源程序中将内存单元的内容送入寄存器中怎么办呢？有两种解决办法：</p><p>1.使用[BX]</p><p>先将段地址送入DS中，再将偏移地址送入BX，使用MOV AL,[BX]就可以将((DS)×16+(BX))中的内容送入AL中啦。(Tips:寄存器DS不可以直接使用mov指令对其赋值。)</p><p>2.在偏移地址前显示指出段地址</p><p>这个方法就比较简单了，我们将段地址送入DS后，只需要使用DS，在偏移地址前显示的指明段地址如MOV AL,DS:[0]这样就可以将((DS)×16+(0))中的内容送入AL里啦。</p><h1 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h1><p>上面我们讲到了两种方法用来解决MASM操作内存单元的问题，其中第二种方法使用了段寄存器显示指明段地址的方式，当然了这个段寄存器不止可以是DS还可以是CS、SS、ES这都可以用来指明内存单元的段地址，CS：、SS：、ES：、DS：在汇编语言中被称作段前缀。</p><h1 id="一段安全的空间"><a href="#一段安全的空间" class="headerlink" title="一段安全的空间"></a>一段安全的空间</h1><p>还记得吗？我们最最开始讲到过的内存地址空间，我们抽象了各个硬件的内存将他们汇总为一个整体叫做内存地址空间，其中有一部分存放着一些重要的系统数据和代码，这就意味着随意的修改一个地址中的内容是十分危险的。比如修改0:26H处内容，这将导致你的DOSBOX卡死，这是因为0:26H处放着重要的系统数据。可见，我们不可以在不能确定一段内存空间是否存放重要的数据或代码时，随意的向其中写入内容，我们要使用操作系统分配给我们的内存空间，下一章我们会对这一空间有所认识。</p><p>因为运行在CPU实模式下的DOS无法对硬件进行严格的管理，所以我们可以真正的去尝试、理解、体会硬件的工作，诸如Windows、Unix这些运行在CPU保护模式下的操作系统中，想要使用汇编语言去操作硬件这是不可能的。而且我们使用DOXBOX也不需要为这些危险行为买单，所以不要害怕这些危险操作。</p><p>虽然我们不需要为危险行为买单，但在学习过程中，因为不小心修改了某个关键的系统数据就要从头来过还是非常痛苦的事情，所以我们要找到一段安全的空间供我们使用。一般来讲0:200~0:2ff这256个字节空间就是非常好的选择。至于为什么一定是这里安全，我们以后会再讨论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（四）</title>
    <link href="http://example.com/2022/08/22/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://example.com/2022/08/22/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2022-08-22T11:50:17.000Z</published>
    <updated>2022-08-30T12:42:28.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li></ol><p>话不多说我们马上开始。</p><h1 id="一个源程序的诞生"><a href="#一个源程序的诞生" class="headerlink" title="一个源程序的诞生"></a>一个源程序的诞生</h1><p>oh！这是什么意思？一个源程序的诞生！没错，学到这里我们终于开始写我们的第一个完整的汇编语言程序了，用编译和连接程序将它们变成.exe文件。但在这之前我们还是先看看一个程序怎么诞生的吧。</p><p><img src="1.jpg" alt="一个源程序的诞生"></p><p>第一步，程序员打开了文本编辑器（Edit，记事本等）写下了一行一行汇编指令。这一步生成了一个储存源程序的文本文件。</p><p>第二步，使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，这样就生成了可以在操作系统中直接运行的可执行文件。</p><p>Tips：可执行文件包括两部分：</p><ul><li>程序（从源程序的汇编指令翻译过来的机器码）与数据（源程序定义的数据）</li><li>相关描述信息（比如，程序有多大，要占用多少内存空间等）</li></ul><p>这一步生成了一个可以在操作系统中直接运行的可执行文件。</p><p>第三步，执行可执行文件中的程序，操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如设置CS:IP指向第一条要执行的指令），由CPU执行程序。</p><h1 id="源程序什么样子嘞？"><a href="#源程序什么样子嘞？" class="headerlink" title="源程序什么样子嘞？"></a>源程序什么样子嘞？</h1><p><del>恭喜恭喜，是个男孩。</del> 我们来看下面这段源程序，认识一下它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,bx</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应机器码的指令，可以被编译为机器指令，最终由CPU所执行。而伪指令没有对应的机器码，不会被CPU执行，那谁来执行呢？伪指令是由编译器来执行的，根据伪指令进行相关的编译工作。</p><h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>在程序中一共出现了三种伪指令:</p><p>1.XXX segment ······· XXX ends</p><p>segment和ends是一对成对使用的伪指令，其作用是定义一个段，这两个指令是必不可少的，XXX代表段名。例如程序中codesg segment代表段codesg由此开始，codesg ends代表段codesg到此结束。一个汇编程序会有多个段用于存放指令，数据，或者被当做栈使用一个有意义的汇编程序至少有一个段，用来存放代码</p><p>2.end</p><p>注意啦！这里说的可不是上面所提到的ends，这是完全不同的！end代表了一个汇编程序的结束，编译器在编译一个汇编程序时遇到了end就会停止编译，所以在编写结束时，一定要记得写end。</p><p>3.assume</p><p>assume v.  假设。这条指令假设某一段寄存器和程序中的某一个用segment ······· ends定义的段相关联。通过assume说明这种关联，也就是assume将有特殊用途的段和相关的段寄存器关联起来了。比如在程序中我们定义了一个叫做codesg的段，这个段用来存放代码的，也就是一个代码段。那CPU中和代码有关的寄存器就是段寄存器CS，所以用assume将codesg和CS联系起来了。</p><h2 id="源程序中的“程序”"><a href="#源程序中的“程序”" class="headerlink" title="源程序中的“程序”"></a>源程序中的“程序”</h2><p>我们编程的最终目的是为了让计算机完成一定的任务。源程序中的伪指令由编译器来处理，这并不能实现我们编程的最终目的。我们所说的程序实际上是源程序中由计算机执行处理的指令或者数据。程序最开始以汇编指令的形式存在源程序中，经过编译、连接后变为机器码，存储在可执行文件中。</p><p><img src="2.jpg" alt="程序经编译连接后变为机器码"></p><h2 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h2><p>汇编程序中，除了汇编指令和伪指令外，还有一些标号，比如“codesg”。一个标号指代一个地址。比如codesg在segment前面作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p><h1 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h1><p>了解了一个汇编程序由什么组成后我们可以照着案例写出一个新的汇编程序，计算2的3次幂：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>看起来很完美，和案例一样完美？这些汇编指令现在已经存在源程序中了，经过编译、连接后变为机器码，存储在可执行文件中，但它要怎么才可以运行起来呢？</p><p>下面我们在DOS的基础上，简单的讨论一下这个问题。一个程序我们叫它P2在可执行文件中，则必须有一个正在运行的程序P1,将P2从可执行文件中载入内存后，将CPU的控制权交给P2，P2才可以开始运行，P1这时停止运行。等P2运行结束后，再把CPU控制权交还给P1，之后P1才会继续进行。感觉起来就像是我们写一个C++或者JAVA程序时要有一个main函数，程序由此开始，将CPU的控制权交给所调用的函数，等函数执行完在把CPU控制权交还给main函数。</p><p>现在我们知道了一个程序结束后，应该将CPU控制权交还给使它运行的程序，这个过程就叫做程序返回。但话又说回来，程序返回到底是怎么样返回的呢？我们要做什么呢？</p><p>我们回头看案例的汇编程序其中有这样两行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure><p>这两条指令就实现了程序返回。我们暂时不深究这两行代码的具体意义，只要知道这两行代码可以完成程序返回即可。</p><p>所以，我们写的程序还是有一点点的瑕疵，我们重新修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这样我们就得到了一个真的很完美的汇编程序。</p><h1 id="实现一个汇编程序！！"><a href="#实现一个汇编程序！！" class="headerlink" title="实现一个汇编程序！！"></a>实现一个汇编程序！！</h1><p>现在我们要动手写一个汇编程序啦！！！</p><h2 id="编辑源程序"><a href="#编辑源程序" class="headerlink" title="编辑源程序"></a>编辑源程序</h2><p>1.这里我们使用DOSBOX下edit</p><p><img src="3.jpg" alt="打开DOSBOX下的edit"></p><p>2.在edit界面下编写如下程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="4.jpg" alt="编写一个汇编程序"></p><p>3.保存这个汇编程序，点击File-Save，修改文件名称（File Name）为1.ASM 点击OK</p><p><img src="5.jpg" alt="保存汇编程序"></p><p>保存好的汇编程序在MASM文件夹下，忘记MASM的小伙伴可以回到<a href="https://liuzhengblog.com/2022/08/09/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89/">从0开始的汇编语言（一）</a>搭建汇编语言环境部分复习一下。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>现在我们有了源文件程序，我们要开始对它进行编译得到包含机器代码的目标文件。在编译一个源程序之前我们要先找到一个相应的编译器，恰好我们在搭建汇编语言环境时下载的命令文件中就有微软的MASM5.0汇编编译器。所以我们可以直接开始对源文件程序编译啦，以1.ASM为例。</p><p>1.打开DOSBOX输入MASM</p><p><img src="6.jpg" alt="打开MASM编译器"></p><p>2.输入保存的源程序文件1.ASM</p><p><img src="7.jpg" alt="编译源程序文件"></p><p>这里有几点要说明，首先，如果我们需要编译的文件扩展名不是ASM，比如是p1.txt那我们就要输入p1.txt全名称才可以。其次，Source filename输入的文件如果和MASM.exe在一个文件夹(MASM文件夹)下那么就可以省略路径，否则需要指定文件的路径。比如我们所需要编译的文件是在c:\windows\desktop下的p1.txt文件，那么我们就要输入c:\windows\desktop\p1.txt。最后Source filename后有[.ASM]这个代表默认的文件扩展名是ASM，如果你确实要编译一个ASM文件且文件位置与MASM.exe在一个文件夹下，那么只需要输入ASM文件名称即可。</p><p>在输入完1后会出现Object filename这个就是我们编译要得到的目标文件[1.OBJ]提示我们默认生成的目标文件名为1.OBJ如无更改可以enter跳过。之后出现的Source listing和Cross-reference生成的都是中间文件我们可以选择enter跳过，让编译器忽略生成。</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>现在我们有了目标文件1.obj，我们接下来对它进行连接，得到可执行文件。当然啦，我们也需要一个连接器，恰好我们有微软的Overlay Linker3.60连接器。事不宜迟，开始连接！</p><p>1.打开DOSBOX输入link，这里的注意事项和编译时的一样要注意路径和文件扩展名的问题。</p><p><img src="8.jpg" alt="连接目标文件1"></p><p>2.同样我们跳过剩下三个选项，这三个选项分别是生成的exe文件名称及位置，映像文件（.map），库文件(.lib)当然了，你也可以在第二个选项也就是生成exe文件那个选项中，输入你想要的路径及文件名，这样就可以在你想的位置生成执行文件啦。</p><p><img src="9.jpg" alt="连接目标文件2"></p><p>这里出现了 no stack segment （没有栈段）我们先忽略这个错误。</p><p>这样我们就得到了可执行文件1.exe只是你不能运行它，大人时代变了。</p><h2 id="简化的方式编译与连接"><a href="#简化的方式编译与连接" class="headerlink" title="简化的方式编译与连接"></a>简化的方式编译与连接</h2><p>如果你已经默认忽略中间文件生成了那你可以这样做：</p><p>编译时输入MASM 文件名（考虑路径，文件扩展名问题）；（注意结尾这个分号要加上要不然还是会询问中间文件是否生成）。</p><p>连接时输入link 文件名（考虑路径，文件扩展名问题）；（注意结尾这个分号要加上要不然还是会询问中间文件是否生成）。</p><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><p>呼！终于到这个时候啦，是不是还有点点紧张？安啦，安啦。打开DOSBOX输入1或者1.exe。</p><p><img src="10.jpg" alt="运行程序"></p><p>哎？！等会这是怎么回事，怎么没有反应！！什么都没有！！别急，别急。咱们也没写可以输出的指令，当然看不出来结果啦，我们以后会写其他可以看出结果的程序的，敬请期待。</p><h1 id="谁将程序装载到内存里并运行它呢？"><a href="#谁将程序装载到内存里并运行它呢？" class="headerlink" title="谁将程序装载到内存里并运行它呢？"></a>谁将程序装载到内存里并运行它呢？</h1><p>我们之前在程序返回部分讲到过，一个汇编程序运行需要另一个程序将该程序装载到内存之中并将CPU的控制权给该程序才可以，但我们刚才运行时候没用开另一个程序呀，那到底是谁把程序装载到内存中并且运行了呢？故事还要从操作系统的shell（外壳）讲起。</p><p>操作系统是一个由多功能模块组成的庞大的、复杂的软件系统。任何通用的操作系统都需要提供一个shell（外壳）的程序，供用户使用其操作计算机系统。听起来很玄妙，但其实我们常用的CMD，PowerShell就是Windows系统提供给我们的shell，而DOS也不例外，它为用户提供了一个叫做command.com的命令解释器，也就是DOS的Shell。DOS启动后，先进行一些重要的初始化工作，然后运行command.com，执行其他相关任务后，屏幕上显示当前盘符和路径组成的提示符。也就是我们打卡DOSBOX后的画面。这个时候command.com就已经在运行了。然后我们要运行我们的可执行文件1.exe，command就根据我们的文件名找到文件，将文件中的程序载入内存，修改CS:IP指向程序入口，此后command暂停工作，待CPU处理完1.exe，控制权交还给command。</p><p>所以真相只有一个，那就是command这个shell将程序装载到内存中并修改CS:IP指向程序入口。</p><h1 id="程序执行过程中的跟踪"><a href="#程序执行过程中的跟踪" class="headerlink" title="程序执行过程中的跟踪"></a>程序执行过程中的跟踪</h1><p>虽然我们没有办法看到程序输出在界面上，这是因为我们没有写一些输出指令。但我们写了mov指令呀，我们不能通过debug -r的方式去观察ax，bx的数值变化嘛，可以只不过我们用到的命令是debug 1.exe(可执行文件名)，这样debug就将1.exe载入了内存之中并修改了CS:IP。OH！对啦，如果你使用程序跟踪的方式运行一个程序，那就是debug程序将程序装载到内存中啦！</p><h1 id="程序去哪？"><a href="#程序去哪？" class="headerlink" title="程序去哪？"></a>程序去哪？</h1><p>现在我们知道了程序被command加载到了内存之中，可问题是程序到底加载到哪里了呢？我要从哪里才可以看到程序呢？谈到这个我们先看看一个程序如何被加载到内存中：</p><p><img src="11.jpg" alt="程序被加载到内存的过程"></p><p>由图可知，程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，这程序所在的内存区地址为ds：0，这个内存区前256个字节存放的是PSP,DOS用来和程序进行通信。从256字节往后的空间存放的就是程序。</p><p>所以从ds中可以得到PSP的段地址SA，PSP的偏移地址为0，则物理地址为SA×16+0</p><p>又因为PSP占256（100H）字节，所以程序的物理地址是：</p><p>SA×16+0+256=SA×16+16×16+0=(SA+16)×16+0</p><p>也就是段地址是SA+16，偏移地址是0。程序运行起来就会根据这两个地址分别设置寄存器CS与寄存器IP，从而进入程序。</p><p>了解完这些你就可以用debug来追踪你的程序啦但记住执行int 21H指令时要使用p指令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（三）</title>
    <link href="http://example.com/2022/08/19/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2022/08/19/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-08-19T05:00:45.000Z</published>
    <updated>2022-08-30T13:06:50.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li></ol><p>话不多说我们马上开始。</p><h1 id="字节型数据与字型数据"><a href="#字节型数据与字型数据" class="headerlink" title="字节型数据与字型数据"></a>字节型数据与字型数据</h1><p>众所周知，字节与字之间存在着一种二倍的关系，也就是说2个字节就等于1个字。由于内存单元是字节单元，也就是说一个内存单元只存储一个字节，所以计算机使用两个连续的内存单元存储一个字。计算机将这个字的第八位放在低位内存单元中，将高八位放在高位内存单元之中。我们称起始地址是N的字单元为N地址字单元。</p><h1 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h1><p>现在我们知道了计算机如何将一个字存储到内存单元之中，但是计算机又如何从内存单元之中取出一个字呢？这就要提到另一个段寄存器DS了。DS寄存器中通常存放着要访问数据的段地址。（Tips：物理地址=段地址×16+偏移地址）</p><p>例如我们想要读取10000H中的数据，我们就编写了如下的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov BX,1000H</span><br><span class="line">mov DS,BX</span><br><span class="line">mov AL,[0]</span><br></pre></td></tr></table></figure><p>这样我们就把10000H中的字节型数据存放到了AL中。</p><p>这个时候我相信肯定有的小伙伴就要发出了疑问“只有段地址没有偏移地址怎么能确定一个准确的内存单元呢？”我也相信有小伙伴已经发现了<del>华点</del>盲点。没错，DS和CS相同，也有一个搭档用来指示偏移地址，而这个搭档就是”[ address ]”。中括号中包含的地址就是偏移地址。</p><p>这里还需要注意的事是我们明明可以通过使用mov指令直接将1000H送入DS中，为什么还要大费周章先把1000H送入BX中再将BX中的数据送入DS呢？这个问题其实很简单，因为8086CPU不支持你这样做，这是一个硬件设计的问题，所以我们就记住要这样为DS提供地址。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>相信有计算机基础的小伙伴对于栈一定不陌生了，不过这里还是给各位介绍一下栈。我们举一个例子，我平时打羽毛球都会从桶中拿出第一个球，而这个球的下场只有两个，我把它打残废，我从羽毛球桶中拿出下一个球，或者它老老实实的配合我拍照，我把它放回桶中。这整个过程中，球都只从上面的开口中取出或者放入，我们没有从另一端取出在放入，这样的存取和最初生产出来的时候是相反的。所以我们给出栈的定义：栈是一种使用受限的线性表，其中数据符合后进先出（LIFO）的存取原则。</p><p><img src="1.jpg" alt="栈"></p><h1 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h1><p>现如今的CPU中都有栈的设计。8086CPU提供了出栈与入栈的指令，即PUSH（入栈）与POP（出栈），当然这两个指令都是以字为单位进行的。我们看一个简单的例子：</p><p><img src="2.jpg" alt="PUSH与POP"></p><p>注意栈是由高位空间向低位空间延伸的，所以两个相邻的内存单元，一个字的高八位要放在下面，低八位放在上面。</p><h2 id="SS与SP"><a href="#SS与SP" class="headerlink" title="SS与SP"></a>SS与SP</h2><p>看了上面的例子，我们对于PUSH与POP有了一定的了解，但这同时也引出了一个问题，既然栈需要从栈顶存入或者取出数据，那CPU怎么知道栈顶的位置呢？CPU又怎么能知道哪里才是栈呢？<del>我都不知道！</del>咳咳，这就要提到我们的段寄存器SS啦！当然也不能忘了SS的搭档SP。SS中存储的是栈顶元素的段地址，SP中存储的是栈顶元素的偏移地址。现在我们就可以知道PUSH与POP具体做了什么了。</p><p>例如PUSH AX（Tips:栈由高位空间向低位空间增长）：</p><ol><li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li><li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新的栈顶</li></ol><p><img src="3.jpg" alt="PUSH执行过程"></p><p>POP AX就和PUSH恰恰相反啦（Tips:栈由高位空间向低位空间增长）：</p><ol><li>将SS:SP指向的内存单元处的数据送入寄存器AX中</li><li>SP=SP+2,SS:SP指向当前栈顶下面的单元，以当前栈顶的下一个单元为新的栈顶</li></ol><p><img src="4.jpg" alt="POP执行过程"></p><p>注意！！这里POP执行后并不是将数据销毁，数据实际还在，只不过栈顶元素的位置发生了改变，数据不在栈里面了。当下一次执行PUSH等入栈指令时，将重新写入一个新的数据，将旧的数据覆盖掉（也就是2266H将被覆盖。）</p><h2 id="栈顶超界的问题"><a href="#栈顶超界的问题" class="headerlink" title="栈顶超界的问题"></a>栈顶超界的问题</h2><p>相信学习过数据结构，有过手撸栈经历的小伙伴对这个问题并不陌生，是的，SS和SP只记录了栈顶元素的段地址和偏移地址，只有这样无法确保我们对栈的操作不会出现栈顶超界的问题，我们自行设计栈时通常会采用计数等方法保证栈顶不会超界，但遗憾的是8086CPU并没有这样的设计，这就要求我们在使用栈之前，根据可能用到的最大栈空间安排栈的大小，执行出栈时也要注意栈是否已空。</p><h2 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h2><p>我们之前学习过，我们在编程的过程中可以使用一个起始地址是16倍数的，长度为N（N≤64KB）的内存单元作为栈使用。那么问题来啦：</p><p>如果将10000H~1FFFFH作为栈段，初始情况下栈是空的，此时，SS=1000H，SP=?</p><p>可能有的小伙伴会想SS:SP指向栈顶元素当栈顶元素出栈就是空的，所以SP就是FFFF+2也就是0001H嘛（应该不止我一个人会这样叭。。）栈操作都是以字为单位操作的，当栈中含有一个数据时，SS:SP应该指向的是1FFFEH，所以其实SP=FFFE+2=0000H。也可以简记为栈底加一才是真正的栈底。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（二）</title>
    <link href="http://example.com/2022/08/10/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2022/08/10/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-08-10T08:53:09.000Z</published>
    <updated>2022-08-30T12:19:41.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li></ol><p>话不多说我们马上开始。</p><h1 id="CPU内部组成"><a href="#CPU内部组成" class="headerlink" title="CPU内部组成"></a>CPU内部组成</h1><p>通常一个CPU由运算器、控制器、寄存器等器件所组成，这些器件在CPU中中过内部的总线相互连接。</p><p><img src="1.jpg" alt="CPU内部结构及CPU与内存交互"></p><p>其中运算器进行信息处理，寄存器进行信息存储，控制器控制各种器件进行工作，内部总线将它们相互连接，在它们之间进行数据的传递。</p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>对于我们学习汇编来讲，CPU中最为主要的部件是寄存器，寄存器是CPU中程序员可以进行读写操作的部件。程序员通过改变寄存器的内容来实现对CPU的控制。</p><p>不同的CPU，寄存器的个数、结构不同。8086CPU有14个寄存器，每一个寄存器都有自己的名字：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>在8086CPU中所有寄存器都是16位的。其中AX、BX、CX、DX这四个寄存器通常存储一些一般性的数据，被称为通用寄存器。</p><p><img src="2.jpg" alt="寄存器AX"></p><p>为了兼容上一代8位CPU，这些通用寄存器可以被分为两个8位寄存器例如AX可以分成AH和AL分别对应寄存器AX的高八位和低八位，同理BX也可以分为BH和BL。</p><p>出于对于兼容性的考虑，8086CPU可以对字节（1B）和字（2B）这两种尺寸的数据进行处理。</p><h1 id="mov指令与add指令"><a href="#mov指令与add指令" class="headerlink" title="mov指令与add指令"></a>mov指令与add指令</h1><p>好啦，接下来我们正式的学习两条汇编指令：mov和add</p><p>首先，mov指令，mov指令又被叫做传送指令，大部分寄存器的值都可以被mov指令改变，我们使用高级语言的语法来描述这件事情以加强理解（在写一条汇编指令或者寄存器名称时不区分大小写）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,18 &lt;=&gt; ax=18</span><br></pre></td></tr></table></figure><p>怎么样是不是很直观？没错mov指令的作用和赋值相似，该mov指令控制CPU将18这个数据送入到了寄存器AX中。当然了这里要注意的是在汇编源程序中，数据是不能以字母开头的，也就是说A000H这样的数据是不允许出现在汇编源程序的，要在前面加上一个0才可以，也就是0A000H可以使用。</p><p>其次，add指令（在写一条汇编指令或者寄存器名称时不区分大小写）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add ax,8 &lt;=&gt; AX=AX+8</span><br></pre></td></tr></table></figure><p>add指令的作用就相当于加上一个数字并且赋值给add指令后的寄存器，该add指令控制CPU将8这个数据与原先AX中的数据相加后赋值给AX。</p><p>举一个简单的例子加强对于两个指令的理解：</p><table><thead><tr><th>程序段中的指令</th><th>指令执行后AX中的数据</th><th>指令执行后BX中的数据</th></tr></thead><tbody><tr><td>mov ax,4E20H</td><td>4E20H</td><td>0000H</td></tr><tr><td>add ax,1406H</td><td>6226H</td><td>0000H</td></tr><tr><td>mov bx,2000H</td><td>6226H</td><td>2000H</td></tr><tr><td>add ax,bx</td><td>8226H</td><td>2000H</td></tr></tbody></table><p>在add指令的使用过程中要注意位数的问题：</p><p>现有AL中存储数据C5H此时使用 add AL,93H ，那么执行后AX中的数据是多少？答案是0058H，因为AL是一个8位寄存器，在add指令执行后，得到结果值为158H，这超过了8位的存储大小，所以最高位的“1”被无情“抛弃”（实际上并不是真正的抛弃掉了，只是表示这个”1“装不下了，至于如何处理我们后续再聊）。而且AL和AH都是被当做一个独立的寄存器所使用的，这个“1”并不会储存在AH中。</p><p>相应的如果AX中存储数据C5H此时使用 add AX,93H ，那么结果又会如何呢？答案是0158H，因为AX是一个16位寄存器，在add指令执行后，得到结果值为158H，不超过16位的存储大小，所以0158H完整的被存放在了寄存器AX之中。</p><p>由此可知，在进行add指令的使用，要注意此次运算到底是几位运算。</p><h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p>我们知道CPU访问内存单元需要提供出访问的内存单元的地址，每一个内存单元都有一个唯一的地址，我们称这个唯一的地址就叫做物理地址。CPU必须现在内部形成这个物理地址，才可以通过地址总线传出，访问特定的内存单元。每一种不同的CPU都有这不一样的方式生成物理地址，下面我们讨论8086CPU如何在内部生成该物理地址。</p><h1 id="8086CPU生成物理地址的方法"><a href="#8086CPU生成物理地址的方法" class="headerlink" title="8086CPU生成物理地址的方法"></a>8086CPU生成物理地址的方法</h1><p>首先我们要知道8086CPU是一个16位结构的CPU，它具有以下特点：</p><ul><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器的通路为16位</li></ul><p>这就意味着8086CPU一次性能够处理、传输、暂存的信息最大长度是16位。</p><p>8086CPU外部有20位地址总线，寻址能力达到了1MB。但因为8086CPU的16位结构导致其表现出来的寻址能力只有64KB为了解决这个问题，8086CPU采用了使用两个16位地址组成一个20位地址。</p><p>当8086CPU进行读写内存操作时8086CPU的相关部件提供两个16位的地址，一个叫做段地址，一个叫做偏移地址。两个地址被送入一个叫地址加法器的部件中合成一个20位地址。</p><p>看到这里我猜你可能有一个疑惑，怎么就两个16位地址变成了一个20位地址呢？</p><p>其实啊，地址加法器有一个独门的公式：物理地址=段地址×16+偏移地址，这样就由两个16位地址变成了一个20位地址。为什么一定是乘16嘞？因为段地址和偏移地址都是一个十六进制数字，通过乘16的方式使段地址整体左移一位。（就像是二进制中 “10”× 2就变成了100）</p><p>假如8086CPU要访问123C8H这个地址，那么整体过程就是：</p><ol><li>相关部件提供段地址 1230H 和偏移地址 00C8H 并送入了地址加法器</li><li>地址加法器通过公式：物理地址=段地址×16+偏移地址 得到物理地址=1230H×16+00C8H=123C8H</li><li>地址加法器把物理地址传输给输入输出控制电路</li><li>输入输出控制电路通过地址总线将物理地址传输给内存</li></ol><p>这样8086CPU就实现了对于内存的访问。</p><h1 id="对于段的理解"><a href="#对于段的理解" class="headerlink" title="对于段的理解"></a>对于段的理解</h1><p>上述提到了段地址的概念，可能让大家理解成内存本身就是一个分段一样的存在，但实则不然，只是CPU操作内存时候采用了分段的方法进行管理。在实际的汇编编程过程中我们可以根据实际需要进行分段处理，由于公式：物理地址=段地址×16+偏移地址 可知一个内存段的起始地址（即段地址×16）必然为16的倍数，因为偏移地址的长度为16位，寻址能力为64KB，所以一个段的长度最大为64KB。</p><h1 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h1><p>上面我们提到CPU内相关组件会提供段地址和偏移地址给地址加法器，那么到底是什么部件提供的呢？那就是段寄存器所提供的，8086CPU中含有4个段寄存器：CS、DS、SS、ES。这里我们先聊聊CS，后续我们在继续讨论其余段寄存器。</p><h2 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h2><p>CS和IP是8086CPU中最为关键的两个寄存器，它们指明了CPU现在要读取指令的地址。CS叫做代码段寄存器，IP叫做指令指针寄存器。假设任意时刻CS中数据为M，IP中数据为N，那么8086CPU就会从内存地址为 M×16+N 的内存单元中读取一条指令并且执行。执行指令之后IP会根据指令的字节数自增。（tips：这里要注意M和N只是段地址和偏移地址的一个实例，不只是CS和IP会提供段地址和偏移地址。）</p><p>假如8086CPU要执行 mov ax,0123H （长度为3B，在地址20000H处）这个指令 那么整体过程就是：</p><ol><li>CS提供段地址2000H，IP提供偏移地址0000H给地址加法器</li><li>地址加法器通过公式：物理地址=段地址×16+偏移地址 得到物理地址=2000H×16+0000H=20000H</li><li>地址加法器把物理地址传输给输入输出控制电路</li><li>输入输出控制电路通过地址总线将物理地址传输给内存</li><li>内存通过数据总线返回给CPU指令 mov ax,0123H</li><li>输入输出控制电路将指令 mov ax,0123H 放入指令缓冲器中</li><li>IP读取到指令长度为3B 自增 3 变为 0003H</li><li>指令执行</li><li>读取下一条指令</li></ol><p>这样8086CPU就读取并且执行了一条汇编指令。</p><p>不知道大家有没有过一个疑问，计算机里面全都是二进制代码，那计算机怎么区分那些二进制代码要当成数据看待，那些二进制代码要当成指令看待呢？学习玩CS IP之后我们可以说会被CS:IP指向的内容就是指令。</p><h1 id="修改CS-IP-数据-JMP指令"><a href="#修改CS-IP-数据-JMP指令" class="headerlink" title="修改CS IP 数据 JMP指令"></a>修改CS IP 数据 JMP指令</h1><p>学习了这样一个底层的语言，我们有权利修改寄存器中的数据，我们可以通过修改CS和IP中的数据来让计算机执行我们希望它去执行的指令。这个时候，有些朋友可能已经开始回想，我们之前学习过mov指令，可以用来修改寄存器中的数据，我们故技重施，直接使用mov去修改CS和IP的数据。但事实上这样是不被允许的，为什么嘞？其实答案很简单，因为8086CPU它。。。它做不到呀！！没这个功能。但不用担心，车到山前必有路，我们有可以改变CS IP的指令叫做转移指令（晚一些我们还会深入研究），这里我们介绍一个简单的转移指令：jmp指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果想同时修改CS IP的值可以用 jmp 段地址:偏移地址 来完成</span><br><span class="line">例如：</span><br><span class="line">jmp 2AE3:3 执行后 CS=2AE3H IP=0003H CPU会从2AE33H处读取指令</span><br><span class="line">当你只想修改IP中的值可以用 jmp 某一合法寄存器 来完成</span><br><span class="line">例如：</span><br><span class="line">AX=1000H,CS=2000H,IP=0003H</span><br><span class="line">jmp ax 执行后 AX=1000H,CS=2000H,IP=1000H CPU会从21000H处读取指令</span><br></pre></td></tr></table></figure><h1 id="Debug调试指令"><a href="#Debug调试指令" class="headerlink" title="Debug调试指令"></a>Debug调试指令</h1><p>学会了这些指令，没地方用怎么能行，取我DOSBOX来，先输入debug，出现一个短杠后就可以使用调试指令啦，接下来就教大家如何使用debug：</p><p>1.R命令：查看、改变CPU寄存器的内容</p><p><img src="3.jpg" alt="R命令"></p><p>改变寄存器内容只需要在r后面加上寄存器名称即可。</p><p>2.D命令：查看内存中的内容</p><p><img src="4.jpg" alt="D命令"></p><p>D命令默认根据DS寄存器内容显示，每次显示128个字节的数据，想显示指定位置数据，只需要在D命令后加上 段地址：偏移地址。</p><p>3.E命令：改写内存内容</p><p><img src="5.jpg" alt="E命令"></p><p>E命令后加上 段地址：偏移地址 即可从指定物理地址后改写内存内容，如果遇到不想改写的内容空格跳过，enter结束。</p><p>4.U命令：将内存中的机器指令翻译成汇编指令</p><p><img src="6.jpg" alt="U命令"></p><p>U命令将CS:IP指向的机器指令翻译成汇编指令。</p><p>5.T命令：执行一条机械指令</p><p><img src="7.jpg" alt="T命令"></p><p>T命令执行一条当前CS:IP所指的汇编指令。</p><p>6.A命令：以汇编语言的格式向内存中写入一条机器指令</p><p><img src="8.jpg" alt="A命令"></p><p>A命令后加 段地址：偏移地址 可以在指定物理地址位置用汇编语言写入一条机器指令。</p><p>学会了这些命令，你就可以使用DOSBOX来验证所学内容啦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
</feed>
