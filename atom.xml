<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuzheng&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-30T13:49:33.763Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>liu zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从0开始的汇编语言（六）</title>
    <link href="http://example.com/2022/08/29/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://example.com/2022/08/29/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AD%EF%BC%89/</id>
    <published>2022-08-29T15:18:59.000Z</published>
    <updated>2022-08-30T13:49:33.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li></ol><p>话不多说我们马上开始。</p><h1 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h1><p>在学习这一章之前，我们也写了不少程序了，但这些程序都是只使用了一个段的，就好像一个程序只有Main函数。这种写程序的手法是很低端的，一点都不符合我们高端程序员的身份，更何况万一我的程序需要其他地方放数据怎么办？在上一篇中，我们讲到了要使用一段安全的空间，但是那段空间只有256个字节大小，万一我们需要的空间大于256个字节怎么办？其实在操作系统的管控下，程序可以取得任意容量的内存，操作系统会为我们安排好。</p><p>程序获取空间的手段有两种，一种是在加载程序时为程序分配好，另一种是在程序执行的过程中向系统申请。第二种就是我们在高级语言中使用的malloc或者new函数等等，这里不多讨论。我们之前在源程序中定义段来进行内存空间的获取，这就是我们为了程序加载过程中得到所需空间做的准备。</p><p>大多数有用的程序，都要处理数据，使用栈等等操作，为了设计上看起来清晰，我们也会定义很多段来做不同的事情，就像是我们会写很多函数而不是把代码全都堆放在Main中。我们慢慢的去体验由一个段的程序到多个段的程序这个过程。</p><h1 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h1><p>试想这样一个问题，现在我们有这样8个数据，分别是0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H。我们要做这样一件事情将他们累加起来放在AX中。之前我们也做过类似的事情，只不过那个时候我们还没有要求将特定的数据累加起来。自从学会loop指令后，总是想用一下看看，没错这次的问题是使用loop指令来完成，但这就代表着我们在累加前，要想办法把这8个数据存放在一组地址连续的内存单元中，就像是我们在高级语言中会做的那样，把他们放在数组中。但问题是我们要上那找到再这样一组内存单元呢？我们不能自己随便找一段内存单元就把它们丢进去了，这样太不负责任了，我们应该告诉系统我们需要一个地方来放这些数据，由系统分配给我们。那具体我们要怎么做呢？来看看代码叭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>首先，解释一下什么是“dw”，dw即“define word”翻译过来就是定义字型数据，在这里dw定义了8个字型数据，大小16个字节，那么这些数据存在哪里了呢？数据既然是跟着代码一起被加载到内存中的，那肯定是在代码段中啦，因为dw定义数据的位置在整个代码段的最上面，所以这8个数据的偏移地址就是0,2,4,6,8,A,C,E。所以在循环中bx每次加2来累加这8个字型数据。</p><p>在编写完成程序以后我们编译、连接，等等先别急，我们用debug追踪一下看看，debug使用U指令！</p><p><img src="1.jpg" alt="debug使用U指令！"></p><p>啊！什么？这是什么？！这不是我的代码啊！哎别急别急，你仔细看看这些汇编指令对应的机械码，是不是看起来很眼熟，没错这16个字节对应的就是程序所定义的字型数据，它们也是程序的一部分。我们跳过这个部分，从0B3D:0010后面看。</p><p><img src="2.jpg" alt="其实在这里呐"></p><p>所以我们想要正确的运行程序就要手动的使用r指令将寄存器IP改为10H。但我们的程序要怎么直接运行呢？总不能让所有人都会使用debug，都手动更改IP吧！当然不需要这样我们只需要对源程序进行小小的改动就可以解决这个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H</span><br><span class="line">start:mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>注意啦！我们在程序的第一条指令前面加了一个标号，并且在伪指令end后面也加上了同名标号。这里我们就要再一次的讨论end的作用啦，end除了可通知编译器程序到此结束外，还可以通知编译器程序到底从哪里进入。正如修改后的代码所做，伪指令end告诉编译器这个程序要从start后面开始，”mov bx,0“才是第一条指令。</p><p>我们之前说过，一个程序运行首先由一个其他程序装载到内存中将CPU的控制权递交给程序，根据第一条指令的段地址和偏移地址来设置寄存器CS和寄存器IP，最后程序运行完将CPU的控制权归还。可问题是，怎么才能知道那一条才是程序的第一条指令呢？我们知道一个可执行文件由描述信息和程序组成，程序就是我们写的代码，描述信息就是处理伪指令后得到的信息，我们在上面在这个程序中使用end告知编译器程序的起始位置与程序的结束位置，在编译后end start就变成了入口地址，储存在描述信息中，所以可以知道程序第一条指令的位置。所以我们若要CPU从何处开始执行程序，只要使用”end 标号“指明就好。</p><h1 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h1><p>我们再来思考这样的问题还是上述8个数据：0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H。现在我们希望将它们逆序存放，我们要怎么做呢？我们来慢慢想，想要逆序一组数据，使用栈是一个非常好的选择，只需要将所有数据入栈，再出栈就可以实现逆序了，那么我们就需要一段可以用来当做栈的内存空间，同样我们不可以自己取用，要通过程序来得到这个空间。来看看代码叭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">code segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">start: movax,cs</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,30H</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>注意啦我们定义了16个字型数据，并将它们所占用的32个字节大小的空间作为栈使用，也就是说我们打算使用CS:10~CS:2F这段内存空间作为栈使用，初始情况下栈为空SS:SP要指向栈底，所以我们设置寄存器SP内容为30H。这样我们就的到了32个字节大小的栈。我们描述dw的作用时，可以说它定义了数据，同时也可以说它开辟了空间，看程序员具体希望得到的东西到底是空间还是数据。</p><h1 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h1><p>我们已经知道怎么把数据、代码、栈放入一个段中啦！但这样做会有两个问题，一是这样写整个程序会很乱，二是一个段的大小不可以超过64KB（这是8086模式的限制，不是所有处理器都这样）。所以我们应该考虑怎么把这些东西放到不同的段里面。其实很简单我们只需要定义多个段然后放进去不就好了嘛（额好废的废话。。），我们量来看具体代码叭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: movax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20H</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>怎么样是不是真的很简单！下面我们对程序仔细的说明一下：</p><h2 id="定义多个段的方法"><a href="#定义多个段的方法" class="headerlink" title="定义多个段的方法"></a>定义多个段的方法</h2><p>很简单，我们从程序中就可以看出，定义一个段的方法和前面所讲的定义代码段的方法一样，只不过不同的段，我们要命不同的名。</p><h2 id="对段地址与偏移地址的取用"><a href="#对段地址与偏移地址的取用" class="headerlink" title="对段地址与偏移地址的取用"></a>对段地址与偏移地址的取用</h2><p>现在程序里面有多个段了，我们访问数据就需要知道这些数据的地址，可是我们如何知道这些数据的地址呢？首先，在程序中段名就相当于一个标号，它就代表了段地址，比如data就代表了数据段的段地址，stack就代表了栈段的段地址。其次偏移地址，这些数据在自己的段中偏移地址都是从0开始的，就类似一个数组，数组名代表数组的起始位置，其中的数据的偏移地址就是自己的标号（当然数组的偏移地址不会是简单的0,1,2·····还要根据数组类型计算）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学习到这里，我们已经掌握了很多汇编知识了，所以在这里写一个总结（其实是有个事情我不知道写在哪里好随便插在总结里叭），汇编语言的学习是为了让我们深刻的理解计算机硬件，对于计算机的运作有深刻的认知，但要记住汇编语言也是人类创造出来方便人类的语言，它并不是计算机的母语，汇编语言最后还是会转变为二进制代码，变成高电平，低电平来工作的，所以我们写下的代码不代表CPU会根据我们的认知来运作，不是说我们定义一个栈CPU就会承认它是个段，SS:SP才决定了哪里是栈段，其余的也是如此。最后，汇编语言的旅程才刚刚开始，加油叭！少年！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（五）</title>
    <link href="http://example.com/2022/08/24/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://example.com/2022/08/24/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%94%EF%BC%89/</id>
    <published>2022-08-23T16:52:41.000Z</published>
    <updated>2022-08-30T12:12:42.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li></ol><p>话不多说我们马上开始。</p><h1 id="对前言更新的解释"><a href="#对前言更新的解释" class="headerlink" title="对前言更新的解释"></a>对前言更新的解释</h1><p>相信小伙伴们都发现了，我们的老伙伴前言终于更新啦！！这次更新了两条第一条是使用()，第二条是idata，我们一一说明。</p><p>首先是(地址或寄存器名称)，为了描述上的简洁以后我们就都用(地址或寄存器名称)来表示一个内存单元或者寄存器中的内容啦。比如(ax)就代表寄存器ax中的内容，(20000H)代表20000H处内存单元中存放的内容。至于()所得到的内容到底是字型数据还是字节型数据要根据具体的运算决定，()中可以出现三种元素：</p><ol><li>寄存器名</li><li>段寄存器名</li><li>地址（注意这里的地址是且必须是一个物理地址）</li></ol><p>所以(AX)、(DS)、(AL)、(20000H)、((ds)×16+(bx))都是正确的使用方式，但(2000:0)这样是不被允许的。学会了这个我们举一个应用的实际例子，对于PUSH AX的过程我们可以这样描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(SP)=(SP)-2</span><br><span class="line">((SS)×16+(SP))=(AX)</span><br></pre></td></tr></table></figure><p>其次是idata，这个很简单，“[0]”偏移地址过去用此类形式表示，我们使用idata代替0,1,2,3这样的常量。</p><p>(Tips:寄存器DS不可以直接使用mov指令对其赋值。)</p><h1 id="BX-与内存单元的描述"><a href="#BX-与内存单元的描述" class="headerlink" title="[BX]与内存单元的描述"></a>[BX]与内存单元的描述</h1><p>相信看到”[]”有的小伙伴已经展开回忆了，我们先来复习一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[0]</span><br><span class="line">MOV AL,[0]</span><br></pre></td></tr></table></figure><p>这就是[]最基本的使用方法了，CPU在执行这两条指令的时候从寄存器DS中取出段地址，在[]中取出偏移地址，组成物理地址后再进行其他的处理。这两条指令分别完成了这样两件事：</p><p>第一条指令将一个长度为2的内存单元中的内容放在了寄存器AX中。</p><p>第二条指令将一个长度为1的内存单元中的内容放在了寄存器AL中。</p><p>注意这其中的不同点，对于不同大小的寄存器，CPU送入的数据大小也不相同。是的，我们在完整的描述一个内存单元需要两种信息：</p><ol><li>内存单元的地址</li><li>内存单元的大小</li></ol><p>其中内存单元的地址会由寄存器DS与[address]指明，内存单元的大小会由具体的操作对象指出。[BX]也是指出偏移地址的作用，只不过[BX]的意思是偏移地址在寄存器BX中。</p><h1 id="试着用用-BX"><a href="#试着用用-BX" class="headerlink" title="试着用用[BX]"></a>试着用用[BX]</h1><p>这里我们通过一段代码理解[BX]。(Tips:inc指令代表自增1)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000H  </span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,[bx]</span><br><span class="line">inc bx</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],ax</span><br><span class="line">inc bx</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],ax</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],al</span><br></pre></td></tr></table></figure><p>其中0地址字单元内容为00BEH，2100:2-2100:7为空，试着写出程序运行完后的21000H-21007H单元中的内容。</p><p>答案：</p><p>21000H~21006H BE 00 BE 00 BE BE BE  21007H为空。</p><p>看完这段代码相信你也学到了一招，可以使用[BX]与inc指令实现偏移地址的改变。</p><h1 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h1><p>loop n. 循环。相信学习过C，JAVA等高级语言的小伙伴对循环一定不陌生，循环为我们简化代码做出了极大地贡献，在汇编语言中也是如此。先给大家剧个透loop指令有点像do····while。先来看一段使用loop指令的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line">code segment</span><br><span class="line">mov ax,2</span><br><span class="line">mov cx,11</span><br><span class="line">s:add ax,ax</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>可能有的小伙伴已经可以猜的八九不离十了，没错这段代码计算了2的12次幂。</p><p>我们来根据这段代码讲述一下loop指令到底怎么工作的，当程序运行至loop时，首先做了(cx)=(cx)-1，然后判断cx中的值，不为0则跳转标号(也就是程序中的S)处执行，若为0则结束loop指令继续向下执行。标号S在程序运行阶段会变成一个地址，loop指令在判断CX的值不为0后，loop s(地址)将寄存器IP设置为S。了解了loop的工作机理后，我们发现寄存器CX的值会影响loop指令的执行结果，是的，通常我们用loop指令实现循环，会用寄存器CX存放循环次数，当然这也不是绝对的，不同场合，我们会有不同的处理方式。注意哦！loop指令不会跳过内部的程序段，它一定是先执行一次在去执行loop指令，这点和do····while很像。</p><h1 id="Debug和MASM对指令的不同处理"><a href="#Debug和MASM对指令的不同处理" class="headerlink" title="Debug和MASM对指令的不同处理"></a>Debug和MASM对指令的不同处理</h1><p>这里的内容是为了下面的学习顺利进行所提供的预备知识。</p><p>还记得吗？我们在Debug中写过这样的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure><p>这条指令表示将DS:0处的数据送入AX中，但是在汇编源程序中，MASM会把它看做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br></pre></td></tr></table></figure><p>OMG!这可不好，这完全是两种意思。那我们要在源程序中将内存单元的内容送入寄存器中怎么办呢？有两种解决办法：</p><p>1.使用[BX]</p><p>先将段地址送入DS中，再将偏移地址送入BX，使用MOV AL,[BX]就可以将((DS)×16+(BX))中的内容送入AL中啦。(Tips:寄存器DS不可以直接使用mov指令对其赋值。)</p><p>2.在偏移地址前显示指出段地址</p><p>这个方法就比较简单了，我们将段地址送入DS后，只需要使用DS，在偏移地址前显示的指明段地址如MOV AL,DS:[0]这样就可以将((DS)×16+(0))中的内容送入AL里啦。</p><h1 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h1><p>上面我们讲到了两种方法用来解决MASM操作内存单元的问题，其中第二种方法使用了段寄存器显示指明段地址的方式，当然了这个段寄存器不止可以是DS还可以是CS、SS、ES这都可以用来指明内存单元的段地址，CS：、SS：、ES：、DS：在汇编语言中被称作段前缀。</p><h1 id="一段安全的空间"><a href="#一段安全的空间" class="headerlink" title="一段安全的空间"></a>一段安全的空间</h1><p>还记得吗？我们最最开始讲到过的内存地址空间，我们抽象了各个硬件的内存将他们汇总为一个整体叫做内存地址空间，其中有一部分存放着一些重要的系统数据和代码，这就意味着随意的修改一个地址中的内容是十分危险的。比如修改0:26H处内容，这将导致你的DOSBOX卡死，这是因为0:26H处放着重要的系统数据。可见，我们不可以在不能确定一段内存空间是否存放重要的数据或代码时，随意的向其中写入内容，我们要使用操作系统分配给我们的内存空间，下一章我们会对这一空间有所认识。</p><p>因为运行在CPU实模式下的DOS无法对硬件进行严格的管理，所以我们可以真正的去尝试、理解、体会硬件的工作，诸如Windows、Unix这些运行在CPU保护模式下的操作系统中，想要使用汇编语言去操作硬件这是不可能的。而且我们使用DOXBOX也不需要为这些危险行为买单，所以不要害怕这些危险操作。</p><p>虽然我们不需要为危险行为买单，但在学习过程中，因为不小心修改了某个关键的系统数据就要从头来过还是非常痛苦的事情，所以我们要找到一段安全的空间供我们使用。一般来讲0:200~0:2ff这256个字节空间就是非常好的选择。至于为什么一定是这里安全，我们以后会再讨论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（四）</title>
    <link href="http://example.com/2022/08/22/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://example.com/2022/08/22/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2022-08-22T11:50:17.000Z</published>
    <updated>2022-08-30T12:42:28.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li></ol><p>话不多说我们马上开始。</p><h1 id="一个源程序的诞生"><a href="#一个源程序的诞生" class="headerlink" title="一个源程序的诞生"></a>一个源程序的诞生</h1><p>oh！这是什么意思？一个源程序的诞生！没错，学到这里我们终于开始写我们的第一个完整的汇编语言程序了，用编译和连接程序将它们变成.exe文件。但在这之前我们还是先看看一个程序怎么诞生的吧。</p><p><img src="1.jpg" alt="一个源程序的诞生"></p><p>第一步，程序员打开了文本编辑器（Edit，记事本等）写下了一行一行汇编指令。这一步生成了一个储存源程序的文本文件。</p><p>第二步，使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，这样就生成了可以在操作系统中直接运行的可执行文件。</p><p>Tips：可执行文件包括两部分：</p><ul><li>程序（从源程序的汇编指令翻译过来的机器码）与数据（源程序定义的数据）</li><li>相关描述信息（比如，程序有多大，要占用多少内存空间等）</li></ul><p>这一步生成了一个可以在操作系统中直接运行的可执行文件。</p><p>第三步，执行可执行文件中的程序，操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如设置CS:IP指向第一条要执行的指令），由CPU执行程序。</p><h1 id="源程序什么样子嘞？"><a href="#源程序什么样子嘞？" class="headerlink" title="源程序什么样子嘞？"></a>源程序什么样子嘞？</h1><p><del>恭喜恭喜，是个男孩。</del> 我们来看下面这段源程序，认识一下它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,bx</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应机器码的指令，可以被编译为机器指令，最终由CPU所执行。而伪指令没有对应的机器码，不会被CPU执行，那谁来执行呢？伪指令是由编译器来执行的，根据伪指令进行相关的编译工作。</p><h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>在程序中一共出现了三种伪指令:</p><p>1.XXX segment ······· XXX ends</p><p>segment和ends是一对成对使用的伪指令，其作用是定义一个段，这两个指令是必不可少的，XXX代表段名。例如程序中codesg segment代表段codesg由此开始，codesg ends代表段codesg到此结束。一个汇编程序会有多个段用于存放指令，数据，或者被当做栈使用一个有意义的汇编程序至少有一个段，用来存放代码</p><p>2.end</p><p>注意啦！这里说的可不是上面所提到的ends，这是完全不同的！end代表了一个汇编程序的结束，编译器在编译一个汇编程序时遇到了end就会停止编译，所以在编写结束时，一定要记得写end。</p><p>3.assume</p><p>assume v.  假设。这条指令假设某一段寄存器和程序中的某一个用segment ······· ends定义的段相关联。通过assume说明这种关联，也就是assume将有特殊用途的段和相关的段寄存器关联起来了。比如在程序中我们定义了一个叫做codesg的段，这个段用来存放代码的，也就是一个代码段。那CPU中和代码有关的寄存器就是段寄存器CS，所以用assume将codesg和CS联系起来了。</p><h2 id="源程序中的“程序”"><a href="#源程序中的“程序”" class="headerlink" title="源程序中的“程序”"></a>源程序中的“程序”</h2><p>我们编程的最终目的是为了让计算机完成一定的任务。源程序中的伪指令由编译器来处理，这并不能实现我们编程的最终目的。我们所说的程序实际上是源程序中由计算机执行处理的指令或者数据。程序最开始以汇编指令的形式存在源程序中，经过编译、连接后变为机器码，存储在可执行文件中。</p><p><img src="2.jpg" alt="程序经编译连接后变为机器码"></p><h2 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h2><p>汇编程序中，除了汇编指令和伪指令外，还有一些标号，比如“codesg”。一个标号指代一个地址。比如codesg在segment前面作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p><h1 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h1><p>了解了一个汇编程序由什么组成后我们可以照着案例写出一个新的汇编程序，计算2的3次幂：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>看起来很完美，和案例一样完美？这些汇编指令现在已经存在源程序中了，经过编译、连接后变为机器码，存储在可执行文件中，但它要怎么才可以运行起来呢？</p><p>下面我们在DOS的基础上，简单的讨论一下这个问题。一个程序我们叫它P2在可执行文件中，则必须有一个正在运行的程序P1,将P2从可执行文件中载入内存后，将CPU的控制权交给P2，P2才可以开始运行，P1这时停止运行。等P2运行结束后，再把CPU控制权交还给P1，之后P1才会继续进行。感觉起来就像是我们写一个C++或者JAVA程序时要有一个main函数，程序由此开始，将CPU的控制权交给所调用的函数，等函数执行完在把CPU控制权交还给main函数。</p><p>现在我们知道了一个程序结束后，应该将CPU控制权交还给使它运行的程序，这个过程就叫做程序返回。但话又说回来，程序返回到底是怎么样返回的呢？我们要做什么呢？</p><p>我们回头看案例的汇编程序其中有这样两行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure><p>这两条指令就实现了程序返回。我们暂时不深究这两行代码的具体意义，只要知道这两行代码可以完成程序返回即可。</p><p>所以，我们写的程序还是有一点点的瑕疵，我们重新修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这样我们就得到了一个真的很完美的汇编程序。</p><h1 id="实现一个汇编程序！！"><a href="#实现一个汇编程序！！" class="headerlink" title="实现一个汇编程序！！"></a>实现一个汇编程序！！</h1><p>现在我们要动手写一个汇编程序啦！！！</p><h2 id="编辑源程序"><a href="#编辑源程序" class="headerlink" title="编辑源程序"></a>编辑源程序</h2><p>1.这里我们使用DOSBOX下edit</p><p><img src="3.jpg" alt="打开DOSBOX下的edit"></p><p>2.在edit界面下编写如下程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="4.jpg" alt="编写一个汇编程序"></p><p>3.保存这个汇编程序，点击File-Save，修改文件名称（File Name）为1.ASM 点击OK</p><p><img src="5.jpg" alt="保存汇编程序"></p><p>保存好的汇编程序在MASM文件夹下，忘记MASM的小伙伴可以回到<a href="https://liuzhengblog.com/2022/08/09/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89/">从0开始的汇编语言（一）</a>搭建汇编语言环境部分复习一下。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>现在我们有了源文件程序，我们要开始对它进行编译得到包含机器代码的目标文件。在编译一个源程序之前我们要先找到一个相应的编译器，恰好我们在搭建汇编语言环境时下载的命令文件中就有微软的MASM5.0汇编编译器。所以我们可以直接开始对源文件程序编译啦，以1.ASM为例。</p><p>1.打开DOSBOX输入MASM</p><p><img src="6.jpg" alt="打开MASM编译器"></p><p>2.输入保存的源程序文件1.ASM</p><p><img src="7.jpg" alt="编译源程序文件"></p><p>这里有几点要说明，首先，如果我们需要编译的文件扩展名不是ASM，比如是p1.txt那我们就要输入p1.txt全名称才可以。其次，Source filename输入的文件如果和MASM.exe在一个文件夹(MASM文件夹)下那么就可以省略路径，否则需要指定文件的路径。比如我们所需要编译的文件是在c:\windows\desktop下的p1.txt文件，那么我们就要输入c:\windows\desktop\p1.txt。最后Source filename后有[.ASM]这个代表默认的文件扩展名是ASM，如果你确实要编译一个ASM文件且文件位置与MASM.exe在一个文件夹下，那么只需要输入ASM文件名称即可。</p><p>在输入完1后会出现Object filename这个就是我们编译要得到的目标文件[1.OBJ]提示我们默认生成的目标文件名为1.OBJ如无更改可以enter跳过。之后出现的Source listing和Cross-reference生成的都是中间文件我们可以选择enter跳过，让编译器忽略生成。</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>现在我们有了目标文件1.obj，我们接下来对它进行连接，得到可执行文件。当然啦，我们也需要一个连接器，恰好我们有微软的Overlay Linker3.60连接器。事不宜迟，开始连接！</p><p>1.打开DOSBOX输入link，这里的注意事项和编译时的一样要注意路径和文件扩展名的问题。</p><p><img src="8.jpg" alt="连接目标文件1"></p><p>2.同样我们跳过剩下三个选项，这三个选项分别是生成的exe文件名称及位置，映像文件（.map），库文件(.lib)当然了，你也可以在第二个选项也就是生成exe文件那个选项中，输入你想要的路径及文件名，这样就可以在你想的位置生成执行文件啦。</p><p><img src="9.jpg" alt="连接目标文件2"></p><p>这里出现了 no stack segment （没有栈段）我们先忽略这个错误。</p><p>这样我们就得到了可执行文件1.exe只是你不能运行它，大人时代变了。</p><h2 id="简化的方式编译与连接"><a href="#简化的方式编译与连接" class="headerlink" title="简化的方式编译与连接"></a>简化的方式编译与连接</h2><p>如果你已经默认忽略中间文件生成了那你可以这样做：</p><p>编译时输入MASM 文件名（考虑路径，文件扩展名问题）；（注意结尾这个分号要加上要不然还是会询问中间文件是否生成）。</p><p>连接时输入link 文件名（考虑路径，文件扩展名问题）；（注意结尾这个分号要加上要不然还是会询问中间文件是否生成）。</p><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><p>呼！终于到这个时候啦，是不是还有点点紧张？安啦，安啦。打开DOSBOX输入1或者1.exe。</p><p><img src="10.jpg" alt="运行程序"></p><p>哎？！等会这是怎么回事，怎么没有反应！！什么都没有！！别急，别急。咱们也没写可以输出的指令，当然看不出来结果啦，我们以后会写其他可以看出结果的程序的，敬请期待。</p><h1 id="谁将程序装载到内存里并运行它呢？"><a href="#谁将程序装载到内存里并运行它呢？" class="headerlink" title="谁将程序装载到内存里并运行它呢？"></a>谁将程序装载到内存里并运行它呢？</h1><p>我们之前在程序返回部分讲到过，一个汇编程序运行需要另一个程序将该程序装载到内存之中并将CPU的控制权给该程序才可以，但我们刚才运行时候没用开另一个程序呀，那到底是谁把程序装载到内存中并且运行了呢？故事还要从操作系统的shell（外壳）讲起。</p><p>操作系统是一个由多功能模块组成的庞大的、复杂的软件系统。任何通用的操作系统都需要提供一个shell（外壳）的程序，供用户使用其操作计算机系统。听起来很玄妙，但其实我们常用的CMD，PowerShell就是Windows系统提供给我们的shell，而DOS也不例外，它为用户提供了一个叫做command.com的命令解释器，也就是DOS的Shell。DOS启动后，先进行一些重要的初始化工作，然后运行command.com，执行其他相关任务后，屏幕上显示当前盘符和路径组成的提示符。也就是我们打卡DOSBOX后的画面。这个时候command.com就已经在运行了。然后我们要运行我们的可执行文件1.exe，command就根据我们的文件名找到文件，将文件中的程序载入内存，修改CS:IP指向程序入口，此后command暂停工作，待CPU处理完1.exe，控制权交还给command。</p><p>所以真相只有一个，那就是command这个shell将程序装载到内存中并修改CS:IP指向程序入口。</p><h1 id="程序执行过程中的跟踪"><a href="#程序执行过程中的跟踪" class="headerlink" title="程序执行过程中的跟踪"></a>程序执行过程中的跟踪</h1><p>虽然我们没有办法看到程序输出在界面上，这是因为我们没有写一些输出指令。但我们写了mov指令呀，我们不能通过debug -r的方式去观察ax，bx的数值变化嘛，可以只不过我们用到的命令是debug 1.exe(可执行文件名)，这样debug就将1.exe载入了内存之中并修改了CS:IP。OH！对啦，如果你使用程序跟踪的方式运行一个程序，那就是debug程序将程序装载到内存中啦！</p><h1 id="程序去哪？"><a href="#程序去哪？" class="headerlink" title="程序去哪？"></a>程序去哪？</h1><p>现在我们知道了程序被command加载到了内存之中，可问题是程序到底加载到哪里了呢？我要从哪里才可以看到程序呢？谈到这个我们先看看一个程序如何被加载到内存中：</p><p><img src="11.jpg" alt="程序被加载到内存的过程"></p><p>由图可知，程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，这程序所在的内存区地址为ds：0，这个内存区前256个字节存放的是PSP,DOS用来和程序进行通信。从256字节往后的空间存放的就是程序。</p><p>所以从ds中可以得到PSP的段地址SA，PSP的偏移地址为0，则物理地址为SA×16+0</p><p>又因为PSP占256（100H）字节，所以程序的物理地址是：</p><p>SA×16+0+256=SA×16+16×16+0=(SA+16)×16+0</p><p>也就是段地址是SA+16，偏移地址是0。程序运行起来就会根据这两个地址分别设置寄存器CS与寄存器IP，从而进入程序。</p><p>了解完这些你就可以用debug来追踪你的程序啦但记住执行int 21H指令时要使用p指令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（三）</title>
    <link href="http://example.com/2022/08/19/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2022/08/19/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-08-19T05:00:45.000Z</published>
    <updated>2022-08-30T13:06:50.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li></ol><p>话不多说我们马上开始。</p><h1 id="字节型数据与字型数据"><a href="#字节型数据与字型数据" class="headerlink" title="字节型数据与字型数据"></a>字节型数据与字型数据</h1><p>众所周知，字节与字之间存在着一种二倍的关系，也就是说2个字节就等于1个字。由于内存单元是字节单元，也就是说一个内存单元只存储一个字节，所以计算机使用两个连续的内存单元存储一个字。计算机将这个字的第八位放在低位内存单元中，将高八位放在高位内存单元之中。我们称起始地址是N的字单元为N地址字单元。</p><h1 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h1><p>现在我们知道了计算机如何将一个字存储到内存单元之中，但是计算机又如何从内存单元之中取出一个字呢？这就要提到另一个段寄存器DS了。DS寄存器中通常存放着要访问数据的段地址。（Tips：物理地址=段地址×16+偏移地址）</p><p>例如我们想要读取10000H中的数据，我们就编写了如下的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov BX,1000H</span><br><span class="line">mov DS,BX</span><br><span class="line">mov AL,[0]</span><br></pre></td></tr></table></figure><p>这样我们就把10000H中的字节型数据存放到了AL中。</p><p>这个时候我相信肯定有的小伙伴就要发出了疑问“只有段地址没有偏移地址怎么能确定一个准确的内存单元呢？”我也相信有小伙伴已经发现了<del>华点</del>盲点。没错，DS和CS相同，也有一个搭档用来指示偏移地址，而这个搭档就是”[ address ]”。中括号中包含的地址就是偏移地址。</p><p>这里还需要注意的事是我们明明可以通过使用mov指令直接将1000H送入DS中，为什么还要大费周章先把1000H送入BX中再将BX中的数据送入DS呢？这个问题其实很简单，因为8086CPU不支持你这样做，这是一个硬件设计的问题，所以我们就记住要这样为DS提供地址。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>相信有计算机基础的小伙伴对于栈一定不陌生了，不过这里还是给各位介绍一下栈。我们举一个例子，我平时打羽毛球都会从桶中拿出第一个球，而这个球的下场只有两个，我把它打残废，我从羽毛球桶中拿出下一个球，或者它老老实实的配合我拍照，我把它放回桶中。这整个过程中，球都只从上面的开口中取出或者放入，我们没有从另一端取出在放入，这样的存取和最初生产出来的时候是相反的。所以我们给出栈的定义：栈是一种使用受限的线性表，其中数据符合后进先出（LIFO）的存取原则。</p><p><img src="1.jpg" alt="栈"></p><h1 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h1><p>现如今的CPU中都有栈的设计。8086CPU提供了出栈与入栈的指令，即PUSH（入栈）与POP（出栈），当然这两个指令都是以字为单位进行的。我们看一个简单的例子：</p><p><img src="2.jpg" alt="PUSH与POP"></p><p>注意栈是由高位空间向低位空间延伸的，所以两个相邻的内存单元，一个字的高八位要放在下面，低八位放在上面。</p><h2 id="SS与SP"><a href="#SS与SP" class="headerlink" title="SS与SP"></a>SS与SP</h2><p>看了上面的例子，我们对于PUSH与POP有了一定的了解，但这同时也引出了一个问题，既然栈需要从栈顶存入或者取出数据，那CPU怎么知道栈顶的位置呢？CPU又怎么能知道哪里才是栈呢？<del>我都不知道！</del>咳咳，这就要提到我们的段寄存器SS啦！当然也不能忘了SS的搭档SP。SS中存储的是栈顶元素的段地址，SP中存储的是栈顶元素的偏移地址。现在我们就可以知道PUSH与POP具体做了什么了。</p><p>例如PUSH AX（Tips:栈由高位空间向低位空间增长）：</p><ol><li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li><li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新的栈顶</li></ol><p><img src="3.jpg" alt="PUSH执行过程"></p><p>POP AX就和PUSH恰恰相反啦（Tips:栈由高位空间向低位空间增长）：</p><ol><li>将SS:SP指向的内存单元处的数据送入寄存器AX中</li><li>SP=SP+2,SS:SP指向当前栈顶下面的单元，以当前栈顶的下一个单元为新的栈顶</li></ol><p><img src="4.jpg" alt="POP执行过程"></p><p>注意！！这里POP执行后并不是将数据销毁，数据实际还在，只不过栈顶元素的位置发生了改变，数据不在栈里面了。当下一次执行PUSH等入栈指令时，将重新写入一个新的数据，将旧的数据覆盖掉（也就是2266H将被覆盖。）</p><h2 id="栈顶超界的问题"><a href="#栈顶超界的问题" class="headerlink" title="栈顶超界的问题"></a>栈顶超界的问题</h2><p>相信学习过数据结构，有过手撸栈经历的小伙伴对这个问题并不陌生，是的，SS和SP只记录了栈顶元素的段地址和偏移地址，只有这样无法确保我们对栈的操作不会出现栈顶超界的问题，我们自行设计栈时通常会采用计数等方法保证栈顶不会超界，但遗憾的是8086CPU并没有这样的设计，这就要求我们在使用栈之前，根据可能用到的最大栈空间安排栈的大小，执行出栈时也要注意栈是否已空。</p><h2 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h2><p>我们之前学习过，我们在编程的过程中可以使用一个起始地址是16倍数的，长度为N（N≤64KB）的内存单元作为栈使用。那么问题来啦：</p><p>如果将10000H~1FFFFH作为栈段，初始情况下栈是空的，此时，SS=1000H，SP=?</p><p>可能有的小伙伴会想SS:SP指向栈顶元素当栈顶元素出栈就是空的，所以SP就是FFFF+2也就是0001H嘛（应该不止我一个人会这样叭。。）栈操作都是以字为单位操作的，当栈中含有一个数据时，SS:SP应该指向的是1FFFEH，所以其实SP=FFFE+2=0000H。也可以简记为栈底加一才是真正的栈底。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（二）</title>
    <link href="http://example.com/2022/08/10/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2022/08/10/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-08-10T08:53:09.000Z</published>
    <updated>2022-08-30T12:19:41.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li></ol><p>话不多说我们马上开始。</p><h1 id="CPU内部组成"><a href="#CPU内部组成" class="headerlink" title="CPU内部组成"></a>CPU内部组成</h1><p>通常一个CPU由运算器、控制器、寄存器等器件所组成，这些器件在CPU中中过内部的总线相互连接。</p><p><img src="1.jpg" alt="CPU内部结构及CPU与内存交互"></p><p>其中运算器进行信息处理，寄存器进行信息存储，控制器控制各种器件进行工作，内部总线将它们相互连接，在它们之间进行数据的传递。</p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>对于我们学习汇编来讲，CPU中最为主要的部件是寄存器，寄存器是CPU中程序员可以进行读写操作的部件。程序员通过改变寄存器的内容来实现对CPU的控制。</p><p>不同的CPU，寄存器的个数、结构不同。8086CPU有14个寄存器，每一个寄存器都有自己的名字：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>在8086CPU中所有寄存器都是16位的。其中AX、BX、CX、DX这四个寄存器通常存储一些一般性的数据，被称为通用寄存器。</p><p><img src="2.jpg" alt="寄存器AX"></p><p>为了兼容上一代8位CPU，这些通用寄存器可以被分为两个8位寄存器例如AX可以分成AH和AL分别对应寄存器AX的高八位和低八位，同理BX也可以分为BH和BL。</p><p>出于对于兼容性的考虑，8086CPU可以对字节（1B）和字（2B）这两种尺寸的数据进行处理。</p><h1 id="mov指令与add指令"><a href="#mov指令与add指令" class="headerlink" title="mov指令与add指令"></a>mov指令与add指令</h1><p>好啦，接下来我们正式的学习两条汇编指令：mov和add</p><p>首先，mov指令，mov指令又被叫做传送指令，大部分寄存器的值都可以被mov指令改变，我们使用高级语言的语法来描述这件事情以加强理解（在写一条汇编指令或者寄存器名称时不区分大小写）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,18 &lt;=&gt; ax=18</span><br></pre></td></tr></table></figure><p>怎么样是不是很直观？没错mov指令的作用和赋值相似，该mov指令控制CPU将18这个数据送入到了寄存器AX中。当然了这里要注意的是在汇编源程序中，数据是不能以字母开头的，也就是说A000H这样的数据是不允许出现在汇编源程序的，要在前面加上一个0才可以，也就是0A000H可以使用。</p><p>其次，add指令（在写一条汇编指令或者寄存器名称时不区分大小写）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add ax,8 &lt;=&gt; AX=AX+8</span><br></pre></td></tr></table></figure><p>add指令的作用就相当于加上一个数字并且赋值给add指令后的寄存器，该add指令控制CPU将8这个数据与原先AX中的数据相加后赋值给AX。</p><p>举一个简单的例子加强对于两个指令的理解：</p><table><thead><tr><th>程序段中的指令</th><th>指令执行后AX中的数据</th><th>指令执行后BX中的数据</th></tr></thead><tbody><tr><td>mov ax,4E20H</td><td>4E20H</td><td>0000H</td></tr><tr><td>add ax,1406H</td><td>6226H</td><td>0000H</td></tr><tr><td>mov bx,2000H</td><td>6226H</td><td>2000H</td></tr><tr><td>add ax,bx</td><td>8226H</td><td>2000H</td></tr></tbody></table><p>在add指令的使用过程中要注意位数的问题：</p><p>现有AL中存储数据C5H此时使用 add AL,93H ，那么执行后AX中的数据是多少？答案是0058H，因为AL是一个8位寄存器，在add指令执行后，得到结果值为158H，这超过了8位的存储大小，所以最高位的“1”被无情“抛弃”（实际上并不是真正的抛弃掉了，只是表示这个”1“装不下了，至于如何处理我们后续再聊）。而且AL和AH都是被当做一个独立的寄存器所使用的，这个“1”并不会储存在AH中。</p><p>相应的如果AX中存储数据C5H此时使用 add AX,93H ，那么结果又会如何呢？答案是0158H，因为AX是一个16位寄存器，在add指令执行后，得到结果值为158H，不超过16位的存储大小，所以0158H完整的被存放在了寄存器AX之中。</p><p>由此可知，在进行add指令的使用，要注意此次运算到底是几位运算。</p><h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p>我们知道CPU访问内存单元需要提供出访问的内存单元的地址，每一个内存单元都有一个唯一的地址，我们称这个唯一的地址就叫做物理地址。CPU必须现在内部形成这个物理地址，才可以通过地址总线传出，访问特定的内存单元。每一种不同的CPU都有这不一样的方式生成物理地址，下面我们讨论8086CPU如何在内部生成该物理地址。</p><h1 id="8086CPU生成物理地址的方法"><a href="#8086CPU生成物理地址的方法" class="headerlink" title="8086CPU生成物理地址的方法"></a>8086CPU生成物理地址的方法</h1><p>首先我们要知道8086CPU是一个16位结构的CPU，它具有以下特点：</p><ul><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器的通路为16位</li></ul><p>这就意味着8086CPU一次性能够处理、传输、暂存的信息最大长度是16位。</p><p>8086CPU外部有20位地址总线，寻址能力达到了1MB。但因为8086CPU的16位结构导致其表现出来的寻址能力只有64KB为了解决这个问题，8086CPU采用了使用两个16位地址组成一个20位地址。</p><p>当8086CPU进行读写内存操作时8086CPU的相关部件提供两个16位的地址，一个叫做段地址，一个叫做偏移地址。两个地址被送入一个叫地址加法器的部件中合成一个20位地址。</p><p>看到这里我猜你可能有一个疑惑，怎么就两个16位地址变成了一个20位地址呢？</p><p>其实啊，地址加法器有一个独门的公式：物理地址=段地址×16+偏移地址，这样就由两个16位地址变成了一个20位地址。为什么一定是乘16嘞？因为段地址和偏移地址都是一个十六进制数字，通过乘16的方式使段地址整体左移一位。（就像是二进制中 “10”× 2就变成了100）</p><p>假如8086CPU要访问123C8H这个地址，那么整体过程就是：</p><ol><li>相关部件提供段地址 1230H 和偏移地址 00C8H 并送入了地址加法器</li><li>地址加法器通过公式：物理地址=段地址×16+偏移地址 得到物理地址=1230H×16+00C8H=123C8H</li><li>地址加法器把物理地址传输给输入输出控制电路</li><li>输入输出控制电路通过地址总线将物理地址传输给内存</li></ol><p>这样8086CPU就实现了对于内存的访问。</p><h1 id="对于段的理解"><a href="#对于段的理解" class="headerlink" title="对于段的理解"></a>对于段的理解</h1><p>上述提到了段地址的概念，可能让大家理解成内存本身就是一个分段一样的存在，但实则不然，只是CPU操作内存时候采用了分段的方法进行管理。在实际的汇编编程过程中我们可以根据实际需要进行分段处理，由于公式：物理地址=段地址×16+偏移地址 可知一个内存段的起始地址（即段地址×16）必然为16的倍数，因为偏移地址的长度为16位，寻址能力为64KB，所以一个段的长度最大为64KB。</p><h1 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h1><p>上面我们提到CPU内相关组件会提供段地址和偏移地址给地址加法器，那么到底是什么部件提供的呢？那就是段寄存器所提供的，8086CPU中含有4个段寄存器：CS、DS、SS、ES。这里我们先聊聊CS，后续我们在继续讨论其余段寄存器。</p><h2 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h2><p>CS和IP是8086CPU中最为关键的两个寄存器，它们指明了CPU现在要读取指令的地址。CS叫做代码段寄存器，IP叫做指令指针寄存器。假设任意时刻CS中数据为M，IP中数据为N，那么8086CPU就会从内存地址为 M×16+N 的内存单元中读取一条指令并且执行。执行指令之后IP会根据指令的字节数自增。（tips：这里要注意M和N只是段地址和偏移地址的一个实例，不只是CS和IP会提供段地址和偏移地址。）</p><p>假如8086CPU要执行 mov ax,0123H （长度为3B，在地址20000H处）这个指令 那么整体过程就是：</p><ol><li>CS提供段地址2000H，IP提供偏移地址0000H给地址加法器</li><li>地址加法器通过公式：物理地址=段地址×16+偏移地址 得到物理地址=2000H×16+0000H=20000H</li><li>地址加法器把物理地址传输给输入输出控制电路</li><li>输入输出控制电路通过地址总线将物理地址传输给内存</li><li>内存通过数据总线返回给CPU指令 mov ax,0123H</li><li>输入输出控制电路将指令 mov ax,0123H 放入指令缓冲器中</li><li>IP读取到指令长度为3B 自增 3 变为 0003H</li><li>指令执行</li><li>读取下一条指令</li></ol><p>这样8086CPU就读取并且执行了一条汇编指令。</p><p>不知道大家有没有过一个疑问，计算机里面全都是二进制代码，那计算机怎么区分那些二进制代码要当成数据看待，那些二进制代码要当成指令看待呢？学习玩CS IP之后我们可以说会被CS:IP指向的内容就是指令。</p><h1 id="修改CS-IP-数据-JMP指令"><a href="#修改CS-IP-数据-JMP指令" class="headerlink" title="修改CS IP 数据 JMP指令"></a>修改CS IP 数据 JMP指令</h1><p>学习了这样一个底层的语言，我们有权利修改寄存器中的数据，我们可以通过修改CS和IP中的数据来让计算机执行我们希望它去执行的指令。这个时候，有些朋友可能已经开始回想，我们之前学习过mov指令，可以用来修改寄存器中的数据，我们故技重施，直接使用mov去修改CS和IP的数据。但事实上这样是不被允许的，为什么嘞？其实答案很简单，因为8086CPU它。。。它做不到呀！！没这个功能。但不用担心，车到山前必有路，我们有可以改变CS IP的指令叫做转移指令（晚一些我们还会深入研究），这里我们介绍一个简单的转移指令：jmp指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果想同时修改CS IP的值可以用 jmp 段地址:偏移地址 来完成</span><br><span class="line">例如：</span><br><span class="line">jmp 2AE3:3 执行后 CS=2AE3H IP=0003H CPU会从2AE33H处读取指令</span><br><span class="line">当你只想修改IP中的值可以用 jmp 某一合法寄存器 来完成</span><br><span class="line">例如：</span><br><span class="line">AX=1000H,CS=2000H,IP=0003H</span><br><span class="line">jmp ax 执行后 AX=1000H,CS=2000H,IP=1000H CPU会从21000H处读取指令</span><br></pre></td></tr></table></figure><h1 id="Debug调试指令"><a href="#Debug调试指令" class="headerlink" title="Debug调试指令"></a>Debug调试指令</h1><p>学会了这些指令，没地方用怎么能行，取我DOSBOX来，先输入debug，出现一个短杠后就可以使用调试指令啦，接下来就教大家如何使用debug：</p><p>1.R命令：查看、改变CPU寄存器的内容</p><p><img src="3.jpg" alt="R命令"></p><p>改变寄存器内容只需要在r后面加上寄存器名称即可。</p><p>2.D命令：查看内存中的内容</p><p><img src="4.jpg" alt="D命令"></p><p>D命令默认根据DS寄存器内容显示，每次显示128个字节的数据，想显示指定位置数据，只需要在D命令后加上 段地址：偏移地址。</p><p>3.E命令：改写内存内容</p><p><img src="5.jpg" alt="E命令"></p><p>E命令后加上 段地址：偏移地址 即可从指定物理地址后改写内存内容，如果遇到不想改写的内容空格跳过，enter结束。</p><p>4.U命令：将内存中的机器指令翻译成汇编指令</p><p><img src="6.jpg" alt="U命令"></p><p>U命令将CS:IP指向的机器指令翻译成汇编指令。</p><p>5.T命令：执行一条机械指令</p><p><img src="7.jpg" alt="T命令"></p><p>T命令执行一条当前CS:IP所指的汇编指令。</p><p>6.A命令：以汇编语言的格式向内存中写入一条机器指令</p><p><img src="8.jpg" alt="A命令"></p><p>A命令后加 段地址：偏移地址 可以在指定物理地址位置用汇编语言写入一条机器指令。</p><p>学会了这些命令，你就可以使用DOSBOX来验证所学内容啦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（一）</title>
    <link href="http://example.com/2022/08/09/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/08/09/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-08-09T14:50:10.000Z</published>
    <updated>2022-08-29T10:10:42.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li></ol><p>话不多说我们马上开始。</p><h1 id="初识汇编"><a href="#初识汇编" class="headerlink" title="初识汇编"></a>初识汇编</h1><blockquote><p>汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。</p></blockquote><p>早在计算机诞生之初，人们就开始使用机器语言和计算机进行交流了，因为计算机的硬件作为一种电路元件，其输入输出只能是高电平和低电平，所以计算机传递的数据是有“0”和“1”组成的二进制数。二进制的语言就是计算机语言的本质，所有的高级语言诸如JAVA，C++,C#等最终都会转化为一系列的二进制数供计算机阅读，最初的程序员们就是使用这样繁杂的机器语言利用打孔机重复的敲击“0”和“1”在纸带上留下他们奋斗的痕迹。</p><p>但你懂得”011001011010110….“这种东西简直实在折磨人，这么一大串数字要准确无误的输入是不可能的，人们很快的就发现了这一点，为了减轻这样的痛苦，人们对这种机器语言进行了升级改造，用一些简单的容易记忆的单词或者字母来代替一个特定的指令。通过这种办法人们可以很方便的进行编程。就这样汇编语言诞生了。</p><h1 id="汇编在今天"><a href="#汇编在今天" class="headerlink" title="汇编在今天"></a>汇编在今天</h1><p> “啊？！这么老的语言，我学他有什么用啊?我用JAVA,C++,C#不香嘛”，确实发展到今天汇编语言也已经被改进与高级语言相比汇编语言也成为了一种繁杂的编程语言。</p><p><img src="1.jpg" alt="一段输出斐波那契数列的程序转化为汇编语言"></p><p>但实际上汇编语言经历了这么长时间的变革以后，仍然具有一定的影响力。在2022年8月仍能站在前十大编程语言之中。</p><p><img src="2.jpg" alt="2022年8月编程语言排行"></p><p>学习汇编并不是说一定要懂得使用汇编一定从事一个需要汇编的工作，因为汇编语言更接近计算机的底层，学习汇编可以充分的获得底层编程的体验，深刻理解机器运行的机理，这是学习高级语言所不可获得的，学习汇编对于其他计算机核心课程也有帮助。试问任何一个计算机科班出身的人，哪一位不希望了解计算机更原始更基底的奥秘呢？</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>众所周知，CPU是电脑的核心部件，它控制着整个计算机的运行和计算，就像是人的大脑。CPU想进行工作就要为其提供指令和数据，指令和数据就存放在存储器中也就是我们常说的内存（也就是计算机中的内存条）。磁盘不同于内存，磁盘中的数据于指令如果没有被读取到内存中是无法被CPU使用的，故要灵活的使用汇编语言要了解CPU是如何从内存中读取和写入信息的。</p><h2 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h2><p>存储器在计算机眼里会被划分为多个存储单元，一个存储单元可以存储8个bit也就是1B，这些存储单元是通过一定的规则进行编号的，每一个编号就像是一个存储单元的地址一样。CPU想要进行数据的读写就需要这三类信息的交互：</p><ul><li>存储单元的地址（地址信息）</li><li>器件的选择，读或写的命令（控制信息）</li><li>读或写的数据（数据信息）</li></ul><p><img src="3.jpg" alt="CPU对存储器的读写操作"></p><h3 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h3><p>地址总线，线如其名，用于CPU与内存之间传递地址信息用的线的集合就叫做地址总线。地址总线上能传递多少个不同的信息就是可以对多少个存储单元（Byte）进行寻址，一个CPU具有N个地址线那么其就可以传递2的N次幂个内存单元，我们也称这个CPU的地址总线宽度为N，例如10根地址线的CPU，其地址总线宽度为10，其寻址能力为1KB。</p><h3 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h3><p>CPU与内存或者其他器件之间想要进行数据传递那一定是通过数据总线来进行的，数据总线的宽度决定了数据传递的速度，比如8根数据总线一次可以传递1B的数据，那么16根数据总线一次就可以传递2B的数据。这里顺便说一下在整个汇编学习中使用的一般都是十六进制数，因为它和二进制数对应关系更为明显，每4位二进制数就对应1位十六进制数。故由此可知，每2位十六进制数就对应了1B的数据。</p><p><img src="4.jpg" alt="二进制和十六进制"></p><h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h3><p>控制总线就是CPU传递控制信息所用的线的集合，控制总线的宽度代表着CPU对器件的控制能力。</p><h1 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h1><p>什么是内存地址空间呢？内存空间地址大小取决于地址总线的宽度，内存地址空间和CPU的寻址空间大小是一样的为2的N次幂，这些可寻址的内存单元就构成了CPU的内存地址空间。</p><p>现在我们来深入讨论一下什么是内存地址空间。</p><p>首先我们从物理上来理解一下计算机存储，计算机会有很多个存储器，这些存储器从其读写属性上分类实则分为两类：随机存储器（RAM）和只读存储器（ROM），RAM可读可写，但必须带电存储如果关机则其数据也会丢失，而ROM顾名思义，只可以读不可写，关机后数据不会丢失。在计算机各个器件中诸如显卡，网卡等等都含有这些存储器。</p><p><img src="5.jpg" alt="计算机器件中的存储器"></p><p>这些东西从物理上是独立的器件，但实际上它们都通过总线和CPU相连，也就是说其实在CPU眼里大家都是一样的都是内存而已，所以抽象出来一个假想的逻辑存储器叫做内存地址空间。</p><p><img src="6.jpg" alt="假想的逻辑存储器"></p><p>因此，内存地址空间是我们在探讨CPU对于各类电子器件进行信息交流所假想出来的一种工具，方便我们理解CPU是通过对于不同内存地址操作来工作的。</p><h1 id="搭建汇编语言环境"><a href="#搭建汇编语言环境" class="headerlink" title="搭建汇编语言环境"></a>搭建汇编语言环境</h1><ol><li><p>搜索DOSBox，下载对应系统下的DOSBox 并安装 <a href="https://www.dosbox.com/download.php?main=1">戳我</a></p></li><li><p>下载需要的命令文件  <a href="https://pan.baidu.com/s/1tTd2kVeRFqLeCssb6f6QJA?pwd=7iny">戳我</a></p></li><li><p>将下载好的命令文件解压到你所安装的盘符根目录下，文件夹名为MASM（安装到D盘就直接解压到D盘中就行）</p></li><li><p>打开C:\Users\29421\AppData\Local\DOSBox 这个路径找到dosbox-0.74-3.conf 文件 在最后输入并保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount d d:\masm</span><br><span class="line"> d:</span><br></pre></td></tr></table></figure></li></ol><p>tips：如果没有AppData需要设置“显示隐藏的文件、文件夹和驱动器”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>QT编译MYSQL驱动</title>
    <link href="http://example.com/2022/07/14/QT%E7%BC%96%E8%AF%91MYSQL%E9%A9%B1%E5%8A%A8/"/>
    <id>http://example.com/2022/07/14/QT%E7%BC%96%E8%AF%91MYSQL%E9%A9%B1%E5%8A%A8/</id>
    <published>2022-07-14T10:37:46.000Z</published>
    <updated>2022-08-10T01:46:35.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用QT进行C++开发时，会使用到MySQL，但高版本的QT并不支持MySQL（主要因为没有驱动，具体这里的爱恨情仇，博主也不太了解），所以想在QT中使用MySQL要自行手动的编译出MySQL驱动。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在编译我们的MySQL驱动之前需要准备好如下的几项东西</p><p>1.QT<br>2.MySQL<br>3.QT源代码</p><h2 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h2><p>下载好安装器后需要选择自己的组件进行安装，这里必须要有的就是这个sources组件，当然了如果不确定自己是否安装过sources组件或者需要安装可以打开QT安装目录下的MaintenanceTool进行修改。至于编译套件的选择看个人喜好，<strong>但一定一定一定要注意的事情是编译套件的位数必须和MySQL的位数一致否则后续的编译会失败！！</strong>这里博主以编译套件MinGW 11.2.0 64-bit为例子。（PS：一定要记得自己把QT安在哪里了呀！！）</p><p><img src="1.jpg" alt="QT的安装准备"></p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL只需要去官网下载最新版本即可<a href="https://dev.mysql.com/downloads/installer/">戳这里进入MySQL下载界面</a></p><p>下载完成后第一个界面选择Custom</p><p>第二个界面中选择一个MySQL Server进行安装，官方为我们提供了8.0、5.7、5.6三个大版本可以选择</p><p>点开选择的MySQL Server后选择小版本，再次强调<strong>一定一定要选择和编译套件一样位数的MySQL安装。</strong></p><h2 id="QT源码"><a href="#QT源码" class="headerlink" title="QT源码"></a>QT源码</h2><p>准备QT源码之前可以看一看自己QT安装目录下\QT\6.3.1\Src\qtbase\src\plugins\sqldrivers\mysql中是否存在mysql.pro文件，如果没有需要自行下载qt-everywhere-src-6.0.3文件<a href="https://download.qt.io/official_releases/qt/6.0/6.0.3/single/">戳这里进入源码下载界面</a></p><h1 id="编译驱动及配置"><a href="#编译驱动及配置" class="headerlink" title="编译驱动及配置"></a>编译驱动及配置</h1><h2 id="修改项目文件"><a href="#修改项目文件" class="headerlink" title="修改项目文件"></a>修改项目文件</h2><p>解压下载好的QT源码按照\QT\6.0.3\Src\qtbase\src\plugins\sqldrivers\mysql找到mysql.pro文件打开，<strong>使用和MySQL相同位数的编译套件进行编译</strong>，如果你正确的打开文件后那么项目栏应该是这样子滴。 </p><p><img src="2.jpg" alt="项目目录"> </p><p>打开mysql.pro文件进行如下修改</p><p><img src="3.jpg" alt="修改项目文件1"></p><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIBS += -L<span class="string">&quot;C:\Program Files\MySQL\MySQL Server 8.0\lib&quot;</span> -llibmysql</span><br><span class="line">INCLUDEPATH += <span class="string">&quot;C:\Program Files\MySQL\MySQL Server 8.0\include&quot;</span></span><br><span class="line">DEPENDPATH += <span class="attribute">C</span>:\Program Files\MySQL\MySQL Server <span class="number">8.0</span>\include </span><br></pre></td></tr></table></figure><p>这里有一个坑是如果MySQL安装路径中有空格那么LIBS和INCLUDEPATH后的路径一定要用“”（双引号）引起再打开qsqldriverbase.pri文件进行如下修改</p><p><img src="4.jpg" alt="修改项目文件2"></p><p>之后点击左下脚的构建（小榔头图标）</p><h2 id="配置驱动"><a href="#配置驱动" class="headerlink" title="配置驱动"></a>配置驱动</h2><p>你编译好的驱动躺在你安装QT的盘符下的plugins文件夹中，比如博主的QT安装在了D盘，那么只要进入D盘就可以清楚地看见plugins文件夹，在.\plugins\sqldrivers中找到这三个小家伙，他们就是我们历经千辛万苦所编译出来的宝贵驱动文件。</p><p><img src="5.jpg" alt="驱动位置"></p><p>将他们复制粘贴到（你的QT安装的位置）\QT\6.3.1\Src\qtbase\src\plugins\sqldrivers中</p><p><img src="6.jpg" alt="驱动安放位置"></p><p>做到这里恭喜你你已经完成了80%的工作了！！</p><p>打开找到下面两个文件。</p><p><img src="7.jpg" alt="配置sql所需文件1"></p><p>把他们放到你QT安装路径下\QT\6.3.1\mingw_64\bin中</p><p><img src="8.jpg" alt="配置sql所需文件2"></p><p>新建一个QT项目，在第二步的时候将CMake改为qmake。高版本的QT逐渐抛弃了qmake，之后也会考虑出一片文章介绍一下这个事情，不过这里我们还是先用qmake。创建完成后要运行一次程序点击左下角的三角符号运行。</p><p><img src="9.jpg" alt="创建QT项目"></p><p>建好以后会出现两个文件夹。</p><p><img src="10.jpg" alt="创建成功的文件夹"></p><p>接着打开你的MySQL安装路径找到Connector C++ 8.0文件夹打开其中的lib64文件夹找到这两个文件。</p><p><img src="11.jpg" alt="所需要的文件"></p><p>放在.\build-demo-Desktop_Qt_6_3_1_MinGW_64_bit-Debug\debug中</p><p><img src="12.jpg" alt="文件放置位置"></p><p>这一步操作的原因是因为MySql 8.0 之后的版本，提高了客户端和服务器数据通信的安全性，对通信数据做了加密，我们需要添加这两个文件（动态库），这里博主发现了一个现象等你再一次新建一个项目时不添加也可以成功运行一个MySQL程序，可能这就是<del>爱的</del>信任的力量。</p><h1 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h1><p>OK！至此所有编译与配置都已经完成了接下来进行一个简单的测试</p><p>首先打开项目的pro文件在第一行代码最后添加“sql”</p><p><img src="13.jpg" alt="添加sql模块"></p><p>测试代码（全选复制粘贴到mainwindow.cpp，记得修改数据库的密码和数据库的名字）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtSql/QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlError&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">        QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>);</span><br><span class="line">        db.<span class="built_in">setHostName</span>(<span class="string">&quot;127.0.0.1&quot;</span>); <span class="comment">// 本地连接</span></span><br><span class="line">        db.<span class="built_in">setPort</span>(<span class="number">3306</span>);       <span class="comment">// 如果使用的是默认端口可以不设置</span></span><br><span class="line">        db.<span class="built_in">setUserName</span>(<span class="string">&quot;root&quot;</span>);<span class="comment">// 数据库用户名</span></span><br><span class="line">        db.<span class="built_in">setPassword</span>(<span class="string">&quot;*******&quot;</span>); <span class="comment">// 数据库密码</span></span><br><span class="line">        db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;*******&quot;</span>); <span class="comment">// 数据库名字</span></span><br><span class="line">        <span class="keyword">if</span>(db.<span class="built_in">open</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;打开数据库&quot;</span>, <span class="string">&quot;数据库打开成功, 可以读写数据了......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            QString msg = <span class="string">&quot;数据库打开失败: &quot;</span> + db.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">            QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;打开数据库&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="14.jpg"></p><p>至此QT可以使用MYSQL</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在使用QT进行C++开发时，会使用到MySQL，但高版本的QT并不支持MySQL（主要因为没有驱动，具体这里的爱恨情仇，博主也不太了解），所</summary>
      
    
    
    
    <category term="QT" scheme="http://example.com/categories/QT/"/>
    
    
    <category term="QT" scheme="http://example.com/tags/QT/"/>
    
  </entry>
  
</feed>
