<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuzheng&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-21T14:00:19.102Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>liu zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从0开始的汇编语言（三）</title>
    <link href="http://example.com/2022/08/19/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2022/08/19/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-08-19T05:00:45.000Z</published>
    <updated>2022-08-21T14:00:19.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下规定：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li></ol><p>话不多说我们马上开始。</p><h1 id="字节型数据与字型数据"><a href="#字节型数据与字型数据" class="headerlink" title="字节型数据与字型数据"></a>字节型数据与字型数据</h1><p>众所周知，字节与字之间存在着一种二倍的关系，也就是说2个字节就等于1个字。由于内存单元是字节单元，也就是说一个内存单元只存储一个字节，所以计算机使用两个连续的内存单元存储一个字。计算机将这个字的第八位放在低位内存单元中，将高八位放在高位内存单元之中。我们称起始地址是N的字单元为N地址字单元。</p><h1 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h1><p>现在我们知道了计算机如何将一个字存储到内存单元之中，但是计算机又如何从内存单元之中取出一个字呢？这就要提到另一个段寄存器DS了。DS寄存器中通常存放着要访问数据的段地址。（Tips：物理地址=段地址×16+偏移地址）</p><p>例如我们想要读取10000H中的数据，我们就编写了如下的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov BX,1000H</span><br><span class="line">mov DS,BX</span><br><span class="line">mov AL,[0]</span><br></pre></td></tr></table></figure><p>这样我们就把10000H中的字节数据存放到了AL中。</p><p>这个时候我相信肯定有的小伙伴就要发出了疑问“只有段地址没有偏移地址怎么能确定一个准确的内存单元呢？”我也相信有小伙伴已经发现了<del>华点</del>盲点。没错，DS和CS相同，也有一个搭档用来指示偏移地址，而这个搭档就是”[ address ]”。中括号中包含的地址就是偏移地址。</p><p>这里还需要注意的事是我们明明可以通过使用mov指令直接将1000H送入DS中，为什么还要大费周章先把1000H送入BX中再将BX中的数据送入DS呢？这个问题其实很简单，因为8086CPU不支持你这样做，这是一个硬件设计的问题，所以我们就记住要这样为DS提供地址。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>相信有计算机基础的小伙伴对于栈一定不陌生了，不过这里还是给各位介绍一下栈。我们举一个例子，我平时打羽毛球都会从桶中拿出第一个球，而这个球的下场只有两个，我把它打残废，我从羽毛球桶中拿出下一个球，或者它老老实实的配合我拍照，我把它放回桶中。这整个过程中，球都只从上面的开口中取出或者放入，我们没有从另一端取出在放入，这样的存取和最初生产出来的时候是相反的。所以我们给出栈的定义：栈是一种使用受限的线性表，其中数据符合后进先出（LIFO）的存取原则。</p><p><img src="1.jpg" alt="栈"></p><h1 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h1><p>现如今的CPU中都有栈的设计。8086CPU提供了出栈与入栈的指令，即PUSH（入栈）与POP（出栈），当然这两个指令都是以字为单位进行的。我们看一个简单的例子：</p><p><img src="2.jpg" alt="PUSH与POP"></p><p>注意栈是由高位空间向低位空间延伸的，所以两个相邻的内存单元，一个字的高八位要放在下面，低八位放在上面。</p><h2 id="SS与SP"><a href="#SS与SP" class="headerlink" title="SS与SP"></a>SS与SP</h2><p>看了上面的例子，我们对于PUSH与POP有了一定的了解，但这同时也引出了一个问题，既然栈需要从栈顶存入或者取出数据，那CPU怎么知道栈顶的位置呢？<del>我都不知道！</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，以</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（二）</title>
    <link href="http://example.com/2022/08/10/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2022/08/10/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-08-10T08:53:09.000Z</published>
    <updated>2022-08-10T14:01:32.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下规定：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li></ol><p>话不多说我们马上开始。</p><h1 id="CPU内部组成"><a href="#CPU内部组成" class="headerlink" title="CPU内部组成"></a>CPU内部组成</h1><p>通常一个CPU由运算器、控制器、寄存器等器件所组成，这些器件在CPU中中过内部的总线相互连接。</p><p><img src="1.jpg" alt="CPU内部结构及CPU与内存交互"></p><p>其中运算器进行信息处理，寄存器进行信息存储，控制器控制各种器件进行工作，内部总线将它们相互连接，在它们之间进行数据的传递。</p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>对于我们学习汇编来讲，CPU中最为主要的部件是寄存器，寄存器是CPU中程序员可以进行读写操作的部件。程序员通过改变寄存器的内容来实现对CPU的控制。</p><p>不同的CPU，寄存器的个数、结构不同。8086CPU有14个寄存器，每一个寄存器都有自己的名字：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>在8086CPU中所有寄存器都是16位的。其中AX、BX、CX、DX这四个寄存器通常存储一些一般性的数据，被称为通用寄存器。</p><p><img src="2.jpg" alt="寄存器AX"></p><p>为了兼容上一代8位CPU，这些通用寄存器可以被分为两个8位寄存器例如AX可以分成AH和AL分别对应寄存器AX的高八位和低八位，同理BX也可以分为BH和BL。</p><p>出于对于兼容性的考虑，8086CPU可以对字节（1B）和字（2B）这两种尺寸的数据进行处理。</p><h1 id="mov指令与add指令"><a href="#mov指令与add指令" class="headerlink" title="mov指令与add指令"></a>mov指令与add指令</h1><p>好啦，接下来我们正式的学习两条汇编指令：mov和add</p><p>首先，mov指令，mov指令又被叫做传送指令，大部分寄存器的值都可以被mov指令改变，我们使用高级语言的语法来描述这件事情以加强理解（在写一条汇编指令或者寄存器名称时不区分大小写）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,18 &lt;=&gt; ax=18</span><br></pre></td></tr></table></figure><p>怎么样是不是很直观？没错mov指令的作用和赋值相似，该mov指令控制CPU将18这个数据送入到了寄存器AX中。</p><p>其次，add指令（在写一条汇编指令或者寄存器名称时不区分大小写）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add ax,8 &lt;=&gt; AX=AX+8</span><br></pre></td></tr></table></figure><p>add指令的作用就相当于加上一个数字并且赋值给add指令后的寄存器，该add指令控制CPU将8这个数据与原先AX中的数据相加后赋值给AX。</p><p>举一个简单的例子加强对于两个指令的理解：</p><table><thead><tr><th>程序段中的指令</th><th>指令执行后AX中的数据</th><th>指令执行后BX中的数据</th></tr></thead><tbody><tr><td>mov ax,4E20H</td><td>4E20H</td><td>0000H</td></tr><tr><td>add ax,1406H</td><td>6226H</td><td>0000H</td></tr><tr><td>mov bx,2000H</td><td>6226H</td><td>2000H</td></tr><tr><td>add ax,bx</td><td>8226H</td><td>2000H</td></tr></tbody></table><p>在add指令的使用过程中要注意位数的问题：</p><p>现有AL中存储数据C5H此时使用 add AL,93H ，那么执行后AX中的数据是多少？答案是0058H，因为AL是一个8位寄存器，在add指令执行后，得到结果值为158H，这超过了8位的存储大小，所以最高位的“1”被无情“抛弃”（实际上并不是真正的抛弃掉了，只是表示这个”1“装不下了，至于如何处理我们后续再聊）。而且AL和AH都是被当做一个独立的寄存器所使用的，这个“1”并不会储存在AH中。</p><p>相应的如果AX中存储数据C5H此时使用 add AX,93H ，那么结果又会如何呢？答案是0158H，因为AX是一个16位寄存器，在add指令执行后，得到结果值为158H，不超过16位的存储大小，所以0158H完整的被存放在了寄存器AX之中。</p><p>由此可知，在进行add指令的使用，要注意此次运算到底是几位运算。</p><h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p>我们知道CPU访问内存单元需要提供出访问的内存单元的地址，每一个内存单元都有一个唯一的地址，我们称这个唯一的地址就叫做物理地址。CPU必须现在内部形成这个物理地址，才可以通过地址总线传出，访问特定的内存单元。每一种不同的CPU都有这不一样的方式生成物理地址，下面我们讨论8086CPU如何在内部生成该物理地址。</p><h1 id="8086CPU生成物理地址的方法"><a href="#8086CPU生成物理地址的方法" class="headerlink" title="8086CPU生成物理地址的方法"></a>8086CPU生成物理地址的方法</h1><p>首先我们要知道8086CPU是一个16位结构的CPU，它具有以下特点：</p><ul><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器的通路为16位</li></ul><p>这就意味着8086CPU一次性能够处理、传输、暂存的信息最大长度是16位。</p><p>8086CPU外部有20位地址总线，寻址能力达到了1MB。但因为8086CPU的16位结构导致其表现出来的寻址能力只有64KB为了解决这个问题，8086CPU采用了使用两个16位地址组成一个20位地址。</p><p>当8086CPU进行读写内存操作时8086CPU的相关部件提供两个16位的地址，一个叫做段地址，一个叫做偏移地址。两个地址被送入一个叫地址加法器的部件中合成一个20位地址。</p><p>看到这里我猜你可能有一个疑惑，怎么就两个16位地址变成了一个20位地址呢？</p><p>其实啊，地址加法器有一个独门的公式：物理地址=段地址×16+偏移地址，这样就由两个16位地址变成了一个20位地址。为什么一定是乘16嘞？因为段地址和偏移地址都是一个十六进制数字，通过乘16的方式使段地址整体左移一位。（就像是二进制中 “10”× 2就变成了100）</p><p>假如8086CPU要访问123C8H这个地址，那么整体过程就是：</p><ol><li>相关部件提供段地址 1230H 和偏移地址 00C8H 并送入了地址加法器</li><li>地址加法器通过公式：物理地址=段地址×16+偏移地址 得到物理地址=1230H×16+00C8H=123C8H</li><li>地址加法器把物理地址传输给输入输出控制电路</li><li>输入输出控制电路通过地址总线将物理地址传输给内存</li></ol><p>这样8086CPU就实现了对于内存的访问。</p><h1 id="对于段的理解"><a href="#对于段的理解" class="headerlink" title="对于段的理解"></a>对于段的理解</h1><p>上述提到了段地址的概念，可能让大家理解成内存本身就是一个分段一样的存在，但实则不然，只是CPU操作内存时候采用了分段的方法进行管理。在实际的汇编编程过程中我们可以根据实际需要进行分段处理，由于公式：物理地址=段地址×16+偏移地址 可知一个内存段的起始地址（即段地址×16）必然为16的倍数，因为偏移地址的长度为16位，寻址能力为64KB，所以一个段的长度最大为64KB。</p><h1 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h1><p>上面我们提到CPU内相关组件会提供段地址和偏移地址给地址加法器，那么到底是什么部件提供的呢？那就是段寄存器所提供的，8086CPU中含有4个段寄存器：CS、DS、SS、ES。这里我们先聊聊CS，后续我们在继续讨论其余段寄存器。</p><h2 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h2><p>CS和IP是8086CPU中最为关键的两个寄存器，它们指明了CPU现在要读取指令的地址。CS叫做代码段寄存器，IP叫做指令指针寄存器。假设任意时刻CS中数据为M，IP中数据为N，那么8086CPU就会从内存地址为 M×16+N 的内存单元中读取一条指令并且执行。执行指令之后IP会根据指令的字节数自增。（tips：这里要注意M和N只是段地址和偏移地址的一个实例，不只是CS和IP会提供段地址和偏移地址。）</p><p>假如8086CPU要执行 mov ax,0123H （长度为3B，在地址20000H处）这个指令 那么整体过程就是：</p><ol><li>CS提供段地址2000H，IP提供偏移地址0000H给地址加法器</li><li>地址加法器通过公式：物理地址=段地址×16+偏移地址 得到物理地址=2000H×16+0000H=20000H</li><li>地址加法器把物理地址传输给输入输出控制电路</li><li>输入输出控制电路通过地址总线将物理地址传输给内存</li><li>内存通过数据总线返回给CPU指令 mov ax,0123H</li><li>输入输出控制电路将指令 mov ax,0123H 放入指令缓冲器中</li><li>IP读取到指令长度为3B 自增 3 变为 0003H</li><li>指令执行</li><li>读取下一条指令</li></ol><p>这样8086CPU就读取并且执行了一条汇编指令。</p><p>不知道大家有没有过一个疑问，计算机里面全都是二进制代码，那计算机怎么区分那些二进制代码要当成数据看待，那些二进制代码要当成指令看待呢？学习玩CS IP之后我们可以说会被CS:IP指向的内容就是指令。</p><h1 id="修改CS-IP-数据"><a href="#修改CS-IP-数据" class="headerlink" title="修改CS IP 数据"></a>修改CS IP 数据</h1><p>学习了这样一个底层的语言，我们有权利修改寄存器中的数据，我们可以通过修改CS和IP中的数据来让计算机执行我们希望它去执行的指令。这个时候，有些朋友可能已经开始回想，我们之前学习过mov指令，可以用来修改寄存器中的数据，我们故技重施，直接使用mov去修改CS和IP的数据。但事实上这样是不被允许的，为什么嘞？其实答案很简单，因为8086CPU它。。。它做不到呀！！没这个功能。但不用担心，车到山前必有路，我们有可以改变CS IP的指令叫做转移指令（晚一些我们还会深入研究），这里我们介绍一个简单的转移指令：jmp指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果想同时修改CS IP的值可以用 jmp 段地址:偏移地址 来完成</span><br><span class="line">例如：</span><br><span class="line">jmp 2AE3:3 执行后 CS=2AE3H IP=0003H CPU会从2AE33H处读取指令</span><br><span class="line">当你只想修改IP中的值可以用 jmp 某一合法寄存器 来完成</span><br><span class="line">例如：</span><br><span class="line">AX=1000H,CS=2000H,IP=0003H</span><br><span class="line">jmp ax 执行后 AX=1000H,CS=2000H,IP=1000H CPU会从21000H处读取指令</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，以</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（一）</title>
    <link href="http://example.com/2022/08/09/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/08/09/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-08-09T14:50:10.000Z</published>
    <updated>2022-08-10T11:22:01.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下规定：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li></ol><p>话不多说我们马上开始。</p><h1 id="初识汇编"><a href="#初识汇编" class="headerlink" title="初识汇编"></a>初识汇编</h1><blockquote><p>汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。</p></blockquote><p>早在计算机诞生之初，人们就开始使用机器语言和计算机进行交流了，因为计算机的硬件作为一种电路元件，其输入输出只能是高电平和低电平，所以计算机传递的数据是有“0”和“1”组成的二进制数。二进制的语言就是计算机语言的本质，所有的高级语言诸如JAVA，C++,C#等最终都会转化为一系列的二进制数供计算机阅读，最初的程序员们就是使用这样繁杂的机器语言利用打孔机重复的敲击“0”和“1”在纸带上留下他们奋斗的痕迹。</p><p>但你懂得”011001011010110….“这种东西简直实在折磨人，这么一大串数字要准确无误的输入是不可能的，人们很快的就发现了这一点，为了减轻这样的痛苦，人们对这种机器语言进行了升级改造，用一些简单的容易记忆的单词或者字母来代替一个特定的指令。通过这种办法人们可以很方便的进行编程。就这样汇编语言诞生了。</p><h1 id="汇编在今天"><a href="#汇编在今天" class="headerlink" title="汇编在今天"></a>汇编在今天</h1><p> “啊？！这么老的语言，我学他有什么用啊?我用JAVA,C++,C#不香嘛”，确实发展到今天汇编语言也已经被改进与高级语言相比汇编语言也成为了一种繁杂的编程语言。</p><p><img src="1.jpg" alt="一段输出斐波那契数列的程序转化为汇编语言"></p><p>但实际上汇编语言经历了这么长时间的变革以后，仍然具有一定的影响力。在2022年8月仍能站在前十大编程语言之中。</p><p><img src="2.jpg" alt="2022年8月编程语言排行"></p><p>学习汇编并不是说一定要懂得使用汇编一定从事一个需要汇编的工作，因为汇编语言更接近计算机的底层，学习汇编可以充分的获得底层编程的体验，深刻理解机器运行的机理，这是学习高级语言所不可获得的，学习汇编对于其他计算机核心课程也有帮助。试问任何一个计算机科班出身的人，哪一位不希望了解计算机更原始更基底的奥秘呢？</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>众所周知，CPU是电脑的核心部件，它控制着整个计算机的运行和计算，就像是人的大脑。CPU想进行工作就要为其提供指令和数据，指令和数据就存放在存储器中也就是我们常说的内存（也就是计算机中的内存条）。磁盘不同于内存，磁盘中的数据于指令如果没有被读取到内存中是无法被CPU使用的，故要灵活的使用汇编语言要了解CPU是如何从内存中读取和写入信息的。</p><h2 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h2><p>存储器在计算机眼里会被划分为多个存储单元，一个存储单元可以存储8个bit也就是1B，这些存储单元是通过一定的规则进行编号的，每一个编号就像是一个存储单元的地址一样。CPU想要进行数据的读写就需要这三类信息的交互：</p><ul><li>存储单元的地址（地址信息）</li><li>器件的选择，读或写的命令（控制信息）</li><li>读或写的数据（数据信息）</li></ul><p><img src="3.jpg" alt="CPU对存储器的读写操作"></p><h3 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h3><p>地址总线，线如其名，用于CPU与内存之间传递地址信息用的线的集合就叫做地址总线。地址总线上能传递多少个不同的信息就是可以对多少个存储单元（Byte）进行寻址，一个CPU具有N个地址线那么其就可以传递2的N次幂个内存单元，我们也称这个CPU的地址总线宽度为N，例如10根地址线的CPU，其地址总线宽度为10，其寻址能力为1KB。</p><h3 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h3><p>CPU与内存或者其他器件之间想要进行数据传递那一定是通过数据总线来进行的，数据总线的宽度决定了数据传递的速度，比如8根数据总线一次可以传递1B的数据，那么16根数据总线一次就可以传递2B的数据。这里顺便说一下在整个汇编学习中使用的一般都是十六进制数，因为它和二进制数对应关系更为明显，每4位二进制数就对应1位十六进制数。故由此可知，每2位十六进制数就对应了1B的数据。</p><p><img src="4.jpg" alt="二进制和十六进制"></p><h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h3><p>控制总线就是CPU传递控制信息所用的线的集合，控制总线的宽度代表着CPU对器件的控制能力。</p><h1 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h1><p>什么是内存地址空间呢？内存空间地址大小取决于地址总线的宽度，内存地址空间和CPU的寻址空间大小是一样的为2的N次幂，这些可寻址的内存单元就构成了CPU的内存地址空间。</p><p>现在我们来深入讨论一下什么是内存地址空间。</p><p>首先我们从物理上来理解一下计算机存储，计算机会有很多个存储器，这些存储器从其读写属性上分类实则分为两类：随机存储器（RAM）和只读存储器（ROM），RAM可读可写，但必须带电存储如果关机则其数据也会丢失，而ROM顾名思义，只可以读不可写，关机后数据不会丢失。在计算机各个器件中诸如显卡，网卡等等都含有这些存储器。</p><p><img src="5.jpg" alt="计算机器件中的存储器"></p><p>这些东西从物理上是独立的器件，但实际上它们都通过总线和CPU相连，也就是说其实在CPU眼里大家都是一样的都是内存而已，所以抽象出来一个假想的逻辑存储器叫做内存地址空间。</p><p><img src="6.jpg" alt="假想的逻辑存储器"></p><p>因此，内存地址空间是我们在探讨CPU对于各类电子器件进行信息交流所假想出来的一种工具，方便我们理解CPU是通过对于不同内存地址操作来工作的。</p><h1 id="搭建汇编语言环境"><a href="#搭建汇编语言环境" class="headerlink" title="搭建汇编语言环境"></a>搭建汇编语言环境</h1><ol><li><p>搜索DOSBox，下载对应系统下的DOSBox 并安装 <a href="https://www.dosbox.com/download.php?main=1">戳我</a></p></li><li><p>下载需要的命令文件  <a href="https://pan.baidu.com/s/1tTd2kVeRFqLeCssb6f6QJA?pwd=7iny">戳我</a></p></li><li><p>将下载好的命令文件解压到你所安装的盘符根目录下（安装到D盘就直接解压到D盘中就行）</p></li><li><p>打开C:\Users\29421\AppData\Local\DOSBox 这个路径找到dosbox-0.74-3.conf 文件 在最后输入并保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount d d:\masm</span><br><span class="line"> d:</span><br></pre></td></tr></table></figure></li></ol><p>tips：如果没有AppData需要设置“显示隐藏的文件、文件夹和驱动器”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，以</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>QT编译MYSQL驱动</title>
    <link href="http://example.com/2022/07/14/QT%E7%BC%96%E8%AF%91MYSQL%E9%A9%B1%E5%8A%A8/"/>
    <id>http://example.com/2022/07/14/QT%E7%BC%96%E8%AF%91MYSQL%E9%A9%B1%E5%8A%A8/</id>
    <published>2022-07-14T10:37:46.000Z</published>
    <updated>2022-08-10T01:46:35.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用QT进行C++开发时，会使用到MySQL，但高版本的QT并不支持MySQL（主要因为没有驱动，具体这里的爱恨情仇，博主也不太了解），所以想在QT中使用MySQL要自行手动的编译出MySQL驱动。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在编译我们的MySQL驱动之前需要准备好如下的几项东西</p><p>1.QT<br>2.MySQL<br>3.QT源代码</p><h2 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h2><p>下载好安装器后需要选择自己的组件进行安装，这里必须要有的就是这个sources组件，当然了如果不确定自己是否安装过sources组件或者需要安装可以打开QT安装目录下的MaintenanceTool进行修改。至于编译套件的选择看个人喜好，<strong>但一定一定一定要注意的事情是编译套件的位数必须和MySQL的位数一致否则后续的编译会失败！！</strong>这里博主以编译套件MinGW 11.2.0 64-bit为例子。（PS：一定要记得自己把QT安在哪里了呀！！）</p><p><img src="1.jpg" alt="QT的安装准备"></p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL只需要去官网下载最新版本即可<a href="https://dev.mysql.com/downloads/installer/">戳这里进入MySQL下载界面</a></p><p>下载完成后第一个界面选择Custom</p><p>第二个界面中选择一个MySQL Server进行安装，官方为我们提供了8.0、5.7、5.6三个大版本可以选择</p><p>点开选择的MySQL Server后选择小版本，再次强调<strong>一定一定要选择和编译套件一样位数的MySQL安装。</strong></p><h2 id="QT源码"><a href="#QT源码" class="headerlink" title="QT源码"></a>QT源码</h2><p>准备QT源码之前可以看一看自己QT安装目录下\QT\6.3.1\Src\qtbase\src\plugins\sqldrivers\mysql中是否存在mysql.pro文件，如果没有需要自行下载qt-everywhere-src-6.0.3文件<a href="https://download.qt.io/official_releases/qt/6.0/6.0.3/single/">戳这里进入源码下载界面</a></p><h1 id="编译驱动及配置"><a href="#编译驱动及配置" class="headerlink" title="编译驱动及配置"></a>编译驱动及配置</h1><h2 id="修改项目文件"><a href="#修改项目文件" class="headerlink" title="修改项目文件"></a>修改项目文件</h2><p>解压下载好的QT源码按照\QT\6.0.3\Src\qtbase\src\plugins\sqldrivers\mysql找到mysql.pro文件打开，<strong>使用和MySQL相同位数的编译套件进行编译</strong>，如果你正确的打开文件后那么项目栏应该是这样子滴。 </p><p><img src="2.jpg" alt="项目目录"> </p><p>打开mysql.pro文件进行如下修改</p><p><img src="3.jpg" alt="修改项目文件1"></p><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIBS += -L<span class="string">&quot;C:\Program Files\MySQL\MySQL Server 8.0\lib&quot;</span> -llibmysql</span><br><span class="line">INCLUDEPATH += <span class="string">&quot;C:\Program Files\MySQL\MySQL Server 8.0\include&quot;</span></span><br><span class="line">DEPENDPATH += <span class="attribute">C</span>:\Program Files\MySQL\MySQL Server <span class="number">8.0</span>\include </span><br></pre></td></tr></table></figure><p>这里有一个坑是如果MySQL安装路径中有空格那么LIBS和INCLUDEPATH后的路径一定要用“”（双引号）引起再打开qsqldriverbase.pri文件进行如下修改</p><p><img src="4.jpg" alt="修改项目文件2"></p><p>之后点击左下脚的构建（小榔头图标）</p><h2 id="配置驱动"><a href="#配置驱动" class="headerlink" title="配置驱动"></a>配置驱动</h2><p>你编译好的驱动躺在你安装QT的盘符下的plugins文件夹中，比如博主的QT安装在了D盘，那么只要进入D盘就可以清楚地看见plugins文件夹，在.\plugins\sqldrivers中找到这三个小家伙，他们就是我们历经千辛万苦所编译出来的宝贵驱动文件。</p><p><img src="5.jpg" alt="驱动位置"></p><p>将他们复制粘贴到（你的QT安装的位置）\QT\6.3.1\Src\qtbase\src\plugins\sqldrivers中</p><p><img src="6.jpg" alt="驱动安放位置"></p><p>做到这里恭喜你你已经完成了80%的工作了！！</p><p>打开找到下面两个文件。</p><p><img src="7.jpg" alt="配置sql所需文件1"></p><p>把他们放到你QT安装路径下\QT\6.3.1\mingw_64\bin中</p><p><img src="8.jpg" alt="配置sql所需文件2"></p><p>新建一个QT项目，在第二步的时候将CMake改为qmake。高版本的QT逐渐抛弃了qmake，之后也会考虑出一片文章介绍一下这个事情，不过这里我们还是先用qmake。创建完成后要运行一次程序点击左下角的三角符号运行。</p><p><img src="9.jpg" alt="创建QT项目"></p><p>建好以后会出现两个文件夹。</p><p><img src="10.jpg" alt="创建成功的文件夹"></p><p>接着打开你的MySQL安装路径找到Connector C++ 8.0文件夹打开其中的lib64文件夹找到这两个文件。</p><p><img src="11.jpg" alt="所需要的文件"></p><p>放在.\build-demo-Desktop_Qt_6_3_1_MinGW_64_bit-Debug\debug中</p><p><img src="12.jpg" alt="文件放置位置"></p><p>这一步操作的原因是因为MySql 8.0 之后的版本，提高了客户端和服务器数据通信的安全性，对通信数据做了加密，我们需要添加这两个文件（动态库），这里博主发现了一个现象等你再一次新建一个项目时不添加也可以成功运行一个MySQL程序，可能这就是<del>爱的</del>信任的力量。</p><h1 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h1><p>OK！至此所有编译与配置都已经完成了接下来进行一个简单的测试</p><p>首先打开项目的pro文件在第一行代码最后添加“sql”</p><p><img src="13.jpg" alt="添加sql模块"></p><p>测试代码（全选复制粘贴到mainwindow.cpp，记得修改数据库的密码和数据库的名字）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QtSql/QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlError&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">        QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>);</span><br><span class="line">        db.<span class="built_in">setHostName</span>(<span class="string">&quot;127.0.0.1&quot;</span>); <span class="comment">// 本地连接</span></span><br><span class="line">        db.<span class="built_in">setPort</span>(<span class="number">3306</span>);       <span class="comment">// 如果使用的是默认端口可以不设置</span></span><br><span class="line">        db.<span class="built_in">setUserName</span>(<span class="string">&quot;root&quot;</span>);<span class="comment">// 数据库用户名</span></span><br><span class="line">        db.<span class="built_in">setPassword</span>(<span class="string">&quot;*******&quot;</span>); <span class="comment">// 数据库密码</span></span><br><span class="line">        db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;*******&quot;</span>); <span class="comment">// 数据库名字</span></span><br><span class="line">        <span class="keyword">if</span>(db.<span class="built_in">open</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;打开数据库&quot;</span>, <span class="string">&quot;数据库打开成功, 可以读写数据了......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            QString msg = <span class="string">&quot;数据库打开失败: &quot;</span> + db.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">            QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;打开数据库&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="14.jpg"></p><p>至此QT可以使用MYSQL</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在使用QT进行C++开发时，会使用到MySQL，但高版本的QT并不支持MySQL（主要因为没有驱动，具体这里的爱恨情仇，博主也不太了解），所</summary>
      
    
    
    
    <category term="QT" scheme="http://example.com/categories/QT/"/>
    
    
    <category term="QT" scheme="http://example.com/tags/QT/"/>
    
  </entry>
  
</feed>
