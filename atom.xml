<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuzheng&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-19T13:48:39.461Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>liu zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++面向对象编程（一）</title>
    <link href="http://example.com/2022/10/19/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/10/19/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-10-19T05:33:08.000Z</published>
    <updated>2022-10-19T13:48:39.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>欢迎，各位来到C++面向对象编程的学习，相信各位已经学习过C语言，已经进入到了程序的世界，本课程要求一些c++的基础知识，比如控制流程，循环，指针，引用等等概念，如果清楚可以B站搜索黑马程序员的C++课程，本系列基于侯捷老师的C++课程，为大家讲解C++面向对象的一些知识，同时规范一下程序的书写，事不宜迟，我们马上开始！</p><h1 id="面向过程？面向对象？"><a href="#面向过程？面向对象？" class="headerlink" title="面向过程？面向对象？"></a>面向过程？面向对象？</h1><p>相信各位，在学习C的过程中，一定已经动手写了很多程序了，我们通过写各种函数然后分析事物的指令步骤，依次调用相应的函数去解决问题，这样的操作有一个专有名词叫做面向过程编程，而面向对象编程，从过程中跳出来，将问题处理成转变成一个一个对象，通过对象去做一个行为进而解决问题。可能有的小伙伴还是有点晕，没关系我们举一个例子，写一个五子棋程序：</p><p>面向过程的设计思路就是首先分析问题的步骤：</p><p>1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。</p><p>面向对象的设计则是从事件中各个角色的行为出发来解决问题。</p><p>整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。他们只需要执行自己的行为就可以解决问题。</p><p>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。</p><p>当然我们并不是说面向对象优于面向过程，只是在不同的场合我们选择最为合适的设计。面向过程的性能比较高，面向对象的维护性，复用性，扩展性强。我们要根据场合有选择的使用。</p><h1 id="C-代码的基本形式"><a href="#C-代码的基本形式" class="headerlink" title="C++代码的基本形式"></a>C++代码的基本形式</h1><p>我们在编写代码的时候，建议分文件编写代码，这样的将各个功能模块化可以大大的方便代码的维护、扩展等等。</p><p>我们通常会将我们的类声明写在一个头文件中，其余实现写在另一个cpp中，当我们需要这个类的时候，我们只需要在主文件中使用#include即可使用我们写好的类。我们在编写一个头文件的时候，要记得写防御式声明，这样可以有效地避免头文件被多次引用的问题。防御式声明的语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _头文件名称(大写)_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _头文件名称(大写)_</span></span><br><span class="line">……</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">或者</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure><h1 id="面向对象——类"><a href="#面向对象——类" class="headerlink" title="面向对象——类"></a>面向对象——类</h1><p>在学会面向对象之前，我们要先知道什么是类，可能有的小伙伴会疑问类是什么？为什么面向对象编程要知道类？其实类和对象的关系密不可分，我们举一个例子，这天下的每一个人都是一个对象，我们有各自的名字，各自的性别等等属性，我们也都可以吃饭，可以学习等等，这个被叫做行为(方法)，所以我们将所有人抽象成人类，人类有名字，有性别这些属性，也有吃饭，学习这些行为。所以类就是我们根据实际抽象出来的拥有属性和行为的一个整体，而对象就是由类产出的个例。这就引出了面向对象的第一大特征：“抽象”。我们要学习如何抽象出一个类。类的基本语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">classname</span>             <span class="comment">//这被称为class head</span></span><br><span class="line">&#123;<span class="comment">//从此向下</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">classname</span>();</span><br><span class="line"><span class="function">type <span class="title">functionname1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function">type <span class="title">functionname2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">type <span class="title">functionname3</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    operate+(classname b)&#123; <span class="keyword">this</span>-&gt;属性<span class="number">1</span> += b.属性<span class="number">2</span>; &#125;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> type <span class="title">functionname4</span><span class="params">()</span></span>;</span><br><span class="line">type 属性<span class="number">1</span>;</span><br><span class="line">type 属性<span class="number">2</span>;</span><br><span class="line">……</span><br><span class="line">&#125;;<span class="comment">//从此向上称为class body</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> type <span class="title">functionname4</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以在类内完成函数的实现，也可以在类内声明，类外实现。声明好类以后我们就可以像使用其他基本数据类型一样声明一个对象了。</p><h1 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h1><p>如果你看过从0开始的汇编语言系列，那么你应该知道函数调用的一个过程是什么样子的，实际上函数调用是main函数将CPU的控制权转交给函数，自己停止运行，待函数运行完成将CPU的控制权返回给main函数后，main继续运行。如果函数内容很多，那么这样的转交带来的时间占用可以忽略，但如果函数内容不多，那么程序运行的大部分时间都将被这种转交的过程所占用，所以为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换。这种在函数调用处直接嵌入函数体的函数称为内联函数。实际上类内完成实现的函数都是内联函数，而类外完成的函数不是内敛函数。当然一个函数到最后是否会成为inline函数，我们是不得而知的，我们只能在<strong>函数的定义</strong>前面加上inline关键字，建议编译器将这个函数当做inline函数，至于是否真的会被当做inline函数，编译器要结合程序的复杂程度来确认。</p><h1 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h1><p>可能有的小伙伴已经注意到了，在类的声明中，我们使用了两个关键字public和private，这两个关键字的意思是公有和私有，公有代表可以在任何地方被访问到。私有表示只能在类内被访问。其实还有一种级别叫做protected，我们有序再来研究。</p><p>我们一般将类中数据部分放在private下，这就引出了我们面向对象程序设计的第二大特征：“封装”，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，就像是电视遥控器，我们只需要知道按下音量up键可以使声音变大就好，不需要知道按下按键后到底发生了什么使得音量变大。</p><p>我们在程序设计中要秉承着封装的原则，比如我们将数据放到private下禁止外界随意访问，当外界需要访问或者修改的时候，我们可以对外提供get和set接口。</p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>不知道小伙伴有没有注意到，在上面类的格式中，我们有一个函数很特别它的名字和类名相同，但是没有返回值类型，这个函数会在我们声明一个对象的时候自动调用，这个函数叫做构造函数。</p><p>我们看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classname</span>(type a=<span class="number">0</span>,type b=<span class="number">0</span>……):属性<span class="number">1</span>(a)，属性<span class="number">2</span>(b)……&#123;&#125;</span><br></pre></td></tr></table></figure><p>构造函数有参数，我们可以在参数列表中对这些参数赋值让这些参数变成默认实参，默认实参的意思是当我们声明一个对象的时候，如果我们没有指定对象的属性值，那么就使用默认实参，我们可以看到后面的属性1(a)，这就代表了将a的值赋给属性1，如果我们没有指定a的值，那默认a为0，赋值给属性1，当然这种特殊的语法是构造函数独享的。我们在编写构造函数的时候，要注意将属性初始化。</p><h1 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h1><p>当我们在写成员的行为的时候，我们希望一个行为可以对不同的事情做出不同应对，比如我们吃冰淇淋希望是用勺子挖着吃，吃饺子用筷子夹着吃等等。这个时候我们可以写多个函数比如EatIcecream()，EatDumpings()。但这样有一点麻烦，我们可以通过重载函数的方式解决，重载函数通常用来命名一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。<strong>重载函数要求函数名必须相同，但这些同名函数的指参数的个数、类型或者顺序至少有一个不同。</strong></p><p>几乎所有函数都可以重载，包括构造函数，就比如我们之前写的那条构造函数，我们可以将它重载为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classname</span>():属性<span class="number">1</span>(<span class="number">0</span>)，属性<span class="number">2</span>(<span class="number">0</span>)……&#123;&#125;</span><br></pre></td></tr></table></figure><p>这条代码表示，当我们声明一个对象时不可以指定属性，属性默认为0。编译器会根据我们声明对象的代码决定到底使用哪一个构造函数。</p><h1 id="将构造函数放在private下"><a href="#将构造函数放在private下" class="headerlink" title="将构造函数放在private下"></a>将构造函数放在private下</h1><p>我们要考虑一个问题，我们之前说过private下的无论是属性还是行为都不可以被外界随意访问，但如果我们将构造函数放在了private下呢？我们还可以正常的声明一个对象吗？显然，这是不行的，当我们声明一个对象的时候我们就需要调用构造函数而构造函数被放在了private下不能被访问，那么也就无法创建对象。但这样做有什么意义吗？当然有，这在设计模式中被称为单例模式。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="type">static</span> A a;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">setup</span>()&#123;……&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个经典的单例模式的例子，我们不允许外界声明处一个A类型的对象，我们在getInstance函数中声明一个A类型的对象并将它返回，当我们外界需要使用类A中的setup函数的时候我们可以这样调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A::getInstance().setup();</span><br></pre></td></tr></table></figure><p>我们通过A作用域下的getInstance获得A类对象，然后使用setup函数。</p><p>那么为什么要使用单例模式呢？</p><p>首先单例模式节省公共资源，如果大家都要喝水，但是没必要每人家里都打一口井是吧，通常的做法是整个村里打一个井就够了，大家都从这个井里面打水喝。对应到我们计算机里面，像日志管理、打印机、数据库连接池、应用配置这一类事情都会使用单例模式。其次是单例模式方便控制就像日志管理，如果多个人同时来写日志，你一笔我一笔那整个日志文件都乱七八糟，如果想要控制日志的正确性，那么必须要对关键的代码进行上锁，只能一个一个按照顺序来写，而单例模式只有一个人来向日志里写入信息方便控制，避免了这种多人干扰的问题出现。</p><h1 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h1><p>我们回过头看我们类声明那一部分的代码， 有一个函数后面有const标记，这代表着我这个函数将不会改变任何值，可能有人认为这种东西真的有必要吗？答案是肯定的，当我们在声明一个const的对象的时候，我们规定这个对象的属性不可以被更改，但如果我们调用了一个没有const标记的函数，无论我们这个函数是否修改了属性，编译器都会认为这个函数可能修改属性，这是不被允许的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> v):<span class="built_in">age</span>(v) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">getage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这样的代码将会产生这样的错误：</p><p><img src="1.jpg" alt="常量成员函数的必要"></p><p>只要我们在getage()后面加上const就不会再报这样的错误了。</p><h1 id="传值VS传引用"><a href="#传值VS传引用" class="headerlink" title="传值VS传引用"></a>传值VS传引用</h1><p>C++的函数参数传递方式，可以是传值方式，也可以是传引用方式。传值的本质是：形参是实参的一份复制。传引用的本质是：将我们要传的值所在的地址传输过去。</p><p>当我们要传递一个很大的参数的时候，显然我们先复制再赋值最后再销毁的操作会浪费很多性能，这个时候传递引用显然更为合适。因为传递引用一次只是传输了四个字节。所以我们建议传递参数和返回一个参数的时候，我们多传引用，而不是传值。如果我们是追求速度，不希望我们传递的值被改变，我们可以为引用加上const加以约束。</p><h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><p>在类的声明部分还有一个特殊的关键字值得我们关注，那就是friend，朋友，我们看这个函数直观的感觉它想表达的意思这个函数是这个类的friend，那么C++中的friend可以做什么呢？C++中的friend翻译过来叫做友元，被标记为友元的函数可以直接获取类中的属性。但这样做就打破了我们封装的原则，所以我们在写外部函数访问成员属性的时候，还是尽量的使用类内函数获取。</p><h1 id="相同class的各个objects互为友元"><a href="#相同class的各个objects互为友元" class="headerlink" title="相同class的各个objects互为友元"></a>相同class的各个objects互为友元</h1><p>我们修改之前的代码来解释这一块的内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> v):<span class="built_in">age</span>(v) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addage</span><span class="params">(A &amp;b)</span> </span>&#123; <span class="keyword">return</span> b.age + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">cout&lt;&lt;a.<span class="built_in">addage</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看结果：</p><p><img src="2.jpg" alt="相同class的各个objects互为友元"></p><p>我们可以看到现在类A中有一个addage函数，它接收一个A类对象，并把接收到的对象的age+1返回，可能听起来很正常，但仔细想想我们之前说一个对象的私有属性是不可以被外部随意获取的，那为什么addage函数中可以直接写b.age+1呢？这不符合我们所说的封装啊，这时候就要使用到这一块内容的标题了相同class的各个objects互为友元。也就是说一个类产生出的对象们，都是友元的，也就是大家都是同源的，不存在什么隔阂。</p><h1 id="关于返回引用或者返回值的取舍"><a href="#关于返回引用或者返回值的取舍" class="headerlink" title="关于返回引用或者返回值的取舍"></a>关于返回引用或者返回值的取舍</h1><p>当一个函数中需要使用一个新的变量去存储我们函数的结果的时候，我们一般选择返回值。我们在函数中创建的变量，如果我们返回了它的引用可能会造成程序的错误，我们来看这样一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">RetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=======&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; i = <span class="built_in">RetInt</span>();</span><br><span class="line">    cout &lt;&lt; i&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//split();</span></span><br><span class="line">    cout &lt;&lt; i&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码中RetInt函数返回了i的引用但i是一个局部变量，这个操作是十分危险的，我们来看一下结果：</p><p><img src="3.jpg" alt="返回局部变量的引用1"></p><p>看起来并没有很危险，i的值还是那个值，i的地址还是那个地址看起来没什么不妥，但是如果我们取消注释main函数中的split函数会发生什么呢？我们再看一下结果：</p><p><img src="4.jpg" alt="返回局部变量的引用2"></p><p>i的地址没有发生改变，但是i的值却变得很糟糕，这是为什么？这里要先理解函数调用的过程，我们说调用一个函数要先将函数压入栈中，然后待函数执行完成后弹栈，但这里要注意的是不要把弹栈想象成将函数从栈中移出，弹栈的意思只是栈顶指针向下移动而已，函数还是在栈中，还是那个地址。所以我们在没有另外压入别的函数前，我们都可以正常的访问到局部变量的引用，但是一旦我们重新压入了一个函数，那么我们后压入的函数将覆盖我们原先的函数，这样原先函数里的局部变量将消失，这样我们就没有办法访问到了。所以不要返回一个局部变量的引用，指针同理。</p><h1 id="运算符重载和this指针"><a href="#运算符重载和this指针" class="headerlink" title="运算符重载和this指针"></a>运算符重载和this指针</h1><p>我们可以将两个int相加，当两个数据类型可以转换的时候，我们也可以让它们相加，但如果我们让两个对象相加呢？我们可以写一个行为，它的参数列表是另一个对象，这样当我调用这个行为的时候就可以实现两个对象的相加，但这太麻烦了我们为什么不能用+将两个对象加在一起呢？接下来我们就来看看类声明部分的另一个新鲜事物operate运算符重载，以及它用到的this指针。在C++中我们可以使用operate进行运算符重载，我们赋予这个运算符新的功能，比如下面这些代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> v):<span class="built_in">age</span>(v) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> + (A &amp;b) &#123; <span class="keyword">this</span>-&gt;age += b.age; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">a + b;</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">getage</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下它的结果：</p><p><img src="5.jpg" alt="运算符重载和this指针"></p><p>当我们使用a+b的时候，编译器根据我们的参数类型调用了我们重载之后的+，执行重载+里面的操作，这里有一个新的关键字this，this是一个指针，它指向了当前这个对象本身，我们调用的语句是a+b，那么此时this指向的就是a。所以我们执行的操作就是将a的age加上b的age赋给a的age。所以我们得到了结果17。</p><h1 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h1><p>现在我们思考这样的一个问题，我们现在有三个A类数据，我们要将它们三个加在一起，我们要怎么做呢？可能有的小伙伴认为我们可以直接a+b+c，我们来看一下这样子可以不可以：</p><p><img src="6.jpg" alt="链式编程1"></p><p>看来是不可以的，因为我们重载的+运算符没有返回任何东西，我们不能将一个空的东西和类相加，所以我们需要修改重载+运算符的返回值才可以，我们来看优化后的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> v):<span class="built_in">age</span>(v) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span> + (A&amp; another)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += another.age;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="function">A <span class="title">c</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">a + b + c;</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">getage</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="7.jpg" alt="链式编程2"></p><p>我们得到了正确的结果，这样返回一个对象加入下一次运算的方法我们叫做链式编程，像一个链条一样。运算符重载符合基本的运算规律。</p><h1 id="属于全局函数的运算符重载"><a href="#属于全局函数的运算符重载" class="headerlink" title="属于全局函数的运算符重载"></a>属于全局函数的运算符重载</h1><p>我们知道+是一个双目运算符，它需要两个参数，但是在类中我们本身就是其中一个参数，所以我们的参数列表只有一个值，现在我们将重载运算符搬到类外，变成一个全局函数，这个时候我们的参数列表就应该是两个参数了，我们来看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> v=<span class="number">1</span>):<span class="built_in">age</span>(v) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">A <span class="keyword">operator</span> + (A&amp; one,A&amp; another)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">A</span>(one.<span class="built_in">getage</span>() + another.<span class="built_in">getage</span>());</span><br><span class="line">&#125;</span><br><span class="line">A <span class="keyword">operator</span> + (A&amp; one, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">A</span>(one.<span class="built_in">getage</span>() + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a,b,c,d;</span><br><span class="line">c = a + b;</span><br><span class="line">cout &lt;&lt; c.<span class="built_in">getage</span>() &lt;&lt; endl;</span><br><span class="line">c = a + <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; c.<span class="built_in">getage</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在重载+中使用了一种语法，classname()，这样我们就创建了一个临时的对象，并用两个对象相加得到的值初始化了它，把它返回回来，这里要注意的是我们不是重载+=符号，我们没有空间去存放两个对象相加的值所以只能创建一个新的对象，将它返回回来，这就意味着我们不能返回引用，同时也意味着如果我们希望实现链式编程，那我们的参数列表中要求的参数也要是以值传递的。最后运算符可以发生多次重载，和函数重载相同，要求的是重载同一运算符，但参数列表中参数顺序，参数类型，参数个数(重载加号和正号的区别)至少有一个不同。</p><h1 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h1><p>我们如果需要输出一个类的时候我们可以通过使用类提供的接口来输出，但是如果这个类的属性有很多那我们就要一条一条的输出，很麻烦，所以我们可以重载输出运算符&lt;&lt;来解决这个问题。我们直接看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> v = <span class="number">18</span>, string n = <span class="string">&quot;xiaoming&quot;</span>) :<span class="built_in">age</span>(v),<span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line"><span class="function">string <span class="title">getname</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os,A&amp; another)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> os&lt;&lt; another.<span class="built_in">getname</span>() &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; another.<span class="built_in">getage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意几件事，第一件事是重载&lt;&lt;运算符不能写成一个成员函数，想象一下如果&lt;&lt;成为了成员函数，当我们调用的时候应该是classexample1&lt;&lt;classexample2，这显然不符合我们的预期，我们要的效果是cout&lt;&lt;classexample。所以不可以将重载&lt;&lt;运算符写成一个成员函数，我们要将cout置于&lt;&lt;的左边，所以我们的第一个参数应该是和cout同一类型的，我们查阅资料得知cout的类型为ostream，所以为了实现链式编程，我们返回的类型也是一个ostream类型的引用。</p><p>我们来看一下程序运行的结果：</p><p><img src="8.jpg" alt="链式编程2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;欢迎，各位来到C++面向对象编程的学习，相信各位已经学习过C语言，已经进入到了程序的世界，本课程要求一些c++的基础知识，比如控制流程，循环</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux剑法（第六式）</title>
    <link href="http://example.com/2022/10/17/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E5%85%AD%E5%BC%8F%EF%BC%89/"/>
    <id>http://example.com/2022/10/17/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E5%85%AD%E5%BC%8F%EF%BC%89/</id>
    <published>2022-10-17T11:58:15.000Z</published>
    <updated>2022-10-18T13:32:48.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h1><p>当我们将来走上江湖，我们不止要会这一种剑法，我们还有和其他剑法一起使用，这个时候为了可以更为便捷，更为流畅的使用这些剑法，学会怎么写一个shell脚本是必不可少的，比如我们在进行服务器维护的时候，可能就会需要编写一个脚本来定时备份数据库。</p><h1 id="shell是什么"><a href="#shell是什么" class="headerlink" title="shell是什么"></a>shell是什么</h1><p>知道shell可以做什么了，可是什么是shell呢？shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以通过shell来启动、挂起、停止甚至是编写一些程序。当然Linux不止一个shell，我们常用的是bash。</p><p><img src="1.jpg" alt="shell"></p><h1 id="shell脚本的执行方式"><a href="#shell脚本的执行方式" class="headerlink" title="shell脚本的执行方式"></a>shell脚本的执行方式</h1><p>学习shell和我们学习其他语言是一样的我们先来看一下格式的要求，首先脚本要以**#!/bin/bash<strong>开头，其次脚本要有可执行的权限。脚本常用的执行方式有两种，一是要先赋予我们写好的脚本文件x权限，然后输入脚本的绝对路径或相对路径执行，二是使用</strong>sh 脚本**这个指令来执行。</p><p><img src="2.jpg" alt="执行一个向屏幕输出hello world的程序"></p><h1 id="shell的变量"><a href="#shell的变量" class="headerlink" title="shell的变量"></a>shell的变量</h1><p>之前我们在汇编的学习中提到了，一个有用的程序，多半会存在变量，shell编程也是如此。Linux shell中的变量分为，系统变量和用户自定义变量，系统变量包括$HOME、$PWD、$SHELL、$USER等等，我们可以用<strong>set</strong>指令显示所有变量。</p><p>用户自定义变量的基本语法是：<strong>变量名=值</strong>，注意在Linux中指令对空格的检测很严格，所以一定要仔细看接下来的指令中是否含有空格，这点很重要！当我们需要删除一个变量的时候我们可以使用指令<strong>unset 变量名</strong>来进行销毁，我们还可以声明一个静态变量使用指令<strong>readonly变量</strong>，静态变量不可以被unset销毁掉。当我们输出一个变量的时候我们可以使用指令<strong>echo $A</strong>，注意$符号，当我们定义变量的时候不需要$但输出的时候需要（tips：#表示注释，多行注释为:&lt;&lt;!……!）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">定义一个变量A</span></span><br><span class="line">A=100</span><br><span class="line">:&lt;&lt;!</span><br><span class="line">输出变量需要$</span><br><span class="line">echo指令可以使用“”也可以省略</span><br><span class="line">!</span><br><span class="line">echo A=$A</span><br><span class="line">echo &quot;A=$A&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">撤销变量A</span></span><br><span class="line">unset A</span><br><span class="line">echo A=$A</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">声明静态变量B=2，不能被<span class="built_in">unset</span></span></span><br><span class="line">readonly B=2</span><br><span class="line">echo B=$B</span><br><span class="line">exit 0                                                                    </span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="3.jpg" alt="shell中的变量"></p><p>在高级语言中，变量的定义是有规则的，在shell编程中也不例外，shell编程中，变量的名称可以由字母、数字和下划线组成，但不能以数字开头，变量定义时等号两边不能有空格，变量名称一般习惯为大写。</p><p>当我们希望将一个指令的返回值赋给一个变量，那我们需要使用反引号`（~键）或$()将指令包起来，否则shell认为是将指令本身赋给变量。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">A=date</span><br><span class="line">B=`date`</span><br><span class="line">C=$(date)</span><br><span class="line">echo $A</span><br><span class="line">echo $B</span><br><span class="line">echo $C</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="4.jpg" alt="将指令返回值赋给变量"></p><h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><p>基本语法：export 变量名=变量值，用来将shell变量输出为环境变量（可以理解为全局变量，需要在/etc/profile中定义）</p><p>source 配置文件，用来让修改后的配置信息立即生效</p><p>echo $变量名，用来查询环境变量的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">vim /etc/profile最下面,如果出现swap交换文件输入e即可</span></span><br><span class="line">export myname=liuzheng</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令行中</span></span><br><span class="line">source /etc/profile</span><br><span class="line">echo $myname</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="5.jpg" alt="设置环境变量"></p><h1 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h1><p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量比如./myshell.sh 100 200，这就是一个执行shell的命令行，可以在myshell中获取到参数信息。</p><p>基本语法：</p><p>$n，n为数字，0代表命令本身，1-9代表第一个到第九个参数，十以上的参数需要用大括号包含如：${10}。</p><p>$*，这个变量表示命令行中所有的参数，它把所有参数看成一个整体。</p><p>$@，这个变量也代表命令行中所有参数，不过它把每个参数区分对待。</p><p>$#，这个变量表示命令行中所有参数个数，类似高级语言中main函数的变量argc。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo 0=$0</span><br><span class="line">echo 1=$1</span><br><span class="line">echo 2=$2</span><br><span class="line">echo 所有参数=$*</span><br><span class="line">echo $@</span><br><span class="line">echo 参数个数$#</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="6.jpg" alt="位置参数变量"></p><h1 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h1><p>预定义变量是shell设计者已经实现定义好的变量，可以直接在shell脚本中使用，常用的有三个：</p><ol><li>$$，代表当前进程的进程号PID</li><li>$!，代表后天运行的最后一个进程的进程号PID</li><li>$?，代表最后一次执行的命令的返回状态，如果上一个命令正确执行那么返回的值为0，如果这个值非0着表示上一个命令执行不正确，至于错误后返回的到底是多少，由命令自己决定。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo 当前进程号为$$</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当我们需要在后台执行一个脚本的时候只需要在执行的指令后面加一个&amp;即可</span></span><br><span class="line">sh /home/liuzheng/shell/hello.sh &amp;</span><br><span class="line">echo 后台运行的最后一个进程号为$!</span><br><span class="line">echo 最后一个命令是否成功执行$?</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="7.jpg" alt="预定义变量"></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>我们在学习C语言的时候，肯定做过加法减法的程序，当然这也是计算机最基本的操作了，现在我们在shell中看看如何进行运算。</p><p>基本语法：</p><ol><li>$((运算式))或$[运算式]或者expr m +(-) n(注意格式)</li><li>注意运算符间要有空格</li><li>注意expr中乘法的写法为\*做转义操作</li><li>在使用expr进行运算时，如果要将计算结果赋值给一个变量，需要将运算式用反引号``括起来</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo $[100+200]</span><br><span class="line">A=`expr 100 \* 2`</span><br><span class="line">echo $A</span><br><span class="line">echo $(((2*4)+3))</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="8.jpg" alt="运算符"></p><p>我们也可以通过之前学习的位置参数变量来优化脚本！</p><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>我们在编写一个程序的时候，会对一些事情进行判断，如果满足了某一条件，我们就进行一系列操作，反之我们有别的应对，这个时候就要知道流程控制语句。</p><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>基本语法：if [ condition ]（注意格式，condition前后都有空格）then …… fi，如果非空返回true。</p><p>我们在shell编程中常用的判断条件有四类：</p><p>1.字符串比较</p><ul><li>=</li></ul><p>2.两个整数比较</p><ul><li>-lt 小于</li><li>-le 小于等于</li><li>-eq 等于</li><li>-gt 大于</li><li>-ge 大于等于</li><li>-ne 不等于</li></ul><p>3.按照文件权限进行判断</p><ul><li>-r 有读的权限</li><li>-w 有写的权限</li><li>-x 有执行的权限</li></ul><p>4.按照文件类型进行判断</p><ul><li>-f 文件存在且是一个常规的文件</li><li>-e 文件存在</li><li>-d 文件存在且是一个目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">if [ &quot;ok&quot;=&quot;ok&quot; ]</span><br><span class="line">then</span><br><span class="line">        echo isequal</span><br><span class="line">fi</span><br><span class="line">if [ 21 -ge 22 ]</span><br><span class="line">then</span><br><span class="line">        echo yes</span><br><span class="line">fi</span><br><span class="line">echo exist?</span><br><span class="line">if [ -f /home/liuzheng/shell/hello.sh ]</span><br><span class="line">then</span><br><span class="line">        echo yes</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="9.jpg" alt="if语句"></p><h2 id="if-elif语句"><a href="#if-elif语句" class="headerlink" title="if elif语句"></a>if elif语句</h2><p>我们已经学会了如何使用if，但有的时候判断会进行很多次，这个时候就要用到了else if，所以我们来看一下shell编程中else if是什么样子的。</p><p>基本语法（注意格式）：</p><p>if [ condition ]then …… fi 或者 if [ condition ]then …… elif  [ condition ] then …… fi</p><p>注意[ condition ]，中括号和condition之间必须有空格！！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">if [ $1 -ge 60 ]</span><br><span class="line">then</span><br><span class="line">        echo 及格</span><br><span class="line">elif [ $1 -lt 60 ]</span><br><span class="line">then</span><br><span class="line">        echo 不及格</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="10.jpg" alt="if elif语句"></p><h2 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h2><p>基本语法：</p><p>case $变量名 in 值1 )程序1;; 值2)程序2;; 值3)程序3;;…… * )如果变量的值都不是以上的值，执行本程序;; esac</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">case $1 in</span><br><span class="line">1 )echo monday;;</span><br><span class="line">2 )echo tuesday;;</span><br><span class="line">3 )echo wednesday;;</span><br><span class="line">4 )echo thursday;;</span><br><span class="line">5 )echo friday;;</span><br><span class="line">6 )echo saturday;;</span><br><span class="line">7 )echo sunday;;</span><br><span class="line">* )echo good day!;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="11.jpg" alt="case语句"></p><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>现在我们需要像屏幕上输出1行hello world，你会选择使用echo hello world完成，如果我们需要输出10条，你可能会使用yy，p来完成，可是如果我们需要输出100条甚至更多呢？这个时候就要使用循环。</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>基本语法：</p><p>for 变量 in 值1 值2 值3 … do …… done</p><p>for(( 初始值;循环控制条件;变量变化 ))do……done</p><p>我们这里顺便使用for循环来看一下$*和$@的区别。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo *:</span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">        echo num is $i</span><br><span class="line">done</span><br><span class="line">echo =================</span><br><span class="line">echo @:</span><br><span class="line">for j in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">        echo num is $j</span><br><span class="line">done</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：<img src="12.jpg" alt="for循环1"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">A=0</span><br><span class="line">for (( i=1; i&lt;=100; i++ ))</span><br><span class="line">do</span><br><span class="line">        A=$[$A+$i]</span><br><span class="line">done</span><br><span class="line">echo $A</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：<img src="13.jpg" alt="for循环2"></p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>基本语法：</p><p>while [ 条件判断式 ]do……done，注意while和[之间的空格，条件判断式前后的空格。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">i=0</span><br><span class="line">sum=0</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">        sum=$[$sum+$i]</span><br><span class="line">        i=$[$i+1]</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：<img src="14.jpg" alt="while循环"></p><h1 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h1><p>基本语法：read (选项) (参数) 变量，用来读取键盘输入</p><p>选项：-p：指定读取值时的提示符</p><p>-t：指定读取值时等待的时间(秒)，如果没有在指定的时间输入，就不在等待了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">read -p &quot;请输入数字1&quot; num1</span><br><span class="line">echo &quot;数字1为&quot;$num1</span><br><span class="line">read -t 10 -p &quot;请在10s内输入数字2&quot; num2</span><br><span class="line">echo &quot;数字2为&quot;$num2</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：<img src="15.jpg" alt="read读取控制台输入"></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>shell编程和其它的编程语言一样有函数的存在，函数可以被分为系统函数和自定义函数，接下来我们就来了解一下。</p><h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><p>1.基本语法：basename [pathname] [suffix]</p><p>basename [string] [suffix]</p><p>basename指令会删掉所有的前缀包括最后的一个/字符，然后将字符串显示出来。</p><p>选项：suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。</p><p>结果：<img src="16.jpg" alt="basename指令"></p><p>2.基本语法：dirname 文件绝对路径</p><p>dirname指令从给定的包含绝对路径的文件名中去除文件名，然后返回剩下来的路径。</p><p>结果：<img src="17.jpg" alt="dirname指令"></p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function funname()</span><br><span class="line">&#123;</span><br><span class="line">Action;</span><br><span class="line">[return int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要调用我们的自定义函数的时候，只需要写函数名即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">function getsum()</span><br><span class="line">&#123;</span><br><span class="line">        sum=$[$n1+$n2]</span><br><span class="line">        echo &quot;和为&quot;$sum</span><br><span class="line">&#125;</span><br><span class="line">read -p &quot;输入数字1：&quot; n1</span><br><span class="line">read -p &quot;输入数字2：&quot; n2</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：<img src="18.jpg" alt="自定义函数"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;shell编程&quot;&gt;&lt;a href=&quot;#shell编程&quot; class=&quot;headerlink&quot; title=&quot;shell编程&quot;&gt;&lt;/a&gt;shell编程&lt;/h1&gt;&lt;p&gt;当我们将来走上江湖，我们不止要会这一种剑法，我们还有和其他剑法一起使用，这个时候为了可以更为便捷，更</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux剑法（第五式）</title>
    <link href="http://example.com/2022/10/14/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%94%E5%BC%8F%EF%BC%89/"/>
    <id>http://example.com/2022/10/14/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%94%E5%BC%8F%EF%BC%89/</id>
    <published>2022-10-14T04:55:02.000Z</published>
    <updated>2022-10-17T13:41:44.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux磁盘分区机制"><a href="#Linux磁盘分区机制" class="headerlink" title="Linux磁盘分区机制"></a>Linux磁盘分区机制</h1><p>Linux中只有一个根目录，一个独立且唯一的文件结构，Linux中每一个分区都是用来组成整个文件系统的一部分，Linux采用了一种叫做“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来，这使要载入的一个分区将使它的存储空间在一个目录下获得。 我们可以使用指令<strong>lsblk或lsblk -f</strong>查看分区的挂载情况。</p><p><img src="1.jpg" alt="lsblk挂载情况"></p><h1 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h1><p>Linux硬盘分为IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘，对于IDE硬盘，驱动器标识为“hdx<del>”，其中“hd”表明分区所在设备类型，这里是指IDE硬盘，“x”代表盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从盘），“</del>”表示分区，前四个分区用1-4表示，从5开始是逻辑分区。对于SCSI硬盘，驱动器标识为“sdx~”，和IDE硬盘的表示方法是一样的</p><h1 id="增加磁盘"><a href="#增加磁盘" class="headerlink" title="增加磁盘"></a>增加磁盘</h1><p>接下来我们要增加一块硬盘，熟悉一下磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念。</p><p>1.在虚拟机菜单中，选择设置，然后设备列表中添加硬盘，然后点击下一步，修改好我们新硬盘的大小后下一步，完成后重启系统。</p><p><img src="2.jpg" alt="虚拟机添加硬盘"></p><p>2.重启过后，我们使用lsblk就可以看到我们添加好的硬盘了，接下来我们要为它分区，分区命令为<strong>fdisk 设备名称</strong>，开始分区后输入n，添加新的分区，然后选择p，分区类型为主分区，两次回车默认剩余全部空间，最后输入w写入分区并退出，如果不保存只退出输入q。我们还可以输入m查看命令列表，输入d删除分区。</p><p><img src="3.jpg" alt="为硬盘分区"></p><p>3.第三步，我们要为新的硬盘格式化，分区命令为<strong>mkfs -t ext4 设备名称</strong>。</p><p><img src="4.jpg" alt="为硬盘格式化"></p><p>4.我们之前说过Linux将一个硬盘的存储空间挂载到一个目录上，这样就可以通过访问目录来访问对应的存储空间了，所以我们要将新添加的硬盘挂载到目录上，当然我们要先新建一个目录，这样才可以将硬盘挂载上，这个目录最好在根目录/下。挂载的命令为<strong>mount 设备名称 挂载目录</strong>。</p><p><img src="5.jpg" alt="挂载硬盘"></p><p>5.虽然我们挂载成功了，但是使用命令行挂载在每一次重启后就会失效，这个时候我们需要修改/etc/fstab实现开机自动挂载。</p><p><img src="6.jpg" alt="修改/etc/fstab"></p><p>当我们想将存储空间重新挂载的话，可以使用指令<strong>umount 设备名称 挂载目录</strong></p><h1 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h1><p>现在我们知道如何添加磁盘了，可是我们什么时候添加呢？当然是磁盘的内存不够了的时候添加，可是我们怎么知道磁盘还剩多少内存可以使用呢？我们可以使用指令<strong>df -h</strong>查看。</p><p><img src="7.jpg" alt="df -h指令"></p><p>  除了查看磁盘整体的内存，我们还可以查看指定目录的磁盘占用情况，指令为<strong>du -h /目录</strong>，默认为当前目录，它还有别的选项，这里给出几个常用的-s指定目录占用大小汇总，-h带计量单位，-a含文件，–max-depth=1子目录深度，-c列出明细的同时增加汇总值。</p><p><img src="8.jpg" alt="du指令"></p><h1 id="磁盘情况常用指令"><a href="#磁盘情况常用指令" class="headerlink" title="磁盘情况常用指令"></a>磁盘情况常用指令</h1><p>在我们工作中可能经常要查看磁盘内容，所以学会使用指令可以大大的方便我们的工作。</p><h2 id="统计个数"><a href="#统计个数" class="headerlink" title="统计个数"></a>统计个数</h2><p>当我们需要统计文件的个数的时候我们可以使用我们学过的指令组合实现，我们可以使用ll指令获得所有文件通过grep指令进行过滤最后使用wc来进行统计数目，grep指令支持正则表达式，”^-“就表示了我要所有以-开头的文件，所以整体的指令为<strong>ls -l 文件夹 | grep “^-” | wc -l</strong>。同理我们只要修改正则表达式就可以统计其它类型的文件的个数，比如<strong>ls -l 文件夹 | grep “^d” | wc -l</strong>就表示统计文件夹下目录的个数。如果我们希望统计包括子文件在内的数目的话只需要在ls的选项中加上一个R即可，也就是<strong>ls -lR 文件夹 | grep “^d” | wc -l</strong>。</p><p><img src="9.jpg" alt="统计文件个数"></p><h2 id="以树状显示目录结构"><a href="#以树状显示目录结构" class="headerlink" title="以树状显示目录结构"></a>以树状显示目录结构</h2><p>基本语法：tree 目录</p><p><img src="10.jpg" alt="tree指令在哪？"></p><p>oh！找不到tree指令！真是遗憾，tree指令没有被默认安装，所以如果提示我们找不到tree指令，我们就要手动安装一下，安装指令为yum install tree。安装后我们再次执行这条指令。</p><p><img src="11.jpg" alt="tree指令"></p><h1 id="查看网络IP和网关"><a href="#查看网络IP和网关" class="headerlink" title="查看网络IP和网关"></a>查看网络IP和网关</h1><p>在Windows下我们在命令行中使用ipconfig指令即可查看Windows的网络信息，同样在Linux下我们可以使用ifconfig查看Linux系统的网络信息。我们之前还是用过ping指令来查看网络是否正确连通，ping指令的格式是ping 目的主机，用来检测当前服务器是否可以连接到目的主机。</p><h1 id="设置主机名和hosts映射"><a href="#设置主机名和hosts映射" class="headerlink" title="设置主机名和hosts映射"></a>设置主机名和hosts映射</h1><p>少侠，自古以来的用剑高手，都有一把宝剑流传于江湖之上，我们的剑出厂自带一个名字，我们可以用指令hostname。</p><p><img src="12.jpg" alt="hostname指令"></p><p>这个名字显然不能表达出少侠的英气，不如少侠为剑重新起一个名字吧，我们修改/etc/hostname文件来重新为剑起名，reboot后生效。</p><p><img src="13.jpg" alt="重设主机名1"></p><p><img src="14.jpg" alt="重设主机名2"></p><p>少侠，现在已经为剑取了一个响亮的名字，接下来我们可以通过设置映射，来实现简单的御剑，在Linux下我们可以修改文件/etc/hosts来完成映射，假如我们的pc机叫rog，我们只要在/etc/hosts中写入主机地址 映射名称即可。这样我们可以直接通过ping映射来ping主机。如果没有ping通，可能是因为主机开启了防火墙的原因，关闭即可。</p><p><img src="15.jpg" alt="通过映射ping主机"></p><p>同理我们也可以在Windows下通过修改C:\windows\system32\drivers\etc\hosts文件来设置Linux的映射。</p><h1 id="主机名解析过程"><a href="#主机名解析过程" class="headerlink" title="主机名解析过程"></a>主机名解析过程</h1><p>刚才我们了解了然后进行简单的御剑，接下来我们了解一下其中的原理，首先我们先了解两个名词，hosts，一个文本文件，用来记录IP和hostname的映射关系，DNS，域名系统，是互联网上作为域名和IP地址相互映射的一个分布式数据库。接下来我们就通过访问百度来理解一下这个过程。</p><p>1.当我们在浏览器中输入了百度的网址后，浏览器先检查浏览器缓存中有没有该域名解析IP地址，有就先调用这个IP完成解析，没有就检查操作系统DNS解析器缓存，如果有直接返回IP完成解析，这两个缓存可以理解为本地解析器缓存。</p><p>2.一般来说电脑在第一次成功访问某一个网站后，在一定时间内，操作系统会缓存他的IP地址，我们可以在cmd窗口中输入ipconfig/displaydns来查看缓存，使用ipconfig/flushdns来手动清理缓存。</p><p>3.如果本地解析器没有找到对应的映射，检查系统中hosts文件中有没有配置对应的域名IP映射，如果有，完成解析并返回。</p><p>4.如果本地DNS解析器缓存和hosts文件中均没有找到对应的IP则到域名服务DNS进行解析域，也就是去到公网之上找寻映射。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux磁盘分区机制&quot;&gt;&lt;a href=&quot;#Linux磁盘分区机制&quot; class=&quot;headerlink&quot; title=&quot;Linux磁盘分区机制&quot;&gt;&lt;/a&gt;Linux磁盘分区机制&lt;/h1&gt;&lt;p&gt;Linux中只有一个根目录，一个独立且唯一的文件结构，Linux中每</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux剑法（第四式）</title>
    <link href="http://example.com/2022/10/12/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%BC%8F%EF%BC%89/"/>
    <id>http://example.com/2022/10/12/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%BC%8F%EF%BC%89/</id>
    <published>2022-10-12T09:37:52.000Z</published>
    <updated>2022-10-17T12:33:33.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h1><p>在linux专用每一个用户都要属于一个组，不能独立于组外，就像是我们人生来就属于一个国家。在Linux中每个文件有所有者、所在组、其他组的概念。接下来我们就看看这些概念。</p><h1 id="所有者"><a href="#所有者" class="headerlink" title="所有者"></a>所有者</h1><p>假如我们现在有一个用户jerry，他创建了一个文件hello.txt，那么我们就说这个文件的所有者是jerry，当然jerry也可以将文件转给别的用户比如jack。一般来讲为文件的创建者，谁创建了文件，谁就成为文件的所有者。当然这并不绝对，我们可以使用指令<strong>chown 用户名 文件名</strong>修改文件的所有者，使用<strong>ls -ahl</strong>查看文件的所有者。</p><p><img src="1.jpg" alt="chown指令和ls -ahl指令"></p><h1 id="所在组"><a href="#所在组" class="headerlink" title="所在组"></a>所在组</h1><p>假如用户jerry属于组一，他建立了一个文件hello.txt，那么我们说hello.txt也属于组一，组一就是hello.txt的所在组，组内的其他成员，比如jack，也对文件有一定的权限，去操作文件。当某个用户创建了一个文件后，这个文件的所在组就是用户的所在组。<strong>ls -ahl</strong>同样可以查看文件的所在组，我们可以使用<strong>chgrp 组名 文件名</strong>来修改文件的所在组。</p><p><img src="2.jpg" alt="chgrp指令和ls -ahl指令"></p><h1 id="其他组"><a href="#其他组" class="headerlink" title="其他组"></a>其他组</h1><p>现在我们有了一个属于组一的文件hello.txt但是这个文件并不属于组二，那么我们就说组二是文件hello.txt的其他组，虽然是其他组，但对文件hello.txt也还有一些权限。我们可以更改一个用户的所在组我们之前也讲过只需要使用<strong>usermod -g 组名 用户名</strong>即可，但我们需要注意组一定存在才可以转移进去，我们可以使用<strong>cat查看/etc/group</strong>来看看都存在那些组。我们还可以做的事情是更改用户登录的初始目录，指令是<strong>usermod -d 目录名 用户名</strong>，这样就可以改变用户登录的初始目录了但要注意的是用户需要有进入到新目录的权限才可以。</p><p><img src="3.jpg" alt="查看用户组并修改"></p><h1 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h1><p>我们使用ls -l(ll指令)指令的时候会发现有一串神秘的字符串，其实它就代表了文件的权限。它的每位都有特殊的含义。</p><p><img src="4.jpg" alt="文件权限"></p><p>我们来看看这9位字符都告诉了我们什么，首先是第0位，它确定了文件的类型，-表示普通文件，i相当于链接，相当于Windows的快捷方式，d是目录，相当于Windows的文件夹，c是字符设备文件，像是鼠标、键盘之类的，b是块设备，比如硬盘。其次1-3位确定所有者拥有该文件的权限，r代表可读，w代表可写，对于目录来讲代表可修改，x表示可执行，对于目录来讲就是可进入。在着4-6位确定所属组拥有该文件的权限。最后7-9确定其他用户拥有该文件的权限。在日期前面还有一些数字，这些数字代表文件大小，至于所有者前面的数字代表硬链接数目，一个文件至少一个，一个文件夹至少两个。在Linux中r可以用4代替，w可以用2代替，x可以用1代替，所以全部的权限可以用7代替。</p><h1 id="修改权限chmod指令"><a href="#修改权限chmod指令" class="headerlink" title="修改权限chmod指令"></a>修改权限chmod指令</h1><p>基本语法：</p><p>chmod u=rwx,g=rx,o=x 文件/目录名</p><p>chmod o+w 文件/目录名</p><p>chmod a-x 文件/目录名</p><p>其中u代表所有者，g代表所在组，o代表其他组，a代表所有，也就是u，g，o的总和。我们可以使用+，-，=变更权限。</p><p><img src="5.jpg" alt="chmod指令使用+，-，="></p><p>也可以用数字变更权限</p><p><img src="6.jpg" alt="chmod指令使用数字"></p><h1 id="修改文件所有者chown指令"><a href="#修改文件所有者chown指令" class="headerlink" title="修改文件所有者chown指令"></a>修改文件所有者chown指令</h1><p>基本语法：</p><p>chown [选项] newowner 文件/目录</p><p>chown [选项] newowner:newgroup 文件/目录</p><p>常用选项：-r：如果是目录则使其下所有子文件或目录递归生效。如果对目录使用chown时没有使用-r选项那么其子文件和目录所有者和所有组不变。</p><p><img src="7.jpg" alt="chmod指令使用数字"></p><h1 id="修改文件所在组chgrp指令"><a href="#修改文件所在组chgrp指令" class="headerlink" title="修改文件所在组chgrp指令"></a>修改文件所在组chgrp指令</h1><p>基本语法：</p><p>chgrp [选项] newgroup 文件/目录 改变所在组</p><p>常用选项：-r：如果是目录则使其下所有子文件或目录递归生效。</p><p><img src="8.jpg" alt="chmod指令使用数字"></p><h1 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h1><p>任务调度的意思是指系统在某个时间执行的特定的命令或程序，可以分为系统工作和个别用户工作。系统工作是指有些重要的工作必须周而复始的执行，如病毒扫描。个别用户工作是指个别用户可能希望执行某些程序，比如对MySQL数据库的备份。想象一下当你需要凌晨起来备份一下数据库，这样的事情谁受得了啊！！所以我们要知道怎么使用任务调度代替我们做这样的工作，任务调度会使用crontab指令。</p><p>基本语法：crontab [选项]</p><p>常用选项：-e：编辑crontab定时任务。-l：查询所有crontab任务。-r：删除当前用户所有的crontab任务。</p><p>假设我们现在要每一分钟向文件中写入当前时间，我们可以先在终端中使用crontab -e，进入任务编辑页面，然后输入*/1 * * * *  date&gt;&gt;time.txt（注意空格），之后退出。</p><p><img src="9.jpg" alt="crontab指令"></p><p>看了任务指令，少侠想必一定是一头雾水，这一串**是什么，哎，少侠果然发现了<del>华点</del>盲点，其实这5个 *确实不是常物，第一个 *代表一个小时当中的第几分钟范围是0-59，第二个 *代表了一天当中的第几个小时0-23，第三个 *是一个月中的第几天范围是1-31，第四个 *是一年当中的第几个月范围是1-12，第五个 *是一周当中的星期几范围是0-7(0和7都是星期日)。</p><p>crond任务调度还有一些特殊的符号，比如我们刚才说的“* ”代表任意时间，比如第一个 * 就代表一小时中每分钟都执行一次的意思。“，”代表不连续的时间比如“0 8,12,16 * * * ” 就代表每天的8点0分，12点0分，16点0分都执行一次命令。“- ”代表连续的时间范围比如“0 5 * * 1-6“代表周一到周六的凌晨5点0分执行命令。”*/n“代表每隔多久执行一次比如 ” */10 * * * * “代表每隔10分钟就执行一遍命令。</p><p>我们可以使用service crond restart重启crond，也可以使用service crond stop关闭crond，使用service crond start启动crond。</p><h1 id="at定时任务"><a href="#at定时任务" class="headerlink" title="at定时任务"></a>at定时任务</h1><p>基本语法：at [选项] [时间]，Ctrl+D结束at输入</p><p>at是一次性定时任务，at的守护进程atd会以后台模式进行，检查作业队列来运行，默认情况下，atd守护进程每60秒检查作业队列，有作业的时候，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业，所以我们在使用at指令的时候一定要保证atd进程的启动，我们可以使用<strong>ps -ef | grep atd</strong>，其中ps -ef的作用是显示所有进程。</p><p><img src="10.jpg" alt="ps -ef | grep atd"></p><p>我们可以看到”/usr/sbin/atd -f”这说明atd进程已经被启用了，我们可以使用at指令了。</p><p>选项：-m：当指定任务被完成后，将给用户发邮件。-i：atq的别名。-d：atrm的别名。-v：显示任务将被执行的时间。-c：打印任务的内容到标准输出。-V：显示版本信息。-q&lt;队列&gt;：使用指定的队列。-f&lt;文件&gt;：从指定文件读入任务而不是从标准输入读入。-t&lt;时间参数&gt;：以时间参数的形式提交要运行的任务。</p><p>at指令的时间参数接受在当天的hh:mm(小时:分钟)式的时间指定，这里的小时采用12小时计时法所以要在时间后面加上AM(上午)或PM(下午)，假如这个时间已经过去了那就放在第二天执行。我们还可以使用midnight(深夜)，noon(中午)，teatime(一般是下午4点)等模糊词来指定时间。如果任务需要在某一个具体日期执行我们可以使用month day或mm/dd/yy或dd.mm.yy，指定的日期必须在指定的时间后面。有具体的也有相对的，我们还有相对计时法，格式为now+count time-units，这里time-units表示时间单位，可以是minutes、hours、days、weeks，count表示时间数量。</p><p>我们可以使用atq查看还未执行的任务，使用atrm 编号删除已经设置的任务。</p><p>使用at指令后会进入任务编写，我们可以几条指令，也可以执行一个脚本。</p><p><img src="11.jpg" alt="at定时任务"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组管理和权限管理&quot;&gt;&lt;a href=&quot;#组管理和权限管理&quot; class=&quot;headerlink&quot; title=&quot;组管理和权限管理&quot;&gt;&lt;/a&gt;组管理和权限管理&lt;/h1&gt;&lt;p&gt;在linux专用每一个用户都要属于一个组，不能独立于组外，就像是我们人生来就属于一个国家。在</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux剑法（第三式）</title>
    <link href="http://example.com/2022/10/09/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%89%E5%BC%8F%EF%BC%89/"/>
    <id>http://example.com/2022/10/09/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%89%E5%BC%8F%EF%BC%89/</id>
    <published>2022-10-09T12:07:26.000Z</published>
    <updated>2022-10-12T13:43:00.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux基础操作"><a href="#Linux基础操作" class="headerlink" title="Linux基础操作"></a>Linux基础操作</h1><p>使用linux就和使用Windows是一样的我们要掌握一些基础的操作，才能让我们游刃有余，接下来的内容，死记硬背不是上策，少侠还需勤加锻炼，记住，无他，唯手熟尔。</p><h1 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h1><p>首先我们介绍几条简单的命令用来关机：</p><ol><li>shutdown -h now 立刻关机</li><li>shutdown -h 1 1分钟后关机</li><li>shutdown -r now 现在重新启动</li><li>halt 关机，作用和上面一样</li><li>reboot 现在重新启动</li><li>sync 把内存的数据同步到磁盘</li></ol><p><strong>建议在使用这些指令之前先使用sync同步数据。</strong></p><h1 id="用户登录与注销"><a href="#用户登录与注销" class="headerlink" title="用户登录与注销"></a>用户登录与注销</h1><p>我们在登录的时候建议不使用root登录因为root的权限很大，为了避免误操作，我们一般不选择使用root登录，如果我们需要管理员权限时可以使用命令su来提高权限，在提示符下输入logout即可注销用户，但是要注意的是logout在图形运行级别无效，在运行级别3下有效，我知道少侠可能对运行级别有疑惑，别担心我们这就来讲讲运行级别。</p><h1 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h1><p>Linux中有这样几个运行级别：</p><ul><li><p>0：关机</p></li><li><p>1：单用户（可以用于找回密码）</p></li><li><p>2：多用户状态没有网络服务</p></li><li><p>3：多用户状态有网络服务</p></li><li><p>4：系统未使用保留给用户</p></li><li><p>5：图形界面</p></li><li><p>6：系统重启</p></li></ul><p>其中常用的运行指令是3和5，当然我们也可以使用<strong>systemctl set-default graphical.target(或multi-user.target)<strong>指定默认的运行级别，在运行过程中我们可以使用</strong>init+运行级别</strong>来切换运行级别。</p><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都要先向系统管理员申请一个账户，然后用这个账户进入系统，因此我们要知道如何管理Linux系统下的用户。</p><p>首先是添加用户，命令为<strong>useradd 用户名</strong>，这样我们就可以添加一个用户了，当然也可以使用<strong>useradd -d 指定目录 新的用户名</strong>来给新创建的用户指定home目录。我们可以使用<strong>passwd指令</strong>来更改用户的密码，格式为<strong>passwd 用户名</strong>。之后我们就可以使用不同的用户登录了，我们可以在登录后使用<strong>命令pwd查看当前位置</strong>，来判定我们是否真的登录上了新的用户。</p><p>第二就是删除用户，我们需要管理员权限才可以删除用户，删除用户的命令为<strong>userdel 用户名</strong>，这样我们就可以删除指定用户了，但这样直接删除会保留用户的家目录，如果我们不想保留用户的家目录只需要使用<strong>userdel -r 用户名</strong>即可。我们还可以查看我们用户的信息，语法也很简单为<strong>id 用户名</strong>。</p><p>在着就是切换用户了，我们之前也用过切换用户命令<strong>su -用户名</strong>，当我们从低权限切换成高权限用户时需要输入密码，反之不需要，当我们想返回原来的用户时，使用<strong>exit/logout</strong>指令。我们可以使用命令<strong>who am i</strong>查看当前用户信息。</p><h1 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h1><p>类似于一种角色上的分类，系统可以对有相同权限的多个用户进行统一管理，我们可以通过赋予组权限，为组内用户提供权限。我们如果新增一个组可以使用指令<strong>groupadd 组名</strong>，删除一个组就是<strong>groupdel 组名</strong>，在添加用户时直接加到组里使用<strong>useradd -g 用户组 用户名</strong>。当然我们也可以更改成员所在的组，只需要使用<strong>usermod -g 组名 用户名</strong>即可。</p><h1 id="用户和组相关文件"><a href="#用户和组相关文件" class="headerlink" title="用户和组相关文件"></a>用户和组相关文件</h1><p>这里，我们介绍三个文件：</p><ol><li>/etc/passwd文件：它是用户的配置文件，记录用户的各种信息，每行的含义是用户名：加密口令：用户标识号：组标识号：注释性描述：主目录：登录shell</li><li>/etc/shadow文件：它是口令的配置文件，每行的含义是登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</li><li>/etc/group文件：它是组的配置文件，记录Linux包含的组的信息，每行的含义是组名：口令：组标识号：组内用户目录</li></ol><h1 id="找回root密码"><a href="#找回root密码" class="headerlink" title="找回root密码"></a>找回root密码</h1><p>什么？！少侠你把root密码给忘记了，哎呀呀，这这。。。没事我们可以再找回root密码。</p><p>首先我们重启Linux，在这个页面时按e</p><p><img src="1.jpg" alt="找回root密码1"></p><p>然后上下左右移动光标至linux16开头的那句话末尾并输入init=/bin/sh</p><p><img src="2.jpg" alt="找回root密码2"></p><p>之后按下 Ctrl X启动单用户模式，进入单用户模式后我们需要输入：mount -o remount,rw /，按enter，然后输入passwd重新设置密码和确定密码，如果出现passwd就说明密码修改成功如图：</p><p><img src="3.jpg" alt="找回root密码3"></p><p>接着我们要输入touch /.autorelabel，按回车，最后输入exec /sbin/init，按回车。</p><p><img src="4.jpg" alt="找回root密码4"></p><p>至此root密码就找回来了，这一次少侠别再轻易忘记了。</p><h1 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h1><p>想必少侠也感觉到了，我们到现在为止虽然好像没做什么，但大多数都用到了各种指令，没错linux下我们需要熟练的使用这些指令，这样才方便我们的修炼，所以接下来我们要开始接触各种指令，但在此之前我们先了解一个重要的指令，帮助指令，它就像一个罗盘，少侠要是迷茫了可以使用帮助指令看看命令的帮助信息。</p><p>第一个帮助指令是man [命令或配置文件]，比如man ls，我们可以通过这条指令知道ls命令是做什么的，以及它有没有其他的扩展选项，例如ls -a可以显示所有文件包括以“.”开头的隐藏文件。如果帮助信息很多没有显示完，可以使用space(空格键)翻页。（Tips：ls指令的选项可以叠加使用比如ls -la，单列显示所有文件，la选项不区分先后关系，也可以为al。）</p><p><img src="5.jpg" alt="man ls"></p><p>第二个帮助指令时help 命令，它可以获得shell内置命令的帮助信息。比如help cd。</p><p><img src="6.jpg" alt="help cd"></p><h1 id="文件目录指令"><a href="#文件目录指令" class="headerlink" title="文件目录指令"></a>文件目录指令</h1><p>Linux下一切皆文件，所以我们要想成为高手，就要知道怎么操作文件，所以我们接下来了解一下文件目录指令。</p><h2 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a>pwd指令</h2><p>基本语法：pwd，用来显示当前工作目录的绝对路径。</p><p><img src="7.jpg" alt="pwd指令"></p><h2 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h2><p>基本语法：ls [选项] [目录或是文件]，用来显示当前目录文件。</p><p>常用选项：-a，显示当前目录所有文件和目录，包括隐藏的。-l，以列表的方式显示信息，信息会展示的更为全面。</p><p><img src="8.jpg" alt="ls指令"></p><h2 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h2><p>基本语法：cd [参数]，用来切换到指定目录</p><p>cd~或cd，回到自己的家目录 cd..回到当前目录的上一级目录</p><p><img src="9.jpg" alt="cd指令"></p><h2 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a>mkdir指令</h2><p>基本语法：mkdir [选项] 要创建的目录，用来创建目录</p><p>常用选项：-p，创建多级目录</p><p><img src="10.jpg" alt="mkdir指令"></p><h2 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a>rmdir指令</h2><p>基本语法：rmdir（或rm） [选项] 要删除的空目录，用来删除目录</p><p>注意，因为rmdir删除的是空目录，如果目录下有内容是无法删除的，这个时候要使用rm -rf删除。</p><p><img src="11.jpg" alt="rmdir指令和rm -rf"></p><h2 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h2><p>基本语法：touch 文件名称，用来创建空文件</p><p><img src="12.jpg" alt="touch指令"></p><h2 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a>cp指令</h2><p>基本语法：cp [选项] 文件夹(或文件) 目的地址，用来拷贝文件到指定目录</p><p>常用选项：-r 递归复制整个文件夹</p><p><img src="13.jpg" alt="cp指令"></p><p>当我们重复的将一个文件(文件夹)复制到同一个目录时，就会发生覆盖，这个时候我们需要输入y才可以覆盖文件。当然我们也可以使用\cp [选项] 文件夹(或文件) 目的地址，强制覆盖。</p><p><img src="14.jpg" alt="cp指令覆盖问题"></p><h2 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h2><p>基本语法：rm [选项] 要删除的文件或目录，用来移除文件或目录</p><p>常用选项：-r：递归删除整个文件夹。-f：强制删除不提示</p><p><img src="15.jpg" alt="rm指令"></p><h2 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h2><p>基本语法：</p><p>mv oldfilename newfilename，用来重命名</p><p>mv 文件(文件夹)路径 目的路径，用来移动文件</p><p><img src="16.jpg" alt="mv指令"></p><p>我们也可以在移动文件的同时修改文件名称。</p><h2 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h2><p>基本语法：cat [选项] 要查看的文件，用来查看文件内容</p><p>常用选项：-n：显示行号</p><p><img src="17.jpg" alt="cat指令"></p><p>当然文件往往都有很多行所以为了方便浏览，我们可以加上管道指令|more，例如 cat -n pig.txt |more。</p><h2 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h2><p>基本语法：more 要查看的文件</p><p>more指令是一个基于vi编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干个快捷键。如下图：</p><p><img src="18.jpg" alt="more指令快捷键"></p><h2 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h2><p>基本语法：less 要查看的文件</p><p>less指令用分屏来查看文件内容，它和more类似，当比more更为强大，less对显示大型文件具有较高的效率。</p><p>less相较于more而言，还可以使用/ 关键词来进行搜索，输入n向前查找下一个匹配的文本，输入N向后查找前一个匹配的文本。</p><h2 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a>echo指令</h2><p>基本语法：echo [选项] [输出内容]，用来输出内容到控制台</p><p><img src="19.jpg" alt="echo指令"></p><h2 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h2><p>基本语法：</p><p>head 文件，用来显示文件开头部分，默认为头10行</p><p>head -n 5 文件，用来查看文件头5行内容，5是变数 </p><p><img src="20.jpg" alt="head指令"></p><h2 id="gt-指令和-gt-gt-指令"><a href="#gt-指令和-gt-gt-指令" class="headerlink" title="&gt;指令和&gt;&gt;指令"></a>&gt;指令和&gt;&gt;指令</h2><p>基本语法：</p><p>ls -l&gt;文件，列表的内容写入文件中(覆盖写)</p><p>ls -al&gt;&gt;文件，列表的内容追加到文件的末尾</p><p>cat 文件1&gt;文件2，将文件1的内容覆盖到文件2</p><p>echo “内容”&gt;&gt;文件，将内容写入文件</p><h2 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h2><p>基本语法：</p><p>tail 文件，查看文件尾内容，默认为10行</p><p>tail -n 5 文件，查看文件尾5行内容，5是变数</p><p>tail -f 文件，实时追踪该文档的所有更新，指令执行后监控文件，有新内容写入后立马显示。</p><p><img src="21.jpg" alt="tail指令"></p><h1 id="ln指令"><a href="#ln指令" class="headerlink" title="ln指令"></a>ln指令</h1><p>基本语法：ln -s [原文件或目录] [软链接名]，用来给文件创建一个软链接</p><p>软链接就类似于Windows下的快捷方式，我们为一个文件或目录创造一个软链接，当我们访问这个软链接时就相当于访问原文件或目录。</p><p><img src="22.jpg" alt="ln指令"></p><p>我们可以看到虽然我们通过软链接进入了原文件中，但路径还是软链接的路径，这点要注意。如果我们不想要这个软链接了，我们可以使用rm删除它。</p><h2 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a>history指令</h2><p>基本语法：history，用来查看已经执行过的历史指令。</p><p>你也可以在history后加上一个数字，显示你想显示的后几条指令，比如history 10会显示后十条指令。输入！标号，就可以标号对应指令。</p><p><img src="23.jpg" alt="history指令"></p><h1 id="时间日期指令"><a href="#时间日期指令" class="headerlink" title="时间日期指令"></a>时间日期指令</h1><p>Linux中还有其他功能的指令，比如时间日期指令</p><h2 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a>date指令</h2><p>基本语法：</p><p>date，显示当前时间</p><p>date “+%Y”，显示当前年份</p><p>date “+%m”，显示当前月份</p><p>date “+%d”，显示当前是哪一天</p><p>date “+%Y-%m-%d %H:%M:%S”，显示年月日时分秒</p><p>注意，这里指令的大小写是规定好的，一定要按照上述大小写输入。</p><p><img src="24.jpg" alt="date指令"></p><h2 id="date-s指令"><a href="#date-s指令" class="headerlink" title="date -s指令"></a>date -s指令</h2><p>基本语法：date -s 时间(字符串)</p><p>我们可以使用这个指令修改当前系统的时间。</p><h2 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h2><p>基本语法：cal [选项]</p><p>选项：-m：显示星期一作为一周的第一天，-y：显示当前年份的日历。</p><p><img src="25.jpg" alt="cal指令"></p><p>还可以使用cal+年份，显示指定年份的日历。</p><h1 id="查找指令"><a href="#查找指令" class="headerlink" title="查找指令"></a>查找指令</h1><p>我们在使用Linux的过程中，使用查找指令可以大大的方便我们的工作。</p><h2 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h2><p>基本语法：find [搜索范围] [选项]，用来从指定目录下递归地遍历其各个子目录，将满足条件的显示在终端。</p><p>选项：-name&lt;查询方式&gt;，按照指定的用户名查找模式查找文件。-user&lt;用户名&gt;，查找属于指定用户名所有文件。-size&lt;文件大小&gt;，按照指定的文件大小查找文件。</p><p><img src="26.jpg" alt="find指令"></p><h2 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h2><p>基本语法：locate 搜索文件，同样是用来查找文件的，但是locate指令可以快速定位文件路径。</p><p>注意，由于locate指令基于数据库进行查询，所以第一次运行前，要使用updatedb指令创造locate数据库。</p><p><img src="27.jpg" alt="locate指令"></p><h2 id="grep指令和管道符号"><a href="#grep指令和管道符号" class="headerlink" title="grep指令和管道符号|"></a>grep指令和管道符号|</h2><p>基本语法：grep [选项] 查找内容 源文件，用于过滤查找。管道符“|”表示将前一个命令的处理结果输出传递给后面的命令处理。两者多联合使用。</p><p>选项：-n：显示匹配行及行号。-i忽略字母大小写。</p><p><img src="28.jpg" alt="grep指令和|"></p><h2 id="which指令"><a href="#which指令" class="headerlink" title="which指令"></a>which指令</h2><p>基本语法：which 可执行文件名称，用来查看可执行文件的位置</p><p><img src="29.jpg" alt="which指令"></p><h1 id="压缩和解压指令"><a href="#压缩和解压指令" class="headerlink" title="压缩和解压指令"></a>压缩和解压指令</h1><p>我们在处理文件的时候也少不了压缩和解压的过程，Linux为我们提供了这样的指令。</p><h2 id="gzip-gunzip指令"><a href="#gzip-gunzip指令" class="headerlink" title="gzip/gunzip指令"></a>gzip/gunzip指令</h2><p>基本语法：</p><p>gzip 文件，用来压缩文件，只能将文件压缩为.gz格式</p><p>gunzip 文件，用来解压缩文件</p><p><img src="30.jpg" alt="gzip/gunzip指令"></p><h2 id="zip-unzip指令"><a href="#zip-unzip指令" class="headerlink" title="zip/unzip指令"></a>zip/unzip指令</h2><p>基本语法：</p><p>zip [选项] xxx.zip，用来压缩文件和目录</p><p>unzip [选项] xxx.zip，用于解压缩文件</p><p>zip常用选项：-r：递归压缩，即压缩目录</p><p>unzip常用选项：-d&lt;目录&gt;：指定压缩后文件的存放位置</p><p><img src="31.jpg" alt="zip/unzip指令"></p><h2 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h2><p>基本语法：tar [选项] xxx.tar.gz 打包内容，用来打包目录</p><p>选项：-c：产生.tar打包文件。-v：显示详细信息。-f：指定压缩后的文件名。-z：打包同时压缩。-x：解包.tar文件。</p><p><img src="32.jpg" alt="tar指令"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux基础操作&quot;&gt;&lt;a href=&quot;#Linux基础操作&quot; class=&quot;headerlink&quot; title=&quot;Linux基础操作&quot;&gt;&lt;/a&gt;Linux基础操作&lt;/h1&gt;&lt;p&gt;使用linux就和使用Windows是一样的我们要掌握一些基础的操作，才能让我们游刃</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux剑法（第二式）</title>
    <link href="http://example.com/2022/10/05/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%BC%8F%EF%BC%89/"/>
    <id>http://example.com/2022/10/05/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%BC%8F%EF%BC%89/</id>
    <published>2022-10-05T07:57:54.000Z</published>
    <updated>2022-10-12T13:25:51.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h1><p>Linux讲究的是一切皆文件，在Windows下是文件的东西，在Linux中也是，在Windows下不是文件的东西，比如套接字，进程，甚至是硬件设备，在Linux下还是文件，你可以通过访问文件的方式来获取它们的信息，所以说要记住Linux下一切皆文件。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p><img src="1.jpg" alt="Linux目录结构"></p><p>Linux目录结构十分重要，要熟练的掌握。接下来我们来看一看这些目录都是用来做什么的：</p><ol><li>/bin：bin是Binaries(二进制文件)的缩写，这个目录存放着最经常用的命令。</li><li>/sbin：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</li><li>/home：存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名。</li><li>/root：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li>/lib：系统开机所需要最基本的动态连接共享库，就类似于Windows下的DLL文件。几乎所有的应用程序都需要用到这些共享库</li><li>/lost+found：这个目录是一个被隐藏的目录，一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li>/etc：所有的系统管理所需要的配置文件和子目录。</li><li>/usr：这是一个非常重要的目录，用户很多的应用程序和文件都放在这个目录下，类似Windows的program files目录。</li><li>/boot：存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li>/proc：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。不要动它，可能导致系统崩溃。</li><li>/srv：service缩写，该目录存放一些服务启动后需要提取的数据。不要动它，可能导致系统崩溃。</li><li>/sys：这是Linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。不要动它，可能导致系统崩溃。</li><li>/tmp：用来存放一些临时文件。</li><li>/dev：类似Windows的设备管理器，把所有的硬件用文件的形式存储。</li><li>/media：Linux系统会自动识别一些设备，例如光驱，U盘等等，当识别后，Linux会把识别的设备挂载到这个目录下。</li><li>/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt上，然后进入该目录就可以查看里面的内容了。</li><li>/opt：这是主机额外安装软件用到的目录，默认为空。</li><li>/user/local：这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码方式安装的程序。</li><li>/var：这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。</li><li>/selinux：SELinux是一种安全子系统，它能控制程序只访问特定文件，有三种工作模式，可自行设定。</li></ol><h1 id="远程登录linux"><a href="#远程登录linux" class="headerlink" title="远程登录linux"></a>远程登录linux</h1><p>在公司里，linux服务器是开发小组共享的，正式上线的项目是运行在公网之上的，因此程序员需要远程登录到linux进行项目管理或开发，所以我们要知道如何远程登录linux。当然我们远程登录也需要工具，一个是Xshell6，一个是Xftp6。<a href="https://www.xshell.com/zh/free-for-home-school/">戳我下载</a></p><p>安装好后，我们开始使用Xshell，首先我们如果想远程登录linux，就要先知道linux的IP地址，我们可以在linux中断中输入ifconfig来查看IP地址。<img src="2.jpg" alt="查看IP地址"></p><p>之后我们打开Xshell新建一个连接，名称可以随便取，但主机一定是我们刚才拿到的主机号</p><p><img src="3.jpg" alt="建立连接"></p><p>之后会有一个弹窗，我们选择接受并保存。这样我们就可以使用Xshell远程登录linux了。</p><h2 id="远程文件传输"><a href="#远程文件传输" class="headerlink" title="远程文件传输"></a>远程文件传输</h2><p>我们现在已经可以远程登录linux了，但我们知道linux下一切皆文件，文件的使用方法之一就是传输，所以我们还要知道怎么进行远程文件传输，这就要使用另一个工具了Xftp。</p><p>Xftp和Xshell相通，还是建立连接即可。左侧是windows文件系统，右侧是linux文件系统。</p><p><img src="4.jpg" alt="成功建立连接"></p><p>这里有的少侠可能就发现了，这个页插画怎么如此难懂，这是什么文字，少侠稍安勿躁，我们只需要点击上方地球按钮，选择Unicode就可以解决这个问题了。</p><p><img src="5.jpg" alt="解决乱码"></p><h1 id="vi和vim"><a href="#vi和vim" class="headerlink" title="vi和vim"></a>vi和vim</h1><p>我们知道Linux一切皆文件，文件大多数都应该是可以更改的，所以Linux系统内置了vi文本编辑器，vim也是一个文本编辑器，不过vim具有程序编辑的能力，可以看做是Vi的增强版本，可以主动以字体颜色辨别语法的正确性，方便程序设计。代码补完，编译以及错误跳转等功能丰富。</p><h2 id="vi和vim常用的三种模式"><a href="#vi和vim常用的三种模式" class="headerlink" title="vi和vim常用的三种模式"></a>vi和vim常用的三种模式</h2><p>vi和vim有三种常用模式分别是正常模式、插入模式、命令行模式。</p><p>首先是正常模式，以vim打开一个档案就直接进入了一般模式了。在这个模式中可以使用上下左右移动光标，删除字符，复制粘贴等操作处理文件数据。</p><p>之后是插入模式，按下i，I，o，O，A，R，r都可以进入插入模式，但一般习惯按i，按esc可以退出插入模式，回到正常模式。</p><p>最后是命令行模式，在正常模式下，当我们输入“：”就可以切换为命令模式，在这个模式中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等动作。</p><p><img src="6.jpg" alt="三种模式及切换方法"></p><h2 id="vi和vim快捷键"><a href="#vi和vim快捷键" class="headerlink" title="vi和vim快捷键"></a>vi和vim快捷键</h2><p>首先是基本的复制与粘贴操作，我们在正常模式下敲击yy就可以拷贝当前行，之后按p就可以粘贴当前行了，如果需要多行复制可以敲击数字加yy比如敲击5yy就可以复制当前行向下5行。有复制粘贴就会有删除，还是在正常模式下按dd就可以删除当前行，同样也可以进行多行删除操作。同样我们还有撤销操作，在正常模式下按u即可撤销。</p><p>我们还可以查找一个文本文件中的某个单词，我们在<strong>命令行模式</strong>下只需要使用“/关键字”，回车即可查找，输入n就是查找下一个。我们还可以使用<strong>“set nu”</strong>和<strong>“set nonu”</strong>显示和隐藏行号。我们也可以快速的转到最首行快捷键是gg，快速转到最末行<strong>G（shift+g）</strong>当然这个操作要在<strong>正常模式</strong>下进行。还有一个操作就是快速的转到某一行，比如我想转到20行只需要在正常模式下敲击<strong>2+0+shift+g</strong>即可，不过要注意的是<strong>20不要用键盘的小键盘输入</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一切皆文件&quot;&gt;&lt;a href=&quot;#一切皆文件&quot; class=&quot;headerlink&quot; title=&quot;一切皆文件&quot;&gt;&lt;/a&gt;一切皆文件&lt;/h1&gt;&lt;p&gt;Linux讲究的是一切皆文件，在Windows下是文件的东西，在Linux中也是，在Windows下不是文件的东西，</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux剑法（第一式）</title>
    <link href="http://example.com/2022/10/04/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%80%E5%BC%8F%EF%BC%89/"/>
    <id>http://example.com/2022/10/04/Linux%E5%89%91%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%80%E5%BC%8F%EF%BC%89/</id>
    <published>2022-10-04T05:39:16.000Z</published>
    <updated>2022-10-05T07:54:59.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要习得此剑法？"><a href="#为什么要习得此剑法？" class="headerlink" title="为什么要习得此剑法？"></a>为什么要习得此剑法？</h1><p>当今世界，强者纵横，Linux被广泛使用，自掌门Linus Benedict Torvalds开宗立派之后，便将此剑法广布天下，如今也成为了晋升强者道路上的一门必修功法。Linux安全性高，内核稳定，具有完善的开发和调试工具，如今Linux也被广泛的使用在超级计算机、服务器、PC机、手机、嵌入式系统中，尤其是服务器开发，此剑法可谓上乘之选。而且我们未来学习其他功法，可能也需要懂得此套剑法。少侠，何不现在开始？</p><h1 id="工欲善其事，必先利其器"><a href="#工欲善其事，必先利其器" class="headerlink" title="工欲善其事，必先利其器"></a>工欲善其事，必先利其器</h1><p>在学习剑法之前，必然是选择一柄上好的武器，恰好，我这里有京中著名工匠所铸的长剑剑柄<a href="https://download3.vmware.com/software/WKST-1624-WIN/VMware-workstation-full-16.2.4-20089737.exe">VMware</a>，剑刃<a href="https://pan.baidu.com/s/1u0tuBRRYBqOgHEloVUJ4xA?pwd=whmk">centOS7</a>，还有一个密匙ZF3R0-FHED2-M80TY-8QYGC-NPKYF，一并赠与少侠，但。。。还需要少侠亲自组装一下。不用担心，我给少侠带来了安装说明书，如下：</p><p>1.取出VMware，安装在我们的电脑上，如果你直接安装成功可以去看第二步了，如果你没安装成功，可能是需要开启CPU虚拟化，开启虚拟化首先要根据你的电脑型号上网查找按哪个键进入BIOS，然后重启电脑，在重启的过程中狂按那个键，待进入BIOS界面后进入BIOS后，找到Configuration，选择Intel Virtual Technology（或AMD Virtual Technology）按回车，将光标移至Enabled，然后再回车，最后按F10保存并退出。</p><p>2.安装好VMware后，我们要将centOS7映像文件下载下来。</p><p>3.打开VMware，点击创建新的虚拟机，依次执行下列操作，选中典型、下一步、选中稍后安装操作系统、下一步、选中Linux、在版本的下拉菜单中选择Red Hat Enterprise Linux 7 64位、下一步、为你的剑取一个心仪的名字、选择放在一个喜欢的位置、下一步、下一步。</p><p>4.点击自定义硬件，选择处理器，这个时候我们要先确定自己电脑有几个CPU，总共有几个内核，我们点开任务管理器，点击性能，点击打开资源监视器，我们可以看到一个进程栏和一个任务栏，这证明我们的电脑有两个CPU，把右边拉到最下面可以看到一个CPU15，这证明我们总共有16个内核，也就是一个CPU有8个内核。所以我们可以选择分配给虚拟机2个CPU，每一个CPU分配4个内核，毕竟我们还要给母机本身留一点内核，这样我们就分配给虚拟机了2个CPU和总共8个内核。</p><p><img src="1.jpg" alt="资源监视器"></p><p>5.点击关闭、完成，右键新建好的虚拟机，点击设置，点击CD/DVD，选择使用ISO映像文件，选中下载好的centOS7映像文件，点击确定。</p><p>6.开启创建好的虚拟机，选中Install CentOS7，回车。</p><p><img src="2.jpg" alt="安装CentOS7"></p><p>7.进入之后我们选择中文，点击软件选择，按照下图选择配置，点击完成。</p><p><img src="3.jpg" alt="配置选择"></p><p>8.点击安装位置，选择我要配置分区，点击完成，我们最开始分配给了虚拟机一共20G的内存，现在我们要对这20G内存进行分区，点击加号，添加/boot分区1G，/swap分区2G，/分区17G。将三个分区的设备类型更改为标准分区，将/boot分区和/分区文件系统修改为ext4。</p><p><img src="4.jpg" alt="内存分区"></p><p>9.点开网络和主机名，开启网络连接，点击完成</p><p>10.之后我们开始安装，这个过程中我们可以设置Root密码，创建一个新的用户，因为Linux主张使用普通用户登录，当然你也可以在登录界面点击未登录，输入用户名Root和Root密码登录。安装结束后重启虚拟机，同意许可信息。</p><p>至此安装过程完毕，少侠得到了一柄好剑，江湖之旅即刻开始。</p><h1 id="网络连接的三种模式"><a href="#网络连接的三种模式" class="headerlink" title="网络连接的三种模式"></a>网络连接的三种模式</h1><p><img src="5.jpg" alt="网络连接"></p><p>这一小段，我们认识一下网络的三种连接方式，分别是桥接模式，NAT模式，仅主机模式。首先我们根据图片可以知道，主机A、B、C都处在一个网段之中，所以他们之间可以相互通讯。</p><p>主机A的虚拟机采用的是桥接模式，所以虚拟机和主机处于同一网段，故此A的虚拟机可以和外界比如B的主机，相互连通。但是这样的连通方式存在一个问题，我们要知道，在一个网段中，只能存在255个IP。所以一旦有大量的主机创建了虚拟机，并且选用了桥接模式，就会造成IP冲突。</p><p>我们再看C，C主机的虚拟机是NAT模式，C主机上会生成一个对应的虚拟IP地址(如192.168.100.66 )，虚拟机的IP会和对应的虚拟IP地址相互通讯，C主机的虚拟机IP通过C主机的IP代理来与外部网络通讯，在内网和外网通讯的同时，外网与内网不在同一个网段中。但内网和外网的通讯是单向的，也就是虚拟机网络可以和外网沟通，但外网无法和虚拟机网络沟通。</p><p>最后，仅主机模式就是一个独立的系统，和外部不发生通讯。</p><h1 id="虚拟机克隆"><a href="#虚拟机克隆" class="headerlink" title="虚拟机克隆"></a>虚拟机克隆</h1><p>当我们已经安装了一个Linux系统了，但因为种种原因，我们还需要更多的系统，我们就可以使用虚拟机克隆，我们可以直接使用VMware的克隆操作。注意，在克隆的时候要先关闭Linux系统。</p><p><img src="6.jpg" alt="虚拟机克隆"></p><p>我们右键安装好的Linux系统，找到管理、克隆，之后下一步即可。当然这里面还有一个要注意的地方那就是链接克隆和完整克隆。</p><p><img src="7.jpg" alt="链接克隆和完整克隆"></p><p>链接克隆的意思就好比创建一个引用，我们点击开启连接克隆后的系统和原系统是一样的，只不过我们给原系统起了一个别名。完整克隆的意思是我们真真正正的克隆一个独立的系统和原系统没有瓜葛。</p><h1 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h1><p>当我们在虚拟机中进行操作的时候，可能会有一些危险操作可能会导致系统崩溃，这个时候我们可以使用虚拟机快照，如果系统崩溃可以快速的将Linux系统恢复到我们拍摄快照的时间点。我们右键点击系统，找到快照，点击拍摄快照，这样我们就建立好了一个快照。当我们未来需要恢复的时候可以选择快照管理器，选择回溯到某一个快照的时间节点。</p><p><img src="8.jpg" alt="虚拟机快照"></p><h1 id="虚拟机的迁移和删除"><a href="#虚拟机的迁移和删除" class="headerlink" title="虚拟机的迁移和删除"></a>虚拟机的迁移和删除</h1><p>我们知道虚拟系统在我们主机里面本质上就是一个文件，所以虚拟机的迁移只需要把安装好的虚拟系统这个文件夹整体拷贝或者剪切到目的地即可，删除也很简单只需要在VMware中点击菜单，点击从磁盘中删除即可，或者我们可以直接删除虚拟系统的文件夹，当然如果你选择在VMware中删除虚拟机，要记得先把虚拟机关掉。注意，VMware中的移除，只是将虚拟系统的指向从列表中移除了并不是真正的将虚拟系统从硬盘中删除了。</p><p><img src="9.jpg" alt="虚拟机删除"></p><h1 id="安装VMTools"><a href="#安装VMTools" class="headerlink" title="安装VMTools"></a>安装VMTools</h1><p>VMTools的安装可以让我们更好的在主机中管理VM虚拟机，可以设置Windows和CentOS的共享文件夹。安装方法也很简单，如下：</p><p>1.首先开启我们的Linux系统，点击上方选项卡中的虚拟机，点击安装VMTools或者再次安装VMTools，当然当你安装完虚拟系统后，在下方黄色提示条中会提示你安装VMTools，点击那个安装也可以。</p><p><img src="10.jpg" alt="安装VMTools(1)"></p><p>2.之后我们在Linux的桌面上可以看到一个光盘图标，叫做VMware Tools，我们双击打开</p><p><img src="11.jpg" alt="安装VMTools(2)"></p><p>3.打开后我们可以看到一个压缩文件xx.tar.gz，我们将它拷贝到/opt下（点击其他位置，点击计算机就可以找到opt啦，如果你无法粘贴到/opt下可能是因为你的权限不够需要使用root登录，如果还不可以那粘贴到主文件夹也是可以的）</p><p>4.接下来我们右键点击Linux桌面，打开终端依次输入如下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt    [cd指令的意义是进入一个文件夹中，这里只需要进入xx.tar.gz所在文件夹即可]</span><br><span class="line">tar -zxvf xx.tar.gz (根据你的文件名填写，可以输入VM然后按tab键自动补全)</span><br><span class="line">cd vm(按tab自动补全)</span><br><span class="line">./vmware-install.pl</span><br></pre></td></tr></table></figure><p>之后只要一直按回车，全都使用默认设置即可。</p><p>安装好VMTools后我们来设置共享文件夹，首先我们在Windows系统下找一个地方建立好我们用来共享的文件夹。之后我们右键我们的虚拟系统点击设置，在上方选择选项，点击共享文件夹，点击总是启用，点击添加，添加完成后点击确定即可。之后我们回到Linux中点击其他位置点击计算机点击mnt文件夹，点击hgfs，就可以看到我们的共享文件夹啦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要习得此剑法？&quot;&gt;&lt;a href=&quot;#为什么要习得此剑法？&quot; class=&quot;headerlink&quot; title=&quot;为什么要习得此剑法？&quot;&gt;&lt;/a&gt;为什么要习得此剑法？&lt;/h1&gt;&lt;p&gt;当今世界，强者纵横，Linux被广泛使用，自掌门Linus Benedict</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十七）</title>
    <link href="http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <id>http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/</id>
    <published>2022-09-23T07:05:15.000Z</published>
    <updated>2022-10-03T11:44:09.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="int-9中断例程对键盘输入的处理"><a href="#int-9中断例程对键盘输入的处理" class="headerlink" title="int 9中断例程对键盘输入的处理"></a>int 9中断例程对键盘输入的处理</h1><p>大多数有用的程序都需要处理用户的输入，键盘的输入是最为基本的输入。程序和数据通常需要长期存储，磁盘是最常用的存储设备。BIOS为这两种外设的I/O提供了最基本的中断例程，接下来我们就对它们的应用和相关的问题进行讨论。</p><p>我们之间已经学习过，键盘的输入将引发9号中断，BIOS提供了int 9中断例程。CPU在9号中断发生后，执行int 9中断例程，从60H端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。</p><p>一般的键盘输入，在CPU执行完int 9中断例程后，都放到了键盘缓冲区中，键盘缓冲区有16个字单元，可以储存15个按键的扫描码和对应的ASCII码，接下来我们就从逻辑层面看一下键盘输入的扫描码和对应的ASCII码是如何写入键盘缓冲区的。事实上，键盘缓冲区是用环形队列结构管理的内存区。</p><p>下面想象这样一个场景，我们按下了键盘上的A，B，C，D，E，Shift_A，A。我们来简要的看一下int 9中断例程都做了什么叭！</p><p>1.初始状态下，没有键盘输入，键盘缓冲区空，此时没有任何元素。</p><p><img src="1.jpg" alt="键盘缓冲区内容"></p><p>2.按下A键，引发了键盘中断，CPU执行int 9中断例程，从60H端口读出A键的通码；然后检测状态字节，看看是否有Shift，Ctrl等切换键按下；发现没有切换键按下，就将A键的扫描码1eH和对应的ASCII码，即字母“a”的ASCII码61H，写入键盘缓冲区。缓冲区的字单元中，高位字节存储扫描码，低位字节存储ASCII码。此时缓冲区内容如下。</p><p><img src="2.jpg" alt="键盘缓冲区内容"></p><p>3.按下B键，引发了键盘中断，CPU执行int 9中断例程，从60H端口读出B键的通码；然后检测状态字节，看看是否有切换键按下；发现没有切换键按下，就将B键的扫描码30H和对应的ASCII码，即字母“b”的ASCII码62H，写入键盘缓冲区,此时缓冲区内容如下。</p><p><img src="3.jpg" alt="键盘缓冲区内容"></p><p>4.按下C，D，E键后，缓冲区中的内容如下。</p><p><img src="4.jpg" alt="键盘缓冲区内容"></p><p>5.按下左Shift键，引发键盘中断；int 9中断例程接收左Shift的通码，设置0040:17处的状态字节的第1位为1，表示左Shift按下。</p><p>6.按下A键，引发了键盘中断，CPU执行int 9中断例程，从60H端口读出A键的通码；然后检测状态字节，看看是否切换键按下；发现左Shift被按下，就将A键的扫描码1eH和Shift_A对应的ASCII码，即字母“A”的ASCII码41H，写入键盘缓冲区。此时缓冲区内容如下。</p><p><img src="5.jpg" alt="键盘缓冲区内容"></p><p>7.松开左Shift键，引发键盘中断；int 9中断例程接收左Shift的断码，设置0040:17处的状态字节的第1位为0，表示左Shift松开。</p><p>8.按下A键，引发了键盘中断，CPU执行int 9中断例程，从60H端口读出A键的通码；然后检测状态字节，看看是否切换键按下；发现没有切换键按下，就将A键的扫描码1eH和对应的ASCII码，即字母“a”的ASCII码61H，写入键盘缓冲区。缓冲区的字单元中，高位字节存储扫描码，低位字节存储ASCII码。此时缓冲区内容如下。</p><p><img src="6.jpg" alt="键盘缓冲区内容"></p><h1 id="使用int-16H中断例程读取键盘缓冲区"><a href="#使用int-16H中断例程读取键盘缓冲区" class="headerlink" title="使用int 16H中断例程读取键盘缓冲区"></a>使用int 16H中断例程读取键盘缓冲区</h1><p>BIOS提供了int 16H中断例程供程序员调用。int 16H中断例程中包含的一个最重要的功能是从键盘缓冲区读取一个键盘输入，该功能编号为0。下面的指令从键盘缓冲区读取一个键盘输入，并且将其从缓冲区中删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ah,0</span><br><span class="line">int 16H</span><br></pre></td></tr></table></figure><p>结果是(ah)=扫描码，(al)=ASCII码。接下来我们看一下int16H如何读取键盘缓冲区。</p><p>1.执行上述两条指令后，缓冲区中的内容如下：</p><p><img src="7.jpg" alt="键盘缓冲区内容"></p><p>2.再次执行，缓冲区中内容如下：</p><p><img src="8.jpg" alt="键盘缓冲区内容"></p><p>3.连续执行5次后，缓冲区为空：</p><p><img src="1.jpg" alt="键盘缓冲区内容"></p><p>4.再次执行，int 16H检测到键盘缓冲区，发现缓冲区为空，则循环等待，直到缓冲区中有数据。</p><p>5.按下A键后，缓冲区中的内容如下：</p><p><img src="9.jpg" alt="键盘缓冲区内容"></p><p>6.循环等待的int 16H中断例程检测到键盘缓冲区中有数据，将其读出，缓冲区又为空。</p><p><img src="1.jpg" alt="键盘缓冲区内容"></p><p>ah中内容为1EH，al中内容为61H</p><p>从上面我们可以看出，int 16中断例程的0号功能，进行如下的工作：</p><ol><li>检测键盘缓冲区中是否有数据</li><li>没有则继续做第一步</li><li>读取缓冲区第一个字单元中的键盘输入</li><li>将读取的扫描码送入ah，ASCII码送入al</li><li>将已读取的键盘输入从缓冲区中删除</li></ol><p>可见，BIOS的int 9中断例程和int 16H中断例程是一对相互配合的程序，int 9中断例程向键盘缓冲区中写入，int 16H中断例程从缓冲区中读出。它们写入和读出的时机不同，int 9中断例程是在有键按下的时候向键盘缓冲区中写入数据；而int 16H中断例程是在应用程序对其调用的时候，将数据从键盘缓冲区中读出。我们在编写一般的处理键盘输入的程序的时候，可以调用int 16H从键盘缓冲区中读取键盘的输入。</p><h1 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h1><p>用户通过键盘输入的通常不仅仅是单个字符而是字符串。最基本的字符串输入程序，需要具备下面的功能：</p><ol><li>在输入的同时需要显示这个字符串</li><li>一般在输入回车符后，字符串输入结束</li><li>能够删除已经输入的字符</li></ol><p>接下来我们试着编写一个接收字符串输入的子程序，实现上面3个基本功能。因为在输入的过程中需要显示，子程序的参数如下：</p><p>(dh)、(dl)=字符串在屏幕上显示的行、列位置；ds:si指向字符串的存储空间，字符串以0为结尾符。</p><p>首先，我们要先解决字符的输入和删除，每个新输入的字符都存储在前一个输入的字符之后，而删除是从最后面的字符进行的，这一点可以想象我们平时输入输出的场景。可以知道字符的输入和输出是按照栈的访问规则进行的，即后进先出。这样，我们就可以用栈的方式来管理字符串的存储空间，也就是说字符串的存储空间实际上是一个字符栈。字符栈中的所有字符，从栈底到栈顶，组成一个字符串。第二，我们要在输入回车符后，结束这个字符串，这个很好实现，我们可以在输入回车符后在字符串中加入0，表示字符串结束。最后，我们在输入字符串的同时要显示这个字符串，也就是每次有新的字符输入和删除一个字符的时候，都应该重新显示字符串，即从字符栈的栈底到栈顶，显示所有的字符。</p><p>现在我们可以简单地确定程序的处理过程：</p><ol><li>调用int 16H读取键盘输入</li><li>如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行1</li><li>如果是退格键，就从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行1</li><li>如果是enter键，向字符栈中压入0，返回</li></ol><p>可见整个过程中，字符出栈，入栈，显示的操作很频繁，应该写成子程序。完整的接收字符串输入的子程序，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">getstr:push ax</span><br><span class="line">getstrs:mov ah,0</span><br><span class="line">int 16H</span><br><span class="line">cmp al,20H</span><br><span class="line">jb nochar</span><br><span class="line">mov ah,0</span><br><span class="line">call charstack</span><br><span class="line">jmp getstrs</span><br><span class="line">nochar:cmp ah,0eH</span><br><span class="line">je backspace</span><br><span class="line">cmp ah,1cH</span><br><span class="line">je enther</span><br><span class="line">jmp getstrs</span><br><span class="line">backspace:mov ah,1</span><br><span class="line">call charstack</span><br><span class="line">jmp getstrs</span><br><span class="line">enter:mov al,0</span><br><span class="line">mov ah,0</span><br><span class="line">call charstack</span><br><span class="line">mov ah,2</span><br><span class="line">call charstack</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line">charstack:jmp short charstart</span><br><span class="line">table dw charpush,charpop,charshow</span><br><span class="line">top dw 0</span><br><span class="line">charstart:push bx</span><br><span class="line">push dx</span><br><span class="line">push di</span><br><span class="line">push es</span><br><span class="line">cmp ah,2</span><br><span class="line">ja sret</span><br><span class="line">mov bl,ah</span><br><span class="line">mov bh,0</span><br><span class="line">add bx,bx</span><br><span class="line">jmp word ptr table[bx]</span><br><span class="line">charpush:mov bx,top</span><br><span class="line">mov [si][bx],al</span><br><span class="line">inc top</span><br><span class="line">jmp sret</span><br><span class="line">charpop:cmp top,0</span><br><span class="line">je sret</span><br><span class="line">dec top</span><br><span class="line">mov bx,top</span><br><span class="line">mov al,[si][bx]</span><br><span class="line">jmp sret</span><br><span class="line">charshow:mov bx,0b800H</span><br><span class="line">mov es,bx</span><br><span class="line">mov al,160</span><br><span class="line">mov ah,0</span><br><span class="line">mul dh</span><br><span class="line">mov di,ax</span><br><span class="line">add dl,dl</span><br><span class="line">mov dh,0</span><br><span class="line">add di,dx</span><br><span class="line">mov bx,0</span><br><span class="line">charshows:cmp bx,top</span><br><span class="line">jne noempty</span><br><span class="line">mov byte ptr es:[di],&#x27; &#x27;</span><br><span class="line">jmp sret</span><br><span class="line">noempty:mov al,[si][bx]</span><br><span class="line">mov es:[di],al</span><br><span class="line">mov byte ptr es:[di+2],&#x27; &#x27;</span><br><span class="line">inc bx</span><br><span class="line">add di,2</span><br><span class="line">jmp charshows</span><br><span class="line">sret:pop es</span><br><span class="line">pop di</span><br><span class="line">pop dx</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h1 id="应用int-13H中断例程对磁盘进行读写"><a href="#应用int-13H中断例程对磁盘进行读写" class="headerlink" title="应用int 13H中断例程对磁盘进行读写"></a>应用int 13H中断例程对磁盘进行读写</h1><p>我们主要以3.5英寸软盘为例，3.5英寸软盘分为上下两面，每面80个磁道，每个磁道又分为18个扇面，每个扇面区的大小为512字节。所以3.5英寸软盘大约是1.44MB。磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘，只能以扇区为单位对磁盘进行读写。在读写扇区的时候，要给出面号，磁道号和扇区号。面号和磁盘号从0开始，而扇区号从1开始。BIOS提供了一些中断例程可以访问磁盘，比如int 13H。如果我们想读取0面0道1扇区的内容到0:200，那么程序是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200H</span><br><span class="line">mov al,1</span><br><span class="line">mov ch,0</span><br><span class="line">mov cl,1</span><br><span class="line">mov dl,0</span><br><span class="line">mov dh,0</span><br><span class="line">mov ah,2</span><br><span class="line">int 13H</span><br></pre></td></tr></table></figure><p>其中，(ah)表示int 13H的功能号，(al)表示读取的扇区数，(ch)表示磁道号，(cl)表示扇区号，(dh)表示磁头号(对于软盘即面号，因为一个面用一个磁头来读写)，(dl)表示驱动器号软驱从0开始，0：软驱A，1：软驱B，硬盘从80H开始，80H：硬盘C，81H：硬盘D。如果操作成功(ah)=0，(al)=读入的扇区数，如果操作失败(ah)=出错代码。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此，汇编的学习告一段落，感谢各位能耐心阅读！更新完整个系列后有一种如释重负的感觉，好像完成了一件大事一样，虽然只是学完了一本书。博主也只是一个在校大学生，刚刚开始写博客，所有内容都是一点点看书，选择性记录的，虽然看起来还是有点像搬运，而且很古板粗糙。。。不过至少整个过程还是有收获滴！接下来，博主也会慢慢的写一写其他的系列，最后再次感谢，可以耐心看本系列的朋友们，我们下个系列见！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十六）</title>
    <link href="http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <id>http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/</id>
    <published>2022-09-23T07:04:03.000Z</published>
    <updated>2022-10-02T12:20:03.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="描述了单元长度的标号"><a href="#描述了单元长度的标号" class="headerlink" title="描述了单元长度的标号"></a>描述了单元长度的标号</h1><p>我们之前，一直在代码段中使用标号来标记指令、数据、段的起始地址。比如，下面的代码将code段中的a标号处的8个数据累加，结果储存到b标号处的字中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">a: db 1,2,3,4,5,6,7,8</span><br><span class="line">b: dw 0</span><br><span class="line">start:mov si,offset a</span><br><span class="line">mov bx,offset b</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov al,cs:[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add cs:[bx],ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>程序中，code、a、b、start、s都是标号。这些标号仅仅表示了内存单元的地址。我们还可以使用另一种符号，这种符号不仅可以表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。上面程序还可以写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">start:mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov al,a[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add b,ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>在code段中使用的标号a、b后面没有”:”，它们是同时描述内存单元长度和内存地址的标号。标号a，描述了地址code:0，和从这个地址开始，以后的内存单元都是字节单元；而标号b描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元。</p><p>因为这种标号包含了对单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。比如，对于程序中的”b dw 0”：</p><p>指令：mov ax,b 相当于：mov ax,cs:[8]</p><p>指令中，标号b代表了一个内存单元，地址为code:8，长度为两个字节。如果使用指令mov al,b就会引起编译错误，因为b代表的内存单元是字单元。我们称这种标号为数据标号，它标记了存储数据的单元的地址和长度。</p><h1 id="在其他段中使用数据标号"><a href="#在其他段中使用数据标号" class="headerlink" title="在其他段中使用数据标号"></a>在其他段中使用数据标号</h1><p>一般来说，我们不会在代码段里面定义数据，而是将数据定义到其他段中，在其他段中我们也可以使用数据标号来描述存储数据的单元的地址和长度。不过需要注意的是在后面加有“：”的地址标号，只能在代码段中使用，不能在其他段中使用。下面的程序将data段中a标号处的8个数据累加，结果存储到b标号处的字中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov al,a[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add b,ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mob ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>之前我们说将我们定义的段和相关的寄存器使用伪指令assume联系起来，比如上面的程序中我们就讲cs和code段，ds和data段联系在了一起。之所以这样做是因为我们后来在代码段中使用了数据标号，也就是说当我们将数据定义到其他段中后，想要在代码段使用数据标号就必须使用伪指令assume将段和段寄存器联系起来，否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中，当然这种联系是编译器需要的，但绝对不是说，我们因为编译器的工作需要，用assume指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。所以我们为了程序可以正确访问data段，我们会在代码段的开始使用指令，设置ds指向data段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure><p>我们可以将标号当做数据来定义，此时，编译器将标号所表示的地址当作数据的值，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>数据标号c处存储的两个字型数据为标号a、b的偏移地址相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw offset a,offset b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dd a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>数据标号c处存储的两个双字型数据为标号a、b的偏移地址和段地址相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw offset a,seg a,offset b,seg b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>seg操作符功能为获取某一个标号的段地址。</p><h1 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h1><p>接下来我们通过一个问题引入这个小节的学习，我们现在要编写一个子程序，以十六进制的形式在屏幕中间显示给定的字节型数据。首先一个字节需要两个十六进制数来表示，那我们可以将一个字节的高四位和低四位分开，分别用它们的值得到对应的数码字符。比如2BH，我们可以得到高四位的2和低四位的11，但我们怎么能得到对应的数码字符呢？</p><p>最简单的方法就是一个一个比较，0就是0,1就是1……10就是A,11就是B，但这样有太麻烦了，有太多的比较指令和转移指令了。我们要在0-15和0-F之间找到一种映射关系。</p><p>0-9和字符“0”-“9“的关系显而易见：数值+30H=对应字符的ASCII值，同样我们也可以知道10-15和”A“-”F“之间的对应关系：数值+37H=对应字符的ASCII值。现在我们就可以将数值转换为字符了，因为映射关系存在差异，我们要判断数值是否大于9。</p><p>虽然已经简化很多了，但人嘛，总是追求最简单，最省力的办法，因为0-15和字符“0”-“F”之间没有一致的映射关系存在，所以我们应该在它们之间建立新的映射关系。具体做法是建立一张表，表中依次存放字符“0”-“F”,我们可以通过数值0-15直接查找到对应的字符。子程序如下，其中使用al传送要显示的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">showbyte:jmp short show</span><br><span class="line">table db &#x27;0123456789ABCDEF&#x27;</span><br><span class="line">show:push bx</span><br><span class="line">push es</span><br><span class="line">mov ah,al</span><br><span class="line">shr ah,1</span><br><span class="line">shr ah,1</span><br><span class="line">shr ah,1</span><br><span class="line">shr ah,1;右移4位，ah中得到高四位的值</span><br><span class="line">and ah,00001111b;al中为低四位的值</span><br><span class="line">mov bl,ah</span><br><span class="line">mov bh,0</span><br><span class="line">mov ah,table[bx];用高四位的值作为相对于table的偏移，取得对应的字符</span><br><span class="line">mov bx,0B800H</span><br><span class="line">mov es,bx</span><br><span class="line">mov es:[160*12+40*2],ah</span><br><span class="line">mov bl,al</span><br><span class="line">mov bh,0</span><br><span class="line">mov al,table[bx];用低四位的值作为相对于table的偏移，取得对应的字符</span><br><span class="line">mov es:[160*12+40*2+2],al</span><br><span class="line">pop es</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>可以看到我们在子程序中，使用了一个表建立了两个集合之间的关系，这样做的目的一般有以下三个：</p><ol><li>为了算法的清晰和简洁</li><li>为了加快运算速度</li><li>为了使程序易于扩充</li></ol><p>我们的程序通过给出的数据进行比较而得到的结果的问题，转化为用给出的数据作为查表的依据，通过查表得到结果的问题。具体的查表方法，是用查表的依据数据，直接计算出所要查找的元素在表中的位置。像这种可以通过依据数据，直接计算出所要找的元素的位置的表，我们称其为直接定址表。</p><h1 id="程序入口地址的直接定址表"><a href="#程序入口地址的直接定址表" class="headerlink" title="程序入口地址的直接定址表"></a>程序入口地址的直接定址表</h1><p>我们可以在直接定址表中存储子程序的地址，从而方便地实现不同子程序的调用。假设我们现在有四个子程序a，b，c，d，我们可以将这四个子程序的入口地址存储到一个表中，它们在表中的位置和功能号相对应。对应关系为：功能号*2=对应功能子程序在地址表中的偏移。程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setscreen:jmp short set</span><br><span class="line">table dw a,b,c,d</span><br><span class="line">set:push bx</span><br><span class="line">cmp ah,3</span><br><span class="line">ja sret</span><br><span class="line">mov bl,ah</span><br><span class="line">mov bh,0</span><br><span class="line">add bx,bx</span><br><span class="line">call word ptr table[bx]</span><br><span class="line">sret:pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>我们通过使用直接定址表，根据功能号调用对应子程序的做法，使程序结构清晰，便于扩充，如果我们未来想要加入一个新的功能只需要在地址表中加入它的入口地址就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十五）</title>
    <link href="http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/</id>
    <published>2022-09-23T07:03:55.000Z</published>
    <updated>2022-10-02T08:50:41.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h1><p>我们知道CPU不仅仅只有运算功能，它还有I/O（Input/Output，输入/输出）能力，比如我们打开文本编辑器，按一下键盘，然后我们就可以看到屏幕出现了我们按下的按键，是CPU将从键盘上的键所对应的字符送到显示器上的。要及时处理外设的输入，显然需要解决两个问题：</p><ol><li>外设的输入可能随时发生，CPU怎么知道呢？</li><li>CPU从何处得到外设的输入？</li></ol><p>这一篇我们就以键盘输入为例，讨论这两个问题。</p><h1 id="接口芯片和端口"><a href="#接口芯片和端口" class="headerlink" title="接口芯片和端口"></a>接口芯片和端口</h1><p>第14篇我们讲过，PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片内部有若干个寄存器，CPU将这些寄存器当做端口来访问。外设的输入不直接进入内存和CPU而是先进入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。CPU还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。可见，CPU通过端口和外部设备进行联系。</p><h1 id="外中断信息"><a href="#外中断信息" class="headerlink" title="外中断信息"></a>外中断信息</h1><p>我们知道外设的输入被放到了端口里，那CPU如何及时的知道并处理呢？CPU提供中断机制来满足这种需求，前面说过，CPU内部有需要处理的事情发生的时候，将产生中断信息，引发中断过程。中断信息来自CPU内部。还有一种中断信息，来自于CPU外部，当CPU外部有需要处理的事情发生时，比如说外设的输入到达。这个时候相关芯片会向CPU发出相应的中断信息。CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。在PC系统中，外中断源一共分为一下两种。</p><h2 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h2><p>可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。当CPU检测到可屏蔽中断信息时，如果IF=1，则CPU在执行完当前指令后响应中断，引发中断过程，如果IF=0,则不响应可屏蔽中断。</p><p>我们来回忆一下内中断所引发的中断过程：</p><ol><li>取中断类型码N</li><li>标志寄存器入栈，IF=0，TF=0</li><li>CS、IP入栈</li><li>(IP)=(n×4)，(CS)=(n×4+2)</li></ol><p>由此转去执行中断处理程序。</p><p>可屏蔽中断所引发的中断过程，除在第1步的是实现上有所不同外，基本上和内中断一样。因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；而内中断的中断类型码是在CPU内部生成的。</p><p>现在我们就可以解释为什么中断过程中要设置IF为0了，因为在进入中断处理程序之后，禁止其他的可屏蔽中断。当然，如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置为1。8086CPU提供了两条指令设置IF分别是：</p><ol><li>sti，设置IF=1</li><li>cli，设置IF=0</li></ol><h2 id="不可屏蔽中断"><a href="#不可屏蔽中断" class="headerlink" title="不可屏蔽中断"></a>不可屏蔽中断</h2><p>不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前的指令后，立即响应，引发中断过程。对于8086CPU，不可屏蔽中断的中断过程类型码固定为2，所以中段过程中，不需要取中断类型码。所以不可屏蔽中断的中断过程为：</p><ol><li>标志寄存器入栈，IF=0，TF=0</li><li>CS、IP入栈</li><li>(IP)=(8)，CS=(0AH)</li></ol><p>几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件（比如说键盘输入）发生时，相关芯片向CPU发出可屏蔽中断信息。不可屏蔽中断是在系统中有必须处理的紧急情况发生时来通知CPU的中断信息。我们主要讨论可屏蔽信息。</p><h1 id="PC机键盘的处理过程"><a href="#PC机键盘的处理过程" class="headerlink" title="PC机键盘的处理过程"></a>PC机键盘的处理过程</h1><p>我们接下来看一下键盘输入的处理过程，并以此来体会一下PC机处理外设输入的基本方法。</p><h2 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h2><p>键盘上的每一个键就相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60H。当我们松开这个键的时候，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也会被送到端口60H中。</p><p>一般来说将按下一个键时产生的扫描码叫做通码，松开一个键时产生的扫描码叫做断码，扫描码的长度为一个字节，通码的第7位为0，断码的第7位为1，即断码=通码+80H。</p><h2 id="引发9号中断"><a href="#引发9号中断" class="headerlink" title="引发9号中断"></a>引发9号中断</h2><p>当键盘的输入到达60H端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。CPU检测到该中断信息后，如果IF=1，则响应中断，引发中断过程，转去执行int 9中断例程。</p><h2 id="执行int-9中断例程"><a href="#执行int-9中断例程" class="headerlink" title="执行int 9中断例程"></a>执行int 9中断例程</h2><p>BIOS提供了int 9中断例程，用来进行基本的键盘输入处理，主要工作如下：</p><ol><li>读出60H端口中的扫描码</li><li>如果是字符键的扫描码，将该扫描码和它所对应的字符码，也就是ASCII码送入内存中的BIOS键盘缓冲区；如果是控制键(比如Ctrl)和切换键(比如CapsLock)的扫描码，则将其转变为状态字节(用二进制位记录控制键和切换键状态的字节)写入内存中储存状态字节的单元。</li><li>对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。</li></ol><p>BIOS键盘缓冲区是系统启动后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区。该内存区可以储存15个键盘输入，因为int 9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，低位字节存放字符码。0040:17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下：</p><p><img src="1.jpg" alt="键盘状态字节各位记录的信息"> </p><h1 id="安装新的int-9中断例程"><a href="#安装新的int-9中断例程" class="headerlink" title="安装新的int 9中断例程"></a>安装新的int 9中断例程</h1><p>接下来我们要安装一个新的int 9中断例程，使原来的int 9中断例程功能得到扩展。我们的任务是在DOS下，按F1键后改变当前屏幕的显示颜色，其他键照常处理。首先我们分别思考几个问题：</p><p>1.改变屏幕的显示颜色</p><p>改变从B800H开始的4000个字节中的所有奇地址单元中的内容，当前屏幕的显示颜色即发生改变。程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0B800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,1</span><br><span class="line">mov cx,2000</span><br><span class="line">s:inc byte ptr es:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>2.其他键照常处理</p><p>可以调用原int 9中断处理程序，来处理其他的键盘输入</p><p>3.原int 9中断例程入口地址的保存</p><p>因为在编写新的int 9中断例程中要调用原int 9中断例程，所以，要保存原int 9中断例程的入口地址。要保存在哪里？显然不能保存在安装程序中，因为安装程序返回后地址将丢失。我们将地址保存在0:200单元处。</p><p>4.新int 9中断例程的安装</p><p>我们可以将新的int 9中断例程安装在0:204处。</p><p>完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,128</span><br><span class="line">push cs</span><br><span class="line">pop ds</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,offset int9;设置ds:si指向源地址</span><br><span class="line">mov di,204H;设置es:di指向目的地址</span><br><span class="line">mov cx,offset int9end-offset int9;设置cx为传输长度</span><br><span class="line">cld;设置传输方向为正</span><br><span class="line">rep movsb</span><br><span class="line">push es:[9*4]</span><br><span class="line">pop es:[200H]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop es:[202H]</span><br><span class="line">cli</span><br><span class="line">mov word ptr es:[9*4],204H</span><br><span class="line">mov word ptr es:[9*4],0H</span><br><span class="line">sti</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">int9:push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">in al,60H</span><br><span class="line">pushf</span><br><span class="line">call dword ptr cs:[200H]</span><br><span class="line">cmp al,3bH</span><br><span class="line">jne int9ret</span><br><span class="line">mov ax,0b800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,1</span><br><span class="line">mov cx,2000</span><br><span class="line">s:inc byte ptr es:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">int9ret:pop es</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line">int9end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这一篇我们通过对键盘输入的处理，讲解了CPU对外设输入的通常处理方法。即：</p><ol><li>外设的输入送入端口</li><li>向CPU发出外中断(可屏蔽中断)信息</li><li>CPU检测到可屏蔽中断信息，如果IF=1，CPU在执行完当前指令后响应中断，执行响应的中断处理程序</li><li>可在中断例程中实现对外设输入的处理</li></ol><p>端口和中断机制，是CPU进行I/O的基础。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十四）</title>
    <link href="http://example.com/2022/09/22/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://example.com/2022/09/22/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/</id>
    <published>2022-09-22T15:26:07.000Z</published>
    <updated>2022-09-23T07:01:38.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>我们前面讲过，各种存储器都和CPU的地址线、数据线、控制线相连。CPU在操控它们的时候，把它们都当作内存来看待，把它们总地看做一个由若干存储单元组成的逻辑存储器，这个逻辑存储器我们称其为内存地址空间。</p><p>在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有一下三种芯片：</p><ol><li>各种接口卡上的接口芯片，它们控制接口卡进行工作</li><li>主板上的接口芯片，CPU通过它们对部分外设尽心访问</li><li>其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。</li></ol><p>这些芯片都有一组可以由CPU读写的寄存器。这些寄存器，它们在物理上可能处于不同的芯片中，但是它们在以下两点上相同：</p><ol><li>都和CPU的总线相连，当然这种连接是通过它们所在的芯片进行的</li><li>CPU对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令。</li></ol><p>可见，从CPU的角度，将这些寄存器都当作端口，对它们统一编址，从而建立了一个统一的端口地址空间。每一个端口都在地址空间中有一个地址。</p><p>CPU可以从以下三个地方直接读写数据：</p><ol><li>CPU内部的寄存器</li><li>内存单元</li><li>端口</li></ol><p>这篇我们就讨论一下端口的读写。</p><h1 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h1><p>在访问端口的时候，CPU通过端口地址定位端口。因为端口所在的芯片和CPU通过地址总线相连，所以，端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口。则端口地址的范围为0~65535。</p><p>对于端口的读写就不能使用mov、push、pop等内存读写指令了，端口的读写指令只有两条：in和out，分别对应从端口读取数据和向端口写入数据。</p><p>我们看一下CPU执行内存访问指令和端口访问指令时，总线上的信息：</p><p>（1）访问内存：</p><p>mov ax,ds:[8]    </p><p>假设执行前(ds)=0，那么执行时与总线相关的操作如下所示：</p><ol><li>CPU通过地址线将地址信息8发出</li><li>CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据</li><li>存储器将8号单元中的数据通过数据线送入CPU</li></ol><p>（2）访问端口：</p><p>in al，60H</p><p>这条指令代表从60H端口读入一个字节，那么执行时与总线相关的操作如下：</p><ol><li>CPU通过地址线将地址信息60H发出</li><li>CPU通过发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据</li><li>端口所在的芯片将60H端口中的数据通过数据线送入CPU</li></ol><p>注意，在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位端口时用ax。</p><p>对0~255以内的端口进行读写时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20H</span><br><span class="line">out 20H,al</span><br></pre></td></tr></table></figure><p>对255~65535以内的端口进行读写时,端口号放在dx中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h;将端口号3f8h送入dx</span><br><span class="line">in al,dx;从3f8h端口读入一个字节</span><br><span class="line">out dx,al;向3f8h端口写入一个字节</span><br></pre></td></tr></table></figure><h1 id="CMOS-RAM芯片"><a href="#CMOS-RAM芯片" class="headerlink" title="CMOS RAM芯片"></a>CMOS RAM芯片</h1><p>下面，我们通过对CMOS RAM芯片的读写体会一下对端口的访问。首先我们介绍一下CMOS RAM芯片，这个芯片其中包含一个实时钟和一个有128个存储单元的RAM存储器（早期的计算机为64个字节）。该芯片靠电池供电。所以，关机后其内部的实时钟仍可以工作，RAM中信息不会丢失。128个字节的RAM中，内部实时钟占用0~0dH来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息。这个芯片内部有两个端口，端口地址为70H和71H。CPU通过这两个端口来读写CMOS RAM。端口70H为地址端口，存放要访问的CMOS RAM单元地址；71H为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。可见，CPU对CMOS RAM的读写分两步进行，比如要读取CMOS RAM的2号单元：</p><ol><li>将2送入端口70H</li><li>从端口71H读出2号单元的内容</li></ol><h1 id="shl和shr指令"><a href="#shl和shr指令" class="headerlink" title="shl和shr指令"></a>shl和shr指令</h1><p>shl是逻辑左移指令，它的功能是：</p><ol><li>将一个寄存器或内存单元中的数据向左移位</li><li>将最后移出的一位写入CF中</li><li>最低位用0补充</li></ol><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000B</span><br><span class="line">shl al,1</span><br></pre></td></tr></table></figure><p>执行后(al)=10010000B，CF=0。注意如果移动的位数大于1时，必须将移动位数放在cl中。CF值只看最后一位被移出的数字，比如移出3位，那么CF的值就看第三位被移出的值是多少就是多少。可以看出将X逻辑左移一位，就相当于执行X=X*2。</p><p>shr是逻辑右移指令，它的功能和shl相反是：</p><ol><li>将一个寄存器或内存单元中的数据向右移位</li><li>将最后移出的一位写入CF中</li><li>最高位用0补充</li></ol><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">shr al,1</span><br></pre></td></tr></table></figure><p>执行后(al)=01000000B，CF=1。同样如果移动的位数大于1时，必须将移动位数放在cl中。可以看出将X逻辑右移一位，就相当于执行X=X/2。</p><h1 id="CMOS-RAM中存储的时间信息"><a href="#CMOS-RAM中存储的时间信息" class="headerlink" title="CMOS RAM中存储的时间信息"></a>CMOS RAM中存储的时间信息</h1><p>在CMOS RAM中，存放着当前的时间：年、月、日、时、分、秒。这6个信息的长度都为1个字节，存放单元为：</p><p>秒：0    分：2    时：4    日：7    月：8    年：9</p><p>这些数据以BCD码的方式存放，BCD码是以4位二进制数表示十进制数码的编码方式，比如，数值26，用BCD码表示就是：0010(2) 0110(6)，可见，一个字节可以表示两个BCD码，高4位表示十位，低4位表示个位。现在我们要做这样的一件事：在屏幕中间显示当前的月份。</p><p>首先，这个程序要先从CMOS RAM的8号单元取出月份的BCD码，那我们要先向端口70H中写入地址信息，然后再端口71H中取出信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,8</span><br><span class="line">out 70H,al</span><br><span class="line">inal,71H</span><br></pre></td></tr></table></figure><p>我们拿到了BCD码后，要以十进制的形式显示到屏幕上，我们可以看出，BCD码值=十进制数码值，则BCD码值+30H=十进制数对应的ASCII码，为了实现这个功能，我们要做这样的两件事：</p><p>1.将从CMOS RAM的8号单元中读出的一个字节，分为两个表示BCD码值的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ah,al;al中为从CMOS RAM的8号单元中读出的数据</span><br><span class="line">mov cl,4</span><br><span class="line">shr ah,cl;ah中为月份的十位数码值</span><br><span class="line">and al,00001111b;al中为月份的个位数码值</span><br></pre></td></tr></table></figure><p>2.显示(ah)+30H和(al)+30H对应的ASCII码字符。</p><p>完整的程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov al,8</span><br><span class="line">out 70H,al</span><br><span class="line">in al,71H</span><br><span class="line">mov ah,al</span><br><span class="line">mov cl,4</span><br><span class="line">shr ah,cl</span><br><span class="line">and al,00001111B</span><br><span class="line">add ah,30H</span><br><span class="line">add al,30H</span><br><span class="line">mov bx,0b800H</span><br><span class="line">mov es,bx</span><br><span class="line">movbyte ptr es:[160*12+40*2],ah</span><br><span class="line">mov byte ptr es:[160*12+40*2+2],al</span><br><span class="line">mov 4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十三）</title>
    <link href="http://example.com/2022/09/20/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2022/09/20/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/</id>
    <published>2022-09-20T14:27:26.000Z</published>
    <updated>2022-09-23T04:50:51.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h1><p>本篇我们将介绍另一种重要的内中断，由int指令引发的中断。</p><p>int指令的格式为：int N，N为中断类型码，它的功能是引发中断过程。当CPU执行一条int指令时就相当于引发一个N号中断的中断过程，执行过程如下：</p><ol><li>取中断类型码N</li><li>标志寄存器入栈，IF=0,TF=0</li><li>CS、IP入栈</li><li>(IP)=(N×4)，(CS)=(N×4+2)</li></ol><p>从此处转去执行N号中断的中断处理程序。</p><p>可以在程序中使用int指令调用任何一个中断的中断处理程序。比如我们修改上一章中的程序，将结束时使用的int指令改为int 0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,offset do0end-offset do0</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200H</span><br><span class="line">mov word ptr es:[0*4+2],0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 0</span><br><span class="line">do0:</span><br><span class="line">jmp short do0start</span><br><span class="line">db &quot;OVERFLOW!&quot;</span><br><span class="line">do0start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,202H</span><br><span class="line">mov ax,0B800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,12*160+36*2</span><br><span class="line">mov cx,9</span><br><span class="line">s:mov al,[si]</span><br><span class="line">mov es:[di],al</span><br><span class="line">inc si</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>我们执行这个程序:</p><p><img src="1.jpg" alt="int指令引发0号中断"></p><p>我们可以看到在屏幕中间出现了”OVERFLOW!”，程序中本来是没有除法出现的，那么按理来讲就不会触发0号中断处理程序，但现在0号中断处理程序被调用了，这印证了我们之前说到的int指令可以根据类型中断码调用任何一个中断的中断处理程序。</p><h1 id="编写供应用程序调用的中断例程"><a href="#编写供应用程序调用的中断例程" class="headerlink" title="编写供应用程序调用的中断例程"></a>编写供应用程序调用的中断例程</h1><p>前面我们已经写过0号中断例程了，现在我们讨论如何编写可以供程序调用的中断例程的编写方法，现在有这样一个场景：</p><p>功能：将一个全是字母，以0结尾的字符串，转化为大写。</p><p>参数：ds:si指向字符串的首地址。</p><p>应用举例：将data段中的字符串转化为大写。</p><p>首先和我们之前做的一样要先将我们的中断例程安装到内存之中，这样才可以供应用程序调用，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset capital</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,offset capitalend-offset capital</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[7cH*4],200H</span><br><span class="line">mov word ptr es:[7cH*4+2],0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">capital:push cx</span><br><span class="line">push si</span><br><span class="line">change:mov cl,[si]</span><br><span class="line">mov ch,0</span><br><span class="line">jcxz ok</span><br><span class="line">and byte ptr [si],11011111B</span><br><span class="line">inc si</span><br><span class="line">jmp short change</span><br><span class="line">ok:pop si</span><br><span class="line">pop cx</span><br><span class="line">iret</span><br><span class="line">capitalend:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里需要注意的是在中断例程capital中使用了寄存器si和cx，编写中断例程和编写子程序是一样的要注意寄存器冲突的问题，这点非常重要。执行完安装程序后，我们就可以使用中断类型码7C来实现字符串转大写的操作啦，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;conversation&#x27;,0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">int 7cH</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="对int、iret和栈的深入理解"><a href="#对int、iret和栈的深入理解" class="headerlink" title="对int、iret和栈的深入理解"></a>对int、iret和栈的深入理解</h1><p>我们在学习这部分内容前，先思考一个问题：我们怎么才可以用中断例程7cH中断例程完成loop指令的功能。我们先思考loop指令，loop的执行需要两个信息，循环次数和到s的位移，所以，7cH中断例程要完成loop指令的功能，也需要这两个信息作为参数，我们用cx存放循环次数，用bx存放位移。现在我们想要在屏幕中间显示80个“!”,我们先给出完整代码然后分析一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,0b800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,160*12</span><br><span class="line">mov bx,offset s-offset se</span><br><span class="line">mov cx,80</span><br><span class="line">s:mov byte ptr es:[di],&#x27;!&#x27;</span><br><span class="line">add di,2</span><br><span class="line">int 7cH</span><br><span class="line">se:nop</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>上面的程序中，用int 7ch调用7ch中断例程进行转移，用bx传递转移的位移。为了模拟loop指令，7ch中断例程应该具有以下两个功能：</p><ol><li>dec cx</li><li>如果(cx)≠0，转到标号s处执行，否则向下执行。</li></ol><p>我们根据这两个功能分析一下7cH中断例程如何实现到目的地址的转移，转到标号s这显然是要使用标号s的地址设置CS和IP，但中断例程怎么才能拿到标号s的段地址和偏移地址呢？还记得吗？当CPU执行int指令后会将CS和IP压入栈中，这里的CS就是当前程序段的段地址，IP是int指令的下一条指令的偏移地址。可见，在中断例程中，可以从栈中取得标号s的段地址和标号se的偏移地址，而用标号se的偏移地址加上bx中存放的转移位移就可以得到标号s的偏移地址。</p><p>现在我们知道，可以从栈中直接和间接的获得标号s的段地址和偏移地址，那么我们要怎么用它们设置CS:IP呢？我们可以使用iret指令，我们将栈中的se的偏移地址加上bx中的转移位移，则栈中的se的偏移地址就变成了s的偏移地址。我们再用iret指令，用栈中的内容设置CS、IP，从而实现转移到标号s处。7cH中断例程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lp:push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">dec cx</span><br><span class="line">jcxz lpret</span><br><span class="line">add [bp+2],bx</span><br><span class="line">lpret:pop bp</span><br><span class="line">iret</span><br></pre></td></tr></table></figure><p>因为要访问栈，使用了bp，在程序开始处将bp入栈保存，结束时出栈恢复。当要修改栈中se的偏移地址的时候，栈中的情况为：栈顶处是bp原来的数值，下面是se的偏移地址，再下面是s的段地址，再下面是标志寄存器的值。而此时，bp中为栈顶的偏移地址，所以((ss)*16+(bp)+2)处为se的偏移地址，将它加上bx中的转移位移就变为s的偏移地址，最后用iret出栈返回，CS:IP即从标号s处开始执行指令。如果(cx)=0，则不需要修改栈中se的偏移地址，直接返回即可。CPU从标号se处向下执行指令。</p><h1 id="BIOS和DOS所提供的中断例程"><a href="#BIOS和DOS所提供的中断例程" class="headerlink" title="BIOS和DOS所提供的中断例程"></a>BIOS和DOS所提供的中断例程</h1><p>在系统板的ROM中存放着一套程序，称为BIOS（基本输入输出系统），BIOS中主要包含一下几部分内容。</p><ol><li>硬件系统的检测和初始化程序</li><li>外部中断和内部中断的中断例程</li><li>用于对硬件设备进行I/O操作的中断例程</li><li>其他和硬件系统相关的中断例程</li></ol><p>操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程时候经常需要用到的功能。程序员在编程的时候，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作。和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。</p><h1 id="BIOS和DOS中断例程的安装过程"><a href="#BIOS和DOS中断例程的安装过程" class="headerlink" title="BIOS和DOS中断例程的安装过程"></a>BIOS和DOS中断例程的安装过程</h1><p>我们通过之前的学习知道中断例程都需要先安装到内存中才可以使用，但是BIOS和DOS中断例程是怎么安装到内存中的呢？我们来简单的讲述一下这个过程：</p><ol><li>开机后，CPU一加电，初始化(CS)=0FFFFH，(IP)=0，自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。</li><li>初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。注意，对于BIOS所提供的中断例程，只需要将入口地址登记在中断向量表中即可，因为它们是固化到ROM中的程序，一直在内存中存在。</li><li>硬件系统检测和初始化完成后，调用int 19H进行操作系统的引导。从此将计算机交由操作系统控制。</li><li>DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存并建立相应的中断向量。</li></ol><h1 id="BIOS中断例程应用"><a href="#BIOS中断例程应用" class="headerlink" title="BIOS中断例程应用"></a>BIOS中断例程应用</h1><p>下面我们举一个例子，来看一下BIOS中断例程的应用。</p><p>int 10H中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。一般来说，一个供程序员调用的中断例程中往往包含多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。BIOS和DOS提供的中断例程，都用ah来传递内部子程序的编号。</p><p>下面看一下int 10H中断例程的设置光标位置功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ah,2;置光标</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov dh,5;dh中放行号</span><br><span class="line">mov dl,12;dl中放列号</span><br><span class="line">int 10H</span><br></pre></td></tr></table></figure><p>(ah)=2表示调用第10H号中断例程的2号子程序，功能为设置光标位置，可以提供光标所在行号（80×25 字符模式下：0-24）、列号（80×25字符模式下：0-79），和页号作为参数。</p><p>(bh)=0，(dh)=5，(dl)=12，设置光标到第0页，第五行，第十二列。</p><p>bh中页号的含义：内存地址空间中，B8000H-BFFFFH共32KB的空间，为80*25彩色字符模式的显示缓冲区。一屏的内容在显示缓存区中共占4000个字节。显示缓冲区分为8页，每页4KB，显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。也就是说，通常情况下，B8000H-B8F9FH中的4000个字节的内容将出现在显示器上。</p><p>再看一下int 10H中断例程的在光标位置显示字符功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ah,9;在光标位置显示字符</span><br><span class="line">mov al,&#x27;a&#x27;;字符</span><br><span class="line">mov dl,7;颜色属性</span><br><span class="line">mov dh,0;第0页</span><br><span class="line">mov cx，3;字符重复个数</span><br><span class="line">int 10H</span><br></pre></td></tr></table></figure><p>(ah)=9表示调用第10h号中断例程的9号子程序，功能为在光标位置显示字符，可以提供要显示的字符、颜色属性、页号、字符重复个数作为参数。</p><p>bl中的颜色属性的格式如下：</p><p><img src="2.jpg" alt="颜色属性的格式"></p><p>可以看出，和显存中的属性字节和格式相同。注意，闪烁的效果必须在全屏DOS方式下才能看到。</p><h1 id="DOS中断例程应用"><a href="#DOS中断例程应用" class="headerlink" title="DOS中断例程应用"></a>DOS中断例程应用</h1><p>int 21H中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。我们前面一直使用的是int 21H中断例程的4cH号功能，即程序返回功能，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4cH;程序返回</span><br><span class="line">mov al,0;返回值</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure><p>(ah)=4cH表示第21H号中断例程的4cH号子程序，功能为程序返回，可以提供返回值作为参数。我们前面使用这个功能的时候经常写做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure><p>我们看一下int 21H中断例程在光标位置显示字符串的功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ds:dx 指向字符串;要显示的字符串需用&quot;$&quot;作为结束符,但&quot;$&quot;本身不显示,只起到边界的作用</span><br><span class="line">mov ah,9;功能号9,表示在光标位置显示字符串</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure><p>(ah)=4cH表示第21H号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。</p><p>接下来给大家看一个应用中断例程的例子，在屏幕的5行12列显示字符串“Welcome to masm!”具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &#x27;Welcome to masm&#x27;,&#x27;$&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ah,2</span><br><span class="line">mov bh,0</span><br><span class="line">mov dh,5</span><br><span class="line">mov dl,12</span><br><span class="line">int 10H</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov dx,0</span><br><span class="line">mov ah,9</span><br><span class="line">int 21H</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>上述程序在屏幕的5行12列显示字符串“Welcome to masm!”，直到遇到’$’(不显示’$’，’$’只起到边界作用)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十二）</title>
    <link href="http://example.com/2022/09/18/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2022/09/18/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/</id>
    <published>2022-09-18T07:51:23.000Z</published>
    <updated>2022-09-21T05:37:05.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h1><p>任何一个通用的CPU都具有一个能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊的信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息我们可以称它为：中断信息。中断的意思是指，CPU不再接着向下执行，而是转头去处理这个特殊信息。</p><h1 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h1><p>什么情况下会产生中断信息呢？我们给出以下四种情况：</p><ol><li>除法错误，比如执行div指令产生的除法溢出</li><li>单步执行</li><li>执行into指令</li><li>执行int指令</li></ol><p>CPU在接收到这些信息的时候需要去处理它们，不同的信息有不同的处理方式，所以CPU要先知道中断信息的来源，所以中断信息中必须包含识别来源的编码。8086CPU用称为中断类型码的数据来标识中断信息的来源。中断类型码是一个字节型数据，可以表示256种中断信息的来源。之后我们的学习里，我们将中断信息的来源，简称为中断源。那么上述4种中断源，在8086CPU中的中断类型码如下：</p><ol><li>除法错误：0</li><li>单步执行：1</li><li>执行into指令：4</li><li>执行int指令：int指令的格式是int idata，其中idata是一个字节型立即数，它是int指令提供给CPU的中断类型码。</li></ol><h1 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h1><p>CPU收到中断信息后，需要对中断信息进行处理。至于如何处理中断信息，可以由我们编程决定，我们所编写出来处理中断信息的程序称为中断处理程序。一般来讲，需要对不同的中断信息编写不同的处理程序。</p><p>CPU在收到中断信息后，应该转去执行该中断信息的处理程序，那就要想办法修改CS:IP指向中断处理程序的第一条指令，所以首要问题是，CPU在接收到中断信息后，如何根据中断信息确定其处理程序的入口。如何根据8位的中断类型码得到中断处理程序的段地址和偏移地址呢？</p><h1 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h1><p>CPU用8位中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表又是啥子东西？中断向量表就是中断向量的列表。那中断向量又是啥子东西？？所谓中断向量，就是中断处理程序的入口地址，所以中断向量表就是中断处理程序的入口地址列表。</p><p>中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口。</p><p><img src="1.jpg" alt="中断向量表"></p><p>可以看到，当CPU知道了中断类型码，就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到中断处理程序的入口地址。可是。。CPU怎么找到中断向量表呢？中断向量表被存放在内存中，8086CPU规定内存0000:0000~0000:03FF的1024个单元内必须存放着中断向量表，只要是8086CPU那么内存的这个区域就一定是中断向量表。中断向量表中的每一个表项大小占两个字，高地址字存放段地址，低地址字存放偏移地址。</p><h1 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h1><p>现在我们知道了可以使用中断类型码，在中断向量表里面找到中断处理程序的入口，并用其修改CS:IP，使CPU执行中断处理程序。用中断类型码在中断向量表里面找到中断处理程序，设置CS:IP的过程是CPU硬件自动完成的。CPU硬件完成这一系列工作的过程被称为中断过程。</p><p>CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令，所以在中断过程中，在设置CS:IP之前还应该将原来的CS和IP中的值保存起来。所以整个中断过程应该是这样的：</p><ol><li>从中断信息中取得中断信息码</li><li>标志寄存器的值入栈</li><li>设置标志寄存器的第8位TF和第9位IF的值为0（下一篇详细介绍）</li><li>CS的内容入栈</li><li>IP的内容入栈</li><li>从内存地址为中断类型码×4和中断类型码×4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS</li></ol><h1 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a>中断处理程序和iret指令</h1><p>由于CPU随时都有可能检测到中断程序，所以中断处理程序必须一直储存在内存的某段空间之中。编写中断处理程序的步骤有以下四点：</p><ol><li>保存用到的寄存器</li><li>处理中断</li><li>恢复用到的寄存器</li><li>用iret指令返回</li></ol><p>iret指令的功能用汇编语法描述为pop IP，pop CS，popf。iret通常和硬件自动完成的中断过程配合使用，它实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作。iret指令执行后CPU回到执行中断处理程序前的执行点继续执行程序。</p><h1 id="除法错误中断的处理"><a href="#除法错误中断的处理" class="headerlink" title="除法错误中断的处理"></a>除法错误中断的处理</h1><p>我们接下来通过0号中断，即除法错误中断的处理，来体会一下前面的内容。</p><p>当CPU执行div等除法指令时，如果发生了除法溢出的错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序。就像这样：</p><p><img src="2.jpg" alt="除法错误中断的处理"></p><p>可能因为DOSBox是一个模拟器，这种虚拟模式下的DOS系统的中断处理程序与其它方式进入的DOS系统的中断处理程序并不相同。所以没有显示我们想要的错误提示。</p><h1 id="编程处理0号中断"><a href="#编程处理0号中断" class="headerlink" title="编程处理0号中断"></a>编程处理0号中断</h1><p>现在我们改写一下0号中断处理程序的功能，让它可以在屏幕中间显示”OVERFLOW!”,然后返回操作系统。</p><p>我们叫这个程序为do0好了，首先我们要考虑的问题是因为0号中断随时都可能发生，所以我们编写的中断处理程序需要放在内存当中，可是具体应该是哪里呢？前面讲到，内存0000:0000~0000:03FF，大小为1KB的空间是系统存放中断处理程序的入口地址的中断向量表。8086支持256个中断，但实际上系统要处理的中断事件远没有256个，所以在中断向量表里很多单元都是空的。这些空间只用来存放中断处理程序的入口地址，DOS系统和其他程序不会随便使用这块空间，所以可以用这块空间来存放我们的中断处理程序。当然这也限制我们的中断处理程序不能超过256字节。我们打算将do0传送到0000:0200，将do0传送到0000:0200还不算完，我们还要将0000:0200登记在中断向量表的对应表项中，因为是0号中断，所以中断程序的段地址应该在0000:0002字单元中，偏移地址应该在0000:0000字单元中。</p><p>综上所述我们要做这样几件事：</p><ol><li>编写可以显示”OVERFLOW!”的中断处理程序do0</li><li>将do0送入内存0000:0200处</li><li>将do0的入口地址0000:0200储存在中断向量表0号表项中</li></ol><p>所以程序的框架应该是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:do0安装程序</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:显示字符串&quot;OVERFLOW!&quot;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这个程序执行过后将我们写好的中断处理程序复制到了内存的0000:0200处，将do0的入口地址储存在中断向量表中了。接下来我们一点点将程序补完吧！</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>我们可以使用之前说的串传送指令movsb，do0的代码送入0000:0200，程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:设置es:di指向目的地址</span><br><span class="line">设置ds:si指向原地址</span><br><span class="line">设置cx为传输长度</span><br><span class="line">设置传输方向为正</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:显示字符串&quot;OVERFLOW!&quot;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>我们看一下程序中我们应该可以对应上的数据：</p><ol><li>传送的原始位置，段地址：code，偏移地址：offset do0</li><li>传送的目的位置：0000:0200</li><li>传送的长度：do0部分代码长度</li><li>传送的方向：正向</li></ol><p>那么我们就可以将程序补充成这样子滴：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,do0部分代码的长度</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:显示字符串&quot;OVERFLOW!&quot;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>现在我们面临了一个问题，我们怎么知道do0部分的代码长度呢？最简单的方法是，计算一下do0中所有指令码的字节长度，但这样做太麻烦了，而且写成确定的数字也不利于我们以后的更改。所以我们可以让编译器为我们代劳计算do0的长度。这样代码又变成了这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,offset do0end-offset do0</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:显示字符串&quot;OVERFLOW!&quot;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0end：nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>“-“是编译器识别的运算符号，编译器可以用它进行两个常数的减法。就好比mov ax,8-4会被编译器翻译成mov ax,4一样。</p><p>接下来我们来补全do0代码。</p><h1 id="do0"><a href="#do0" class="headerlink" title="do0"></a>do0</h1><p>我们已经分析好do0的工作了所以这里直接给出代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,offset do0end-offset do0</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:jmp short do0start</span><br><span class="line">db &quot;OVERFLOW!&quot;</span><br><span class="line">do0start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,202H;设置ds:si指向字符串</span><br><span class="line">mov ax,0B800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,12*160+36*2;设置es:di指向显存空间的中间位置</span><br><span class="line">mov cx,9;设置cx为字符串长度</span><br><span class="line">s:mov al,[si]</span><br><span class="line">mov es:[di],al</span><br><span class="line">inc si</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里我们来剖析一下代码：</p><p>首先，“OVERFLOW！”没有被存储在一个数据段里，而是和do0一同储存在了代码段里，这是因为如果将字符串存在数据段里，待程序执行完毕，数据段内容会被释放，这样do0程序以后就找不到字符串了，所以我们将字符串一并的存放在代码段中。</p><p>其次，因为do0程序开始处的“OVERFLOW!”不是可以执行的代码，所以在它之前要加上一个jmp指令，跳转到正式的do0程序。</p><p>最后，do0程序执行过程中必须要能找到“OVERFLOW!”，那么它在哪里呢？首先来看段地址，肯定是code段了和do0在一个段地址，再看偏移地址，0000:0200处指令为jmp short do0start，这条指令占两个字节所以，“OVERFLOW!”的偏移地址为202H。</p><h1 id="设置中断向量"><a href="#设置中断向量" class="headerlink" title="设置中断向量"></a>设置中断向量</h1><p>下面要将do0的入口地址0000:0200写入0号表项中。0号表项地址为0000:0000，其中0000:0000字单元放偏移地址，0000:0002放段地址，所以程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200H</span><br><span class="line">mov word ptr es:[0*4+2],0</span><br></pre></td></tr></table></figure><h1 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h1><p>基本上，CPU在执行完一条指令后，如果检测到标志寄存器TF位为1，则产生单步中断，引发中断过程。单步中断的类型码为1，它引发的中断过程如下：</p><ol><li>取得中断类型码1</li><li>标志寄存器入栈，TF、IF设置为0</li><li>CS、IP入栈</li><li>(IP)=(1×4)，(CS)=(1×4+2)</li></ol><p>如上所述，每执行完一条指令，CPU就要转去执行一次1号中断处理程序，CPU为什么要这样做呢？</p><p>我们在使用debug的T命令时，有没有想过这样的问题，debug凭什么可以让程序执行完一条指令后显示各个寄存器的值？我们知道程序的运行就是CS:IP指向程序入口，然后CPU自动向下读取，如果没有外加其他功能，CPU应该是一加上电，它就从预设的地址开始执行下去，不会出现执行一条停一下的情况，可是在debug中，CPU却是这么做的。其实debug是用到了CPU的一个功能实现的，这个功能支持着T命令的工作。</p><p>下面我们就简要的考虑一下debug到底是如何利用CPU所提供的单步中断的功能的。首先，debug提供了单步中断的中断处理程序，功能为显示所有寄存器内容并且等待后续输入命令。然后，在使用t命令执行指令时，debug将TF设置为1，使得CPU工作于单步中断方式下，然后CPU执行完当前指令后，检测到TF为1，引发单步中断，执行单步中断处理程序。</p><p>但是单步中断处理程序也是一条条指令呀，那执行一条指令就单步中断一次，执行一次单步中断处理程序，这不是没完没了了嘛，CPU当然不会允许这种事情发生啦，CPU会在进入中断处理程序之前，设置TF为0，从而避免这种情况的出现，这就是为什么在中断过程中有TF=0这个步骤。我们再来看一遍中断过程：</p><ol><li>取得中断类型码N</li><li>标志寄存器入栈，TF、IF设置为0</li><li>CS、IP入栈</li><li>(IP)=(N×4)，(CS)=(N×4+2)</li></ol><p>最后，CPU提供单步中断功能的原因，就是为了实现单步跟踪程序的执行过程。</p><h1 id="响应中断的特殊情况"><a href="#响应中断的特殊情况" class="headerlink" title="响应中断的特殊情况"></a>响应中断的特殊情况</h1><p>一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就会响应中断，引发中断过程。但是在某些情况下CPU执行完当前的指令后，即便是发生了中断，也不会响应。比如：</p><p>在执行完向SS寄存器传送数据的指令后，即便发生了中断，CPU也不会响应。这样做的原因是，SS:SP联合指向栈顶，而对它们的设置应该连续完成。如果在执行完设置SS的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器的值、CS和IP的值。而SS改变，SP没改变，那SS:SP指向的位置就是错误的。所以CPU在执行设置完SS的指令后，不响应中断。这给连续设置SS和SP提供了一个时机，我们应该利用这个时机，将设置SS和SP的指令连续存放，也就是应该这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov ax，0</span><br><span class="line">mov sp,0</span><br></pre></td></tr></table></figure><p>相信有些细心的小伙伴在学习过程中会发现，用T命令跟踪程序时，往往设置SP的指令会被跳过，但是SP还是被正确设置了，先在我想你心里已经有了答案！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十一）</title>
    <link href="http://example.com/2022/09/12/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/09/12/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</id>
    <published>2022-09-12T06:09:31.000Z</published>
    <updated>2022-09-18T07:36:56.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h1><p>CPU内部的寄存器中，有一种特殊的寄存器，它具有一下三种作用：</p><ul><li>用来存储相关指令的某些执行成果</li><li>用来为CPU执行相关指令提供行为依据</li><li>用来控制CPU的相关工作方式</li></ul><p>它叫做标志寄存器flag，其中储存的信息通常被叫做程序状态字(PSW)，flag寄存器和其他寄存器不一样，其他寄存器都是整个寄存器具有一个含义，而flag是按位起作用的，每一位都有特定的含义。</p><p><img src="1.jpg" alt="flag寄存器的结构"></p><p>flag寄存器的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义，其余位都具有特殊含义。</p><h1 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h1><p>我们知道flag寄存器的结构后，就分别来介绍一下用到的标志位，首先是ZF标志位。</p><p>flag寄存器中第6位：ZF，零标志位。它记录着相关指令执行后，其结果是否为0，如果为0，则ZF为1，反之ZF为0。这很好理解，只要执行的指令得到的结果是0，那么ZF就是1，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">and ax,0</span><br></pre></td></tr></table></figure><p>这两条指令执行完后ZF就是1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">or ax,0</span><br></pre></td></tr></table></figure><p>这两条指令执行完后ZF就是0。</p><p>注意，在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如add，sub，mul，div，inc，or，and等它们多为运算指令；有的指令对标志寄存器是没有影响的，比如mov，pop，push等它们大多数为传送指令。</p><h1 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h1><p>我们介绍的第二个朋友就是PF标志位。</p><p>flag寄存器中第2位：PF，奇偶标志位，它记录相关指令执行后，其结果的所有bit位中1的个数是奇数个还是偶数个，如果为偶数，那么PF就为1，反之为0，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,1</span><br><span class="line">add AL,10</span><br></pre></td></tr></table></figure><p>这两条指令执行完后，结果为00001011B，其中有三个1，所以ZF就是0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,1</span><br><span class="line">or AL,2</span><br></pre></td></tr></table></figure><p>这两条指令执行完后，结果为00000011B，其中有两个1，所以ZF就是1。</p><p>(Tips：0也是偶数哦)</p><h1 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h1><p>接下来是第三位朋友SF标志位。</p><p>flag寄存器中第7位SF，符号标志位。它记录相关指令执行后，其结果是否为负数，如果为负数，那么SF为1，反之为0，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,10000001B</span><br><span class="line">add AL,1</span><br></pre></td></tr></table></figure><p>这两条指令执行完后，结果为10000010B，如果进行的是有符号数计算，那么SF为1，代表结果为负。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,10000001B</span><br><span class="line">add AL,01111111B</span><br></pre></td></tr></table></figure><p>这两条指令执行完后，结果为0，如果进行的是有符号数计算，那么SF为0，代表结果为正。</p><p>计算机中通常用补码来表示有符号数据，一个数据可以被看成有符号数字也可以被看成无符号数字，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,10000001B</span><br><span class="line">add AL,1</span><br></pre></td></tr></table></figure><p>结果为(AL)=10000010B。我们可以认为add指令进行了一次无符号数运算，那么add指令就相当于计算了129+1，结果为130(10000010B)；当然我们也可以认为add指令进行了一次有符号数运算，那么add指令就相当于计算-127+1，结果为-126(10000010B)。</p><p>SF标志，就是CPU对有符号数运算结果的一种记录，记录了数据的正负，我们进行有符号数计算时，可以将SF标志作为判断数据正负的依据，当我们进行无符号数计算的时候，SF标志没有什么使用价值，因此我们要根据进行的计算，去观察SF标志。</p><h1 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h1><p>接下来介绍大哥，CF标志位。</p><p>flag寄存器第0位CF，进位标志位。一般情况下，进行无符号数计算的时候，注意是无符号数，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p><p>对于位数为N的无符号数来说，其对应的二进制信息的最高位，为N-1位，也就是它的最高有效位，而我们假象出来的第N位，就是相对于最高有效位的更高位。</p><p><img src="2.jpg" alt="最高有效位和假想最高位"></p><p>我们知道，当两个数据相加时，就有可能产生从最高有效位向更高位的进位。比如98H+98H，将产生进位。由于这个进位值在8位数中无法保存，我们之前只是简单的说这个进位丢失了，但其实CPU在运算时，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。8086CPU就使用flag的CF位来记录这个进位值，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov AL,98H</span><br><span class="line">add AL,AL</span><br><span class="line">add AL,AL</span><br></pre></td></tr></table></figure><p>第一条add指令执行后，(AL)=30H，CF=1，CF记录了从最高有效位向更高位的进位值，第二条add指令执行后，(AL)=60H，CF=0。</p><p>同样当进行减法运算时，也可能向更高位借位。比如，两个97H-98H，将产生借位，借位后就相当于计算197H-98H。CF标志为也可以记录这个值，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov AL,97H</span><br><span class="line">sub AL,98H</span><br><span class="line">sub AL,AL</span><br></pre></td></tr></table></figure><p>第一条sub指令执行后，(AL)=FFH，CF=1，CF记录了向更高位的借位值，第二条sub指令执行后，(AL)=0H，CF=0。</p><p>哦对了，inc指令不会影响CF的值，要记住。</p><h1 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h1><p>flag寄存器第11位OF，溢出标志位。在仔细了解它之前我们先来了解一下溢出的问题。</p><p>在进行有符号计算的时候，如果结果超过了机器所能表示的范围称为溢出。那么什么是机器能表示的范围呢？比如说，指令运算的结果用8位寄存器或内存单元来存放，比如，add AL,3，那么对于8位的有符号数据，机器所能表示的范围是-128到127。同理，对于16位有符号数据，机器能表示的范围为-32768到32767。如果运算结果超过了机器所能表达的范围，将产生溢出。注意我们现在所讲的溢出，是针对有符号数而言，下面我们看个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,98</span><br><span class="line">add AL,99</span><br></pre></td></tr></table></figure><p>执行后将产生溢出。因为add AL,99进行的有符号数运算是：98+99=197，而结果197超出了机器能表示的8位有符号数的范围，这就发生了溢出，如果在进行有符号数运算时发生溢出，那么运算结果就不正确，就例子而言，add指令运算完的结果是(AL)=0C5H，因为进行的是有符号数计算，所以AL中存储的是有符号数，C5H是-59的补码，如果我们用add指令进行的是有符号数运算，那我们就得到了98+99=-59，这太夸张了！造成这样的原因是实际结果197无法在8位寄存器中存放，由于这样的事情存在，所以CPU要对指令执行以后是否产生了溢出进行记录。</p><p>现在我们回过头来看一下OF标志，如果指令执行以后发生了溢出OF=1反之OF=0，我们要注意，CF是对无符号数有意义的标志位，而OF是对有符号数有意义的标志位，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,0F0H</span><br><span class="line">add AL,88H</span><br></pre></td></tr></table></figure><p>两条指令执行后：CF=1，OF=1。对于无符号数运算来讲，0F0H+88H有进位，所以CF=1；对于有符号数运算来讲，0F0H+88H发生溢出，所以OF=1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,0F0H</span><br><span class="line">add AL,78H</span><br></pre></td></tr></table></figure><p>两条指令执行后：CF=1，OF=0。对于无符号数运算来讲，0F0H+78H有进位，所以CF=1；对于有符号数运算来讲，0F0H+78H没发生溢出，所以OF=0。</p><p>我们可以看出，CF和OF所表示的进位和溢出，分别是对无符号数计算和有符号数计算而言的，它们之间没有任何关系。</p><h1 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h1><p>adc指令是带进位的加法指令，它利用了CF位上记录的进位值，我们来看一下它的格式：</p><p>adc 操作对象1，操作对象2</p><p>它的功能是：操作对象1=操作对象1+操作对象2+CF，比如说adc  ax,bx，实现的功能是(ax)=(ax)+(bx)+CF，我们看一下例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adc ax,1</span><br></pre></td></tr></table></figure><p>因为sub bx,ax发生了借位，这时CF=1，之后adc指令就计算了：(ax)+1+CF=2+1+1=4，所以(ax)=4。</p><p>为什么要加上CF的值呢？CPU为什么提供了这样的指令呢？我们先来回看一下CF的值的含义，adc指令使用到的CF的值的含义是由adc指令前面的指令决定的，也就是说，关键在于所加上的CF值是被什么设置的，如果CF是被sub设置的那么就是借位值，如果是add设置的那就是进位值，所以CF存在的意义就是用来进行高位数数据计算，比如add ax,bx也可以被看做add AL,BL，adc ah,bh它们是完全等价的。我们看一个例子：</p><p>计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中，很显然add指令做不到计算这样大的数据，所以我们打算先计算低16位相加，然后计算高16位相加再加上CF的值。也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001EH</span><br><span class="line">mov bx,0F000H</span><br><span class="line">add bx,1000H</span><br><span class="line">adc ax,0020H</span><br></pre></td></tr></table></figure><p>我们可以根据这个思路计算更大的数据相加。</p><h1 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h1><p>sbb指令是带借位的减法指令，它利用了CF位上记录的借位值，我们来看一下它的格式：</p><p>sbb 操作对象1，操作对象2</p><p>它的功能是：操作对象1=操作对象1-操作对象2-CF，比如说sbb  ax,bx，实现的功能是(ax)=(ax)-(bx)-CF。同样的我们也可以根据我们之前的思路，进行高位数数据的运算。这里我们不再赘述。</p><h1 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h1><p>cmp指令是比较指令，cmp的功能相当于减法指令，只是不保存结果，cmp指令执行后将对标志寄存器产生影响，其他的指令通过识别这些被影响的标志寄存器位来得知比较结果。老样子我们看一下cmp指令的格式：</p><p>cmp 操作对象1，操作对象2</p><p>cmp指令的功能是这样的，计算操作对象1-操作对象2但并不保存结果，仅仅根据计算的结果对标志寄存器进行设置，比如cmp ax,ax它首先计算了(ax)-(ax)结果为0，但并不在ax中保存，仅根据0来设置flag中的相关位，这条指令执行后，ZF=1,PF=1,SF=0,CF=0,OF=0。</p><p>所以我们可以看出来cmp指令给了我们很多信息：</p><p><img src="3.jpg" alt="cmp指令提供的信息1"></p><p>和add，sub指令一样，CPU执行cmp指令的时候也包含两种含义：对无符号数进行比较，对有符号数进行比较，上面我们讲的是对无符号数进行的比较，下面我们看一下对有符号数的比较：</p><p>我们以cmp ah,bh为例，如果(ah)=(bh)，则(ah)-(bh)=0，所以：ZF=1，反之ZF=0，所以我们根据ZF的值可以知道两个数据是否相等。接下来我们再来看(ah)&lt;(bh)会发生什么，在这个情况下，(ah)-(bh)显然可能引起SF=1，即结果为负，但是我们不能因为SF=1就说明(ah)&lt;(bh)，例如：(ah)-(bh)=34-(-96)=82H(-126)，我们不能因为计算后SF=1就说34&lt;-96这显然是不合理的。当运算发生溢出以后我们逻辑上的得到的结果(130)和实际的结果(-126)是不一样的，所以单单根据SF去判断比较较结果是不可靠的，还要结合OF一起判断，下面我们就来看看SF和OF到底给我们提供了什么样的信息：</p><p><img src="4.jpg" alt="cmp指令提供的信息2"></p><h1 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h1><p>我们在之前的学习过程中，学到过一个条件转移指令jcxz指令，它通过检测(CX)是否为0，来判断是否进行条件转移，当然除了jcxz之外，CPU还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的标志位，这些指令通常和cmp组合使用就像是call和ret的关系。</p><p>因为cmp有两种比较，无符号数比较和有符号数比较，所以和cmp组合的转移动指令也有两种，根据无符号数的比较结果进行转移的条件转移指令(它们检测ZF和CF的值)，根据有符号数的比较结果进行转移的的条件转移指令(它们检测SF、OF、ZF的值)。</p><p>下面是常用的根据无符号数的比较结果进行转移的条件转移指令：</p><p><img src="5.jpg" alt="常用的根据无符号数的比较结果进行转移的条件转移指令"></p><p>这些指令很常用，而且很好记忆，它们的第一个字母j表示jump，之后的e代表equal，ne就是not equal，b是below，a是above。</p><p>当然了，这些指令的含义都是和cmp结合的时候才拥有的，它们做的事情只是检测相关标志位，符合条件就跳转，比如有这样一段程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">add ax,0</span><br><span class="line">je s</span><br><span class="line">inc ax</span><br><span class="line">s:inc ax</span><br></pre></td></tr></table></figure><p>执行过后，(ax)=1，因为add ax,0执行过后设置了ZF=1，je指令检测到ZF=1后跳转到S处，这里就不能说谁等于谁，也就是说je指令没有什么含义，因此我们一般将cmp和这些跳转指令一起使用，它们组合起来就像是高级语言中的IF一样起到一个条件判断的作用。有符号数比较跳转指令的原理就和无符号数比较跳转指令相同了，有兴趣可以查阅相关的指令手册。</p><h1 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h1><p>接下来介绍的是flag寄存器的第10位DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。DF=0每次操作后si、di递增；DF=1每次操作后si、di递减。知道了DF的作用后，我们还得知道串传送指令，我们来看一下movsb指令，首先是movsb的格式就是movsb，当执行movsb指令时就相当于做了这样几件事：</p><ol><li>((es)×16+(di))=((ds)×16+(si))</li><li>如果DF=0则(si)=(si)+1,(di)=(di)+1</li><li>如果DF=1则(si)=(si)-1,(di)=(di)-1</li></ol><p>它实现了将DS:SI指向的内存字节单元的内容送入ES:DI中，然后根据DF的值将SI和DI递增1或者递减1。还有另一个指令，movsw指令，它实现了DS:SI指向的内存字单元的内容送入ES:DI中，然后根据DF的值将SI和DI递增2或者递减2。</p><p>movsb和movsw都是串传送操作的一个步骤，一般来说这两个指令都会和rep指令配合使用，rep指令的格式是rep movsb，它做的事情就像是一个循环即s:movsb；loop s。可见rep的作用是根据CX的值，重复执行后面的串传送指令，因为每执行一次movsb指令si和di都会递增或递减一个单位，所以rep movsb可以循环实现(CX)个字符的传送。同理也有rep movsw。</p><p>因为DF标志位决定了串传送指令执行后，si和di改变的方向，所以CPU给程序员提供了相应修改DF位的指令，让程序员可以修改串传送的方向，这两个指令分别是cld指令(将DF置为0)，std指令(将DF置为1)。</p><h1 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h1><p>pushf的格式很简单就是pushf，它做的事情是将标志寄存器的值压栈，popf的格式也是popf，它做的事情是从栈中弹出数据，送入标志寄存器。这两个指令为直接访问标志寄存器提供了一种方法。</p><h1 id="标志寄存器在Debug中的表示"><a href="#标志寄存器在Debug中的表示" class="headerlink" title="标志寄存器在Debug中的表示"></a>标志寄存器在Debug中的表示</h1><p>最后的最后，我们要了解一下标志寄存器在Debug中怎么表示的，这样方便我们在程序调试的时候，观察这些标志位的变化。</p><p><img src="6.jpg" alt="标志寄存器在debug中显示位置"></p><p>当我们开始debug之后执行r指令，我们可以看到在IP寄存器之后有一串字符，这串字符就表示了几个标志位的值，但是这一些值我也分不清那个是那个标志位呀！没关系，我们给出了标志位中值的表示：</p><p><img src="7.jpg" alt="debug对我们已知的标志位的表示"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十）</title>
    <link href="http://example.com/2022/09/06/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <id>http://example.com/2022/09/06/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%EF%BC%89/</id>
    <published>2022-09-06T15:33:49.000Z</published>
    <updated>2022-09-09T08:13:44.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h1><p>我们书接上回，上一篇我们学习了一些转移指令的原理，接下来我们继续学习一些新的转移指令：</p><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移，当CPU执行ret指令时，进行下面两步操作：(IP)=((SS)×16+(SP))；(SP)=(SP)+2。用汇编语法来解释ref指令相当于进行了pop IP。</p><p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移，当CPU执行retf指令时，进行下面四步操作：(IP)=((SS)×16+(SP))；(SP)=(SP)+2；(CS)=((SS)×16+(SP))；(SP)=(SP)+2。用汇编语法来解释ref指令相当于进行了pop IP，pop CS。</p><h1 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h1><p>call指令也是一种转移指令，当CPU执行call指令的时候，进行两步操作：将下一条指令的IP或CS和IP压入栈中；转移。call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。接下来我们仔细介绍一下。</p><h2 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h2><p>首先，看一下call指令的格式：call 标号，将下一条指令IP压入栈中后，转到标号处执行指令。也就是这么一个过程：(SP)=(SP)-2；((SS)×16+(SP))=(IP)；(IP)=(IP)+16位位移。其中16位位移的计算方法是：位移=标号处偏移地址-call指令下一条指令的偏移地址，结果用补码表示，在编译程序编译时算出。当然了16位位移是有取值范围的，取值范围是-32768~32767，用补码表示。用汇编语法来解释call指令相当于进行了push IP；jmp near ptr 标号。</p><h2 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h2><p>首先，还是看一下call指令的格式：call far ptr 标号，将下一条指令CS和IP压入栈中后，转到标号处执行指令。也就是这么一个过程：(SP)=(SP)-2；((SS)×16+(SP))=(CS)；(SP)=(SP)-2；((SS)×16+(SP))=(IP)；(IP)=(IP)+16位位移；(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址。这样的call指令实现了段间转移，用汇编语法来解释call指令相当于进行了push CS；push IP；jmp far ptr 标号。</p><h2 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h2><p>这个call指令的格式是：call 16位reg。它的过程是：(SP)=(SP)-2；((SS)×16+(SP))=(IP)；(IP)=(16位reg)，用汇编语法来解释call指令相当于进行了push IP；jmp 16位reg。</p><h2 id="转移地址在内存中的call指令"><a href="#转移地址在内存中的call指令" class="headerlink" title="转移地址在内存中的call指令"></a>转移地址在内存中的call指令</h2><p>call指令中的转移地址也可以在内存之中，它也分为两种格式：</p><h3 id="call-word-ptr-内存单元地址"><a href="#call-word-ptr-内存单元地址" class="headerlink" title="call word ptr 内存单元地址"></a>call word ptr 内存单元地址</h3><p>用汇编语言解释这句指令的话，那么当CPU执行这句指令的时候，相当于进行了：push IP；jmp word ptr 内存单元地址。</p><h3 id="call-dword-ptr-内存单元地址"><a href="#call-dword-ptr-内存单元地址" class="headerlink" title="call dword ptr 内存单元地址"></a>call dword ptr 内存单元地址</h3><p>用汇编语言解释这句指令的话，那么当CPU执行这句指令的时候，相当于进行了：push CS；push IP；jmp dword ptr 内存单元地址。</p><h1 id="call和ret的配合使用"><a href="#call和ret的配合使用" class="headerlink" title="call和ret的配合使用"></a>call和ret的配合使用</h1><p>我们学会了ret指令也学会了call指令，学这两个指令的目的是为了实现子程序的机制，什么是子程序呢？直观的来说就是我们在高级语言中写的函数，怎么样是不是一下子就感受到这两个指令的强大了，事不宜迟，我们马上开始。  我们先来看一个程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code内存中的情况（假设程序从内存1000:0处装入）</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 8 dup (0)1000:0000 00 00 00 00 00 00 00 00</span><br><span class="line">db 8 dup (0)1000:0008 00 00 00 00 00 00 00 00</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack1001:0000 B8 00 10</span><br><span class="line">mov ss,ax1001:0003 8E D0</span><br><span class="line">mov sp,161001:0005 BC 10 00</span><br><span class="line">mov ax,10001001:0008 B8 E8 03</span><br><span class="line">call s1001:000B E8 05 00</span><br><span class="line">mov ax,4c00H1001:000E B8 00 4C</span><br><span class="line">int 21H1001:0011 CD 21</span><br><span class="line">s:add ax,ax1001:0013 03 C0</span><br><span class="line">ret1001:0015 C3</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>程序中给出了内存中的情况，我们结合内存的情况一点点分析整个程序做的事情。从start开始前三行执行后，栈的情况如下：</p><p>1000:0000 00 00 00 00 00 00 00 00</p><p>此时SS:SP指向栈底，当call指令读入后，(IP)=000EH，CPU指令缓冲器中的代码为：E8 05 00（call s）</p><p>程序执行完call s后，栈的情况变为</p><p>1000:0000 00 00 00 00 00 00 0E 00</p><p>此时SS:SP指向0E也就是倒数第二个字节，然后(IP)=(IP)+0005=0013H。之后CPU从CS:0013H处(即标号s处)开始执行，ret指令读入后(IP)=0016H，CPU指令缓存器中的代码为：C3 （ret）</p><p>程序执行完C3后，栈的情况变为</p><p>1000:0000 00 00 00 00 00 00 0E 00</p><p>此时SS:SP指向栈底，之后CPU回到CS:000EH处（即call指令后面的指令处）继续执行。</p><p>怎么样，是不是有点像我们在高级程序中做的那个样子，写一个函数，当我们需要它的时候就调用它，不需要的时候我们就不调用它。我们给出一个子程序的源程序的框架：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">main:</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  call sub1         调用子程序sub1</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  mov ax,4C00H</span><br><span class="line">  int 21H</span><br><span class="line">sub1:</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  call sub2调用子程序sub2</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ret子程序返回</span><br><span class="line">sub2:</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ret子程序返回</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure><p>怎么样现在的汇编语言是不是更有我们高级程序语言的模样啦！</p><h1 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h1><p>我们这里介绍一下mul指令，mul是乘法指令，在使用mul做乘法时要注意两点：</p><ol><li>两个相乘的数：要不都是8位，要不都是16位。如果都是8位那么一个默认放在AL中，另一个默认放在8位reg或者内存字节单元中。如果都是16位那么一个默认放在AX中，另一个默认放在16位reg或者内存字单元中。</li><li>结果：如果8位乘法，结果默认在AX中；如果是16位乘法那么，结果高位默认在dx中，低位在ax中。</li></ol><p>格式如下：</p><ul><li>mul reg</li><li>mul 内存单元</li></ul><p>内存单元可以通过不同的寻址方式给出，比如：</p><p>mul byte ptr ds:[0] 含义是(AX)=(AL)×((DS)×16+0);mul word ptr [BX+SI+8]含义是(AX)=(AX)×((DS)×16+(BX)+(SI)+8)结果的低16位;(DX)=(AX)×((DS)×16+(BX)+(SI)+8)结果的高16位。</p><h1 id="参数与结果传递的问题"><a href="#参数与结果传递的问题" class="headerlink" title="参数与结果传递的问题"></a>参数与结果传递的问题</h1><p>在高级语言中，我们都知道一个函数由返回值类型，函数名称、参数列表组成，我们将参数交给函数，函数在进行了指定的操作后，将结果交付给我们。在我们的汇编语言中也会使用这种模块化的程序设计。</p><p>我们现在思考这样的问题，现在我们有一个数N，设计一个子程序计算N的三次幂。这样一来我们就有了两个问题，参数N应该存放在哪里？得到的结果要存放在哪？很显然，可以用寄存器来存储，可以将参数放到BX中；因为子程序中要计算N的3次幂，所以可以使用多个mul指令，为了方便，可将结果存放到dx和ax中，我们来看程序，这个程序计算了data段第一组数据的3次方，结果保存到后一组的dword单元中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">dw 1,2,3,4,5,6,7,8</span><br><span class="line">dd 0,0,0,0,0,0,0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,16</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov bx,[si]</span><br><span class="line">call cube</span><br><span class="line">mov [di],ax</span><br><span class="line">mov [di].2,dx</span><br><span class="line">add si,2</span><br><span class="line">add di,4</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">cube:mov ax,bx</span><br><span class="line">mul bx</span><br><span class="line">mul bx </span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="批量数据的传递"><a href="#批量数据的传递" class="headerlink" title="批量数据的传递"></a>批量数据的传递</h1><p>上面的程序中子程序cube只有一个参数，放在bx中。如果有两个参数，那么可以使用两个寄存器来放，可是如果需要传递3个，4个，N个怎么办？显然一味地使用寄存器是不可靠的。这种时候，我们将批量的数据放到内存之中，然后将它们所在的内存空间的首地址放在寄存器中，传递给需要的子程序，同样需要返回多个数据，我们也这样做。我们写一个将字符串转为大写的程序，体验一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &#x27;conversation&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,12</span><br><span class="line">call capital</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">capital:and byte ptr [si],11011111B</span><br><span class="line">inc si</span><br><span class="line">loop capital</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>除了使用寄存器传递参数，我们还有更通用的做法，使用栈来传递参数，我们接下来结合C语言的函数调用来看一下使用栈传递参数的思想，我们设定一个场景，我们要设计一个子程序计算(a-b)的3次幂，a和b是字型数据，我们来看用到的程序片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">push ax</span><br><span class="line">mov ax,3</span><br><span class="line">push ax</span><br><span class="line">call difcube</span><br><span class="line">difcube:push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">mov ax,[bp+4]</span><br><span class="line">sub ax,[bp+6]</span><br><span class="line">mov bp,ax</span><br><span class="line">mul bp</span><br><span class="line">mul bp</span><br><span class="line">pop bp</span><br><span class="line">ret 4</span><br></pre></td></tr></table></figure><p>其中ret idata的含义用汇编语法描述为：</p><p>pop IP；add sp,idata</p><p>我们来看看栈的变化，假设栈的初始情况如下：</p><p>1000:0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </p><p>此时SS:SP指向栈底。</p><p>当执行mov ax,1~push ax指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 00 00 00 00 03 00 01 00 </p><p>此时SS:SP指向03。</p><p>当执行call difcube指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 00 00 XP XI 03 00 01 00 </p><p>此时SS:SP指向XI(XIXPH即为call指令的下一条指令IP)。</p><p>执行push bp指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 XB XA XI XP 03 00 01 00 </p><p>此时SS:SP指向XB。</p><p>执行mov bp,sp后，SS:BP指向1000:8</p><p>之后执行mov ax,[bp+4]将栈中a的值送入ax中，sub ax,[bp+6]减去栈中b的值，mov bp,ax将ax中的值赋给bp，mul bp计算三次幂。</p><p>执行pop bp指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 XB XA XI XP 03 00 01 00 </p><p>此时SS:SP指向XI。</p><p>执行ret 4指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 XB XA XI XP 03 00 01 00 </p><p>此时SS:SP指向栈底。</p><p>我们接下来通过一个C语言程序编译后的汇编语言程序，看一下栈在参数传递中的应用，在高级语言中，局部变量也在栈中储存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    c=a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">    add(a,b,c);</span><br><span class="line">    c++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的汇编程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mov bp,sp</span><br><span class="line">sub sp,6</span><br><span class="line">mov word ptr [bp-6],0001</span><br><span class="line">mov word ptr [bp-4],0002</span><br><span class="line">mov word ptr [bp-2],0000</span><br><span class="line">push [bp-2]</span><br><span class="line">push [bp-4]</span><br><span class="line">push [bp-6]</span><br><span class="line">call ADDR</span><br><span class="line">add sp,6</span><br><span class="line">inc word ptr [bp-2]</span><br><span class="line">ADDR:</span><br><span class="line">push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">mov ax,[bp+4]</span><br><span class="line">add ax,[bp+6]</span><br><span class="line">mov [bp+8],ax</span><br><span class="line">mov sp,bp</span><br><span class="line">pop bp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>尝试画出栈的情况变化，理解栈在参数传递中的作用。</p><h1 id="寄存器冲突问题"><a href="#寄存器冲突问题" class="headerlink" title="寄存器冲突问题"></a>寄存器冲突问题</h1><p>现在你已经学会了子程序的编写，那么我们思考一个问题当我们循环调用一个子程序时，且子程序中使用了寄存器CX会发生什么？这个问题，我们之前遇到过类似的，当使用嵌套循环时也会出现这样的问题，内层循环更改了寄存器CX使得，外层循环出现了问题。同样，我们的子程序修改了CX使得循环出现了问题，我们要如何解决呢？没错还是使用栈来解决，我们在进入子程序后，立马将CX的值压入栈中，待程序完成后从栈中取出CX的值，不只是CX，只要是主程序用到，子程序重复使用的寄存器，我们都要这样处理一下，当然了要注意出栈入栈的顺序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（九）</title>
    <link href="http://example.com/2022/09/02/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <id>http://example.com/2022/09/02/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B9%9D%EF%BC%89/</id>
    <published>2022-09-02T02:13:13.000Z</published>
    <updated>2022-09-09T07:26:50.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li><li>nop占用一个字节，不进行任何动作</li></ol><p>话不多说我们马上开始。</p><h1 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h1><p>还记得我们之前学习过的jmp指令嘛，就是那个可以用来修改CS，IP的指令。jmp指令就是转移指令的一种，概括的来讲，转移指令就是可以控制CPU执行内存中某处代码的指令。8086CPU的转移行为有以下两种：</p><ul><li>只修改IP时，称为段内转移，比如：jmp AX。</li><li>同时修改CS和IP时，称为段间转移，比如：jmp 1000:0。</li></ul><p>由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。</p><ul><li>短转移IP的修改范围是-128~127。</li><li>近转移IP的修改范围是-32768~32767。</li></ul><p>8086CPU的转移指令可以分为以下几类：</p><ul><li>无条件转移指令（如jmp指令）</li><li>条件转移指令</li><li>循环指令（如loop指令）</li><li>过程</li><li>中断</li></ul><p>这些转移指令的前提条件可能不同，但是其中的原理都大相径庭，我们会在这一章中学习无条件转移指令jmp来理解CPU执行转移指令的基本原理。</p><h1 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h1><p>我们先引入一段简单的程序来介绍操作符offset：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,offset start</span><br><span class="line">s:mov ax,offset s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>现在我们来解释一下上面的程序offset操作符取到了标号处的偏移地址，例如offset得到了start和s的偏移地址分别是0和3，所以指令mov ax,offset start就等同于mov ax,0。</p><h1 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h1><p>jmp为无条件转移指令，可以修改IP也可以同时修改CS和IP。jmp指令要给出两种信息：</p><ol><li>转移的目的地址</li><li>转移的距离（段间转移，段内短转移，段内近转移）</li></ol><p>不同的给出目的地址的方法，不同的转移位置就对应着不同的jmp指令格式。</p><h2 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h2><p>jmp short 标号（转到标号处执行指令），这种格式的jmp指令实现的是段内短转移，之前说过这种转移的方式对IP的修改范围在-128~127，也就是说它最多可以向前跳转最多可以越过128个字节，向后跳转最多可以越过127个字节。short符号就说明了这个jmp指令进行的是一次短转移，标号就代表了这次跳转的目的地，待jmp指令执行完成之后，CS:IP应该指向标号处的指令。我们举一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">jmp short s</span><br><span class="line">add ax,1</span><br><span class="line">s:inc ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>上述程序运行后，ax中的值为1，这是因为执行jmp short s后，越过了add ax,1,IP指向了标号s处的指令inc ax。也就是说实际上程序只对ax进行了一次加1的工作。接下来我们看看jmp short s对应的机器指令，在此之前我们先看看别的汇编指令与其对应的机器指令：</p><p><img src="1.jpg" alt="汇编指令与其对应的机器指令"></p><p>可以看到一般的汇编指令其中的idata，无论它是一个数据还是内存单元的偏移地址，都会在它对应的机器指令中出现，因为CPU执行的是机器指令，它必须要处理这些数据或者地址。</p><p>现在我们回过头，使用debug将我们的程序翻译成机器指令看一下：</p><p><img src="2.jpg" alt="我们的程序与其对应的机器指令"></p><p>我们可以看到debug将jmp short s中的s表示为inc ax,1的偏移地址也就是0008H，并将jmp short s表示为jmp 0008，很合理的行为，但是我们看一下jmp short s对应的机器指令，我们发现它并不像是一般指令做的那样，它的机器码是EB 03,程序的0008H没有出现在机器指令中，这就意味着CPU在执行jmp short s的时候，它并不知道转移的目的地，那它是怎么知道到底要向哪里转移的呢？</p><p>我们修改一下程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">mov bx,0</span><br><span class="line">jmp short s</span><br><span class="line">add ax,1</span><br><span class="line">s:inc ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>然后再一次的使用debug将程序翻译成机器指令：</p><p><img src="3.jpg" alt="修改后的程序与其对应的机器指令"></p><p>OH！jmp指令对应的机器指令还是E8 03。这就说明了CPU在执行jmp指令的时候不需要转移的目的地址。这两次jmp指令转移的目的地址是不同的，如果机器指令中含有转移的目的地址，那么它们的机器指令也应该不同。可事实上它们的机器指令相同，这就说明jmp指令对应的机器指令中不包含转移的目的地址。</p><p>可是CPU不是上仙啊，你不告诉它转移的目的地址它也没办法工作呀，我们使用debug跟踪一下程序结合之前学习CPU执行程序的过程，仔细的看看CPU执行到jmp指令后到底发生了什么吧：</p><ol><li>(CS)=076AH，(IP)=0006H，CS:IP指向EB 03</li><li>读取指令码EB 03进入指令缓冲器</li><li>(IP)=(IP)+2=0008H，CS:IP指向add ax,1</li><li>CPU执行指令缓冲器的指令EB 03</li><li>指令EB 03执行后，(IP)=000BH，CS:IP指向inc ax</li></ol><p>从上面的整个过程我们知道了，CPU将指令EB 03读入后，本来已经将CS:IP指向了add ax,1，下一条指令应该执行</p><p>add ax,1，但在jmp指令执行完后IP变成了000BH，所以EB 03这条机器指令一定修改了IP。没错这条指令确实修改了IP，但是根据什么呢？03！只有03可能了，EB太大了这个数字不可能是修改的关键，没错就是03指导CPU如何修改IP，它们没有告诉CPU目的地址是多少，但却说出了需要转移的位移，03也就是从当前位置向后移动3个字节。那03是如何得到的呢，其实是编译器根据汇编指令中的标号计算出来的，我们给出一个公式：位移=标号处偏移地址-jmp指令下一条指令的偏移地址。对于修改后的程序来讲0003H=000BH-0008H。</p><p>实际上，jmp short 标号的功能为：(IP)=(IP)+8位位移。因为8位位移的取值范围是-128~127所以要使用补码来表示。</p><p>还有一种和jmp short 标号功能相近的指令格式。jmp near ptr 标号，它的功能是(IP)=(IP)+16位位移，实现了段内近转移。16位位移的取值范围是-32768~32767，也是使用补码表示。</p><p>这些位移得来的计算方法相同都是：位移=标号处偏移地址-jmp指令下一条指令的偏移地址。在编译程序编译时算出。</p><h2 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h2><p>我们刚才介绍了一个机器指令中不包含目的地址的jmp指令，那现在我们介绍一个机器指令中包含的目的地址jmp far ptr 标号 实现的是段间转移，又称远转移。功能如下：(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址。far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。我们举一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,0</span><br><span class="line">mov bx,0</span><br><span class="line">jmp far ptr s</span><br><span class="line">db 256 dup(0)</span><br><span class="line">s:add ax,1</span><br><span class="line">inc ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>我们使用debug将程序翻译成机器指令：</p><p><img src="4.jpg" alt="修改后的程序与其对应的机器指令"></p><p>可以看到jmp far ptr s的机器指令，为EA 0B 01 6A 07这其中就包含了目的地址，高地址的076AH为转移的段地址，低地址的010B是偏移地址。</p><h2 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h2><p>我们还是先来看一下指令的格式：jmp 16位reg，它的功能是(IP)=(16位reg)，当然了这已经是我们的老朋友了，我们就不多介绍了。</p><h2 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h2><p>转移指令中的转移地址还可以在内存之中，转移地址在内存中的jmp指令有两种格式：</p><h3 id="jmp-word-ptr-内存单元地址（段内转移）"><a href="#jmp-word-ptr-内存单元地址（段内转移）" class="headerlink" title="jmp word ptr 内存单元地址（段内转移）"></a>jmp word ptr 内存单元地址（段内转移）</h3><p>功能：从内存单元地址处开始存放着一个字，是转移的目的地址的偏移地址，也就是(IP)=(内存单元地址)。内存单元地址可用寻址方式的任一格式给出。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br><span class="line"></span><br><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">jmp word ptr [bx]</span><br></pre></td></tr></table></figure><p>这两种方式最终的结果相同，(IP)=0123H</p><h3 id="jmp-dword-ptr-内存单元地址（段间转移）"><a href="#jmp-dword-ptr-内存单元地址（段间转移）" class="headerlink" title="jmp dword ptr 内存单元地址（段间转移）"></a>jmp dword ptr 内存单元地址（段间转移）</h3><p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址，也就是(CS)=(内存单元地址+2)，(IP)=(内存单元地址)。内存单元地址可用寻址方式的任一格式给出。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">mov word ptr [bx+2],0</span><br><span class="line">jmp dword ptr [bx]</span><br></pre></td></tr></table></figure><p>这两种方式最终的结果相同，(CS)=0000H，(IP)=0123H，CS:IP指向0000:0123。</p><h1 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h1><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围为-128~127。我们来看一下它的格式：jcxz 标号，如果(CX)=0，转移到标号处执行。也就是当(CX)=0时，(IP)=(IP)+8位位移。位移计算方法也是老方法：位移=标号处偏移地址-jcxz指令下一条指令的偏移地址，结果用补码表示，在编译程序编译时算出。当(CX)不等于0时，程序什么也不会做，直接继续向下执行。所以从功能上来讲可以理解成if((CX)==0)jmp short 标号;。</p><p>这里我们给出一个jcxz指令的一种应用场景，在汇编语言编程中，当我们要处理一个字符串的时候，我们在结尾通常会有一个0标志着整个字符串至0为止，这个时候我们就可以使用jcxz指令和循环等方法结合，从字符串的第一个字符开始处理，直至遇到字符串结尾的0。或许char数组以\0结尾的原因也和jcxz指令有些许关系呢，如果小伙伴感兴趣，可以自行查找相关资料，这里不多讨论。</p><h1 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h1><p>loop指令是循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围为-128~127。我们来看一下它的格式：loop 标号（(CX)=(CX)-1，如果(CX)不等于0，转移到标号处执行）。位移计算方法也是老方法：位移=标号处偏移地址-jcxz指令下一条指令的偏移地址，结果用补码表示，在编译程序编译时算出，这些都是大同小异的。当(CX)=0时，程序什么也不会做，直接继续向下执行。所以从功能上我们可以理解为(CX)–；if((CX)!=0)jmp short 标号;。</p><h1 id="根据位移进行转移的意义"><a href="#根据位移进行转移的意义" class="headerlink" title="根据位移进行转移的意义"></a>根据位移进行转移的意义</h1><p>相信有的小伙伴会疑问，为什么要算一下位移，然后通过位移再去确定最终的目的地址呢？其实这种设计，方便了程序段在内存中的浮动装配。我们看一段程序：</p><p><img src="5.jpg" alt="使用位移进行转移的意义"></p><p>这段程序无论装在内存的哪里都可以正确执行，因为loop s在执行时只涉及s的位移（-4，前移四个字节，补码表示为FCH），而不是s的地址。如果loop s的机器码中包含的是s的地址，等s处的指令不在目的地址处，程序的执行就会出错。而loop s的机器码中包含的是转移的位移，就不存在这个问题了，因为无论s处的指令实际地址是多少，loop指令的转移地址是不变的。</p><h1 id="编译器对转移位移超界的检测"><a href="#编译器对转移位移超界的检测" class="headerlink" title="编译器对转移位移超界的检测"></a>编译器对转移位移超界的检测</h1><p>注意，根据我们所学的转移指令发现，它们都有一个转移的范围，如果源程序中出现了超出转移范围的话，在编译阶段，编译器将报错。在我们之前使用的形如jmp 2000:0100的转移指令，这些都会引发编译报错，不过我们之前都是在debug中使用的，汇编编译器不认识而已。所以以后要小心源程序中不要出现这样的指令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（八）</title>
    <link href="http://example.com/2022/08/31/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <id>http://example.com/2022/08/31/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AB%EF%BC%89/</id>
    <published>2022-08-31T15:40:26.000Z</published>
    <updated>2022-09-02T02:12:03.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h1><p>这一篇可以算的上是一篇总结性的文章。我们知道，计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含其中：</p><ol><li>处理的数据在哪里？</li><li>要处理的数据有多长？</li></ol><p>这两个问题，在机器指令中必须给明确或者隐含的说明，要不然是没有办法工作的，所以我们这篇文章就在8086CPU的基础上进行讨论。</p><h1 id="bx、si、di、bp"><a href="#bx、si、di、bp" class="headerlink" title="bx、si、di、bp"></a>bx、si、di、bp</h1><p>前面三个寄存器我们都已经见过啦，我们来总结一下它们的用法：</p><ol><li>在8086CPU中只有这四个寄存器可以用在[…]中来进行内存单元的寻址。</li><li>在[…]中，这4个寄存器可以单个出现，或者只能以这四种组合出现：bx和si、bx和di、bp和si、bp和di。</li><li>只要在[…]中使用寄存器bp且指令中没有显性的给出段地址，那么段地址就默认在SS中。</li></ol><h1 id="机器指令：我的数据在哪里？"><a href="#机器指令：我的数据在哪里？" class="headerlink" title="机器指令：我的数据在哪里？"></a>机器指令：我的数据在哪里？</h1><p>绝大部分的机器指令都是进行数据处理的指令，处理大致分为三类：读取、写入、运算。但从机器指令这一层来讲，它并不关心数据的值是多少，而关心指令执行前一刻，它要处理的数据在哪里？在指令执行前，所要处理的数据可以在三个地方：CPU内部、内存、端口。</p><h1 id="汇编语言中数据位置的表达"><a href="#汇编语言中数据位置的表达" class="headerlink" title="汇编语言中数据位置的表达"></a>汇编语言中数据位置的表达</h1><p>在汇编语言中如何表达数据的位置呢？我们有三个概念来表达数据的位置。</p><p>1.立即数（idata）</p><p>对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），在汇编语言中成为：立即数（idata），在汇编指令中直接给出，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add bx,2000H</span><br><span class="line">or bx,00100000B</span><br><span class="line">mov AL,&#x27;a&#x27;</span><br></pre></td></tr></table></figure><p>2.寄存器</p><p>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx</span><br><span class="line">mov ds,ax</span><br><span class="line">push bx</span><br><span class="line">mov ds:[0],bx</span><br><span class="line">push ds</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,ax</span><br></pre></td></tr></table></figure><p>3.段地址（SA）和偏移地址（EA）</p><p>指令要处理的数据在内存中，在汇编指令中可以使用[X]的格式给出EA,SA在某个段寄存器中，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br><span class="line">mov ax,[di]</span><br><span class="line">mov ax,[bx+8]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line"></span><br><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bp+8]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+si+8]</span><br><span class="line"></span><br><span class="line">mov ax,ds:[bp]</span><br><span class="line">mov ax,es:[bx]</span><br><span class="line">mov ax,cs:[bx+si]</span><br><span class="line">mov ax,ss:[bx+si+8]</span><br></pre></td></tr></table></figure><p>存放段地址的寄存器可以是默认的，1到4条指令的段地址默认在ds中，5到8条指令的段地址默认在ss中，当然存放段地址的寄存器也可以显性给出，就像9到12条指令所做的。</p><h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p>当数据存放在内存中，我们有很多方式给顶这个内存单元的偏移地址，这种定位内存单元的方法一般被称为寻址方式。我们用一张图片来总结一下这些寻址方式。</p><p><img src="1.jpg" alt="寻址方式"></p><h1 id="指令要处理的数据有多长？"><a href="#指令要处理的数据有多长？" class="headerlink" title="指令要处理的数据有多长？"></a>指令要处理的数据有多长？</h1><p>8086CPU可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明到底是字操作还是字节操作，我们有如下方式处理：</p><p>1.通过寄存器名指明要处理的数据的尺寸，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">mov bx,ds:[0]</span><br><span class="line">mov ds,ax</span><br><span class="line">inc ax</span><br><span class="line"></span><br><span class="line">mov AL,1</span><br><span class="line">mov AL,BL</span><br><span class="line">mov AL,ds:[0]</span><br><span class="line">inc AL</span><br></pre></td></tr></table></figure><p>其中1到4条指令指明了是字操作，5到8条指明了是对字节操作。</p><p>2.用操作符 X ptr 指明内存单元的长度，X在汇编指令中可以为word或byte，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br><span class="line">inc word ptr ds:[0]</span><br><span class="line">add word ptr [bx],2</span><br><span class="line"></span><br><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">inc byte ptr [bx]</span><br><span class="line">inc byte ptr ds:[0]</span><br><span class="line">add byte ptr [bx],2</span><br></pre></td></tr></table></figure><p>其中1到4条指令指明了是字操作，5到8条指明了是对字节操作。在没有寄存器指明数据尺寸时，使用操作符指明时非常必要的，如果没有指明是无法正常工作的。</p><p>3.其他方法</p><p>有些指令默认了访问的是字节单元还是字单元，比如push [1000H]就不需要指明访问单元是字单元还是字节单元，push指令只进行字操作。</p><h1 id="寻址方式的综合应用"><a href="#寻址方式的综合应用" class="headerlink" title="寻址方式的综合应用"></a>寻址方式的综合应用</h1><p>我们通过一个问题来体验一下各种寻址方式的作用。</p><p>1982年，DEC公司有一条数据如下：</p><p>公司名称：DEC</p><p>总裁姓名：Ken Oslen</p><p>排       名：137</p><p>收       入：40（40亿美元）</p><p>著名产品：PDP</p><p>这些数据在内存中存放方式如下：</p><p><img src="2.jpg" alt="DEC公司数据"></p><p>根据图片可以知道，数据被存放在seg段中从偏移地址60H起始的位置，从seg:60+0开始存放了3个字节的公司名称；从seg:60+3开始存放了9个字节的总裁姓名；从seg:60+C开始存放了一个字型数据，排名；从seg:60+E开始存放了一个字型数据，公司的收入；从seg:60+10开始存放了3个字节的著名产品。</p><p>直到1988年DEC公司的信息有了如下变化：</p><ol><li>Ken Olsen在富豪榜上上升到了38位。</li><li>DEC的收入增加了70亿美元。</li><li>该公司的著名产品已变为VAX系列计算机。</li></ol><p>我们的任务就是把过时的数据修改掉。</p><p>我们直接看code段的关键代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov ax,seg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,60H</span><br><span class="line">mov word ptr [bx+0CH],38</span><br><span class="line">add word ptr [bx+0EH],70</span><br><span class="line">mov si,0</span><br><span class="line">mov byte ptr [bx+10H+si],&#x27;V&#x27;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx+10H+si],&#x27;A&#x27;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx+10H+si],&#x27;X&#x27;</span><br></pre></td></tr></table></figure><p>为了让大家对这段代码有更好的理解，我们用C语言写一下该程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">company</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> cn[<span class="number">3</span>];</span><br><span class="line">    <span class="type">char</span> hn[<span class="number">9</span>];</span><br><span class="line">    <span class="type">int</span> pm;</span><br><span class="line">    <span class="type">int</span> sr;</span><br><span class="line">    <span class="type">char</span> cp[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">company</span> <span class="title">dec</span>=</span>&#123;<span class="string">&quot;DEC&quot;</span>,<span class="string">&quot;Ken Oslen&quot;</span>,<span class="number">137</span>,<span class="number">40</span>,<span class="string">&quot;PDP&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    dec.pm=<span class="number">38</span>;</span><br><span class="line">    dec.sr=dec.sr+<span class="number">70</span>;</span><br><span class="line">    dec.cp[i]=<span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">    i++;</span><br><span class="line">    dec.cp[i]=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    i++;</span><br><span class="line">    dec.cp[i]=<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将两种代码的一些部分对应起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr [bx+0CH],38dec.pm=38;</span><br><span class="line">add word ptr [bx+0EH],70dec.sr=dec.sr+70;</span><br><span class="line">mov si,0   </span><br><span class="line">mov byte ptr [bx].10H[si],&#x27;V&#x27;dec.cp[i]=&#x27;V&#x27;;</span><br><span class="line">inc si    i++;</span><br><span class="line">mov byte ptr [bx].10H[si],&#x27;A&#x27;     dec.cp[i]=&#x27;A&#x27;;</span><br><span class="line">inc si   i++;</span><br><span class="line">mov byte ptr [bx].10H[si],&#x27;X&#x27;dec.cp[i]=&#x27;X&#x27;;</span><br></pre></td></tr></table></figure><p>怎么样是不是很直观，根据对比的结构，我们可以得知8086CPU提供如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便。一个结构化的数据包含了多个数据项，而且数据项的类型又不相同。这个时候我们就可以使用[bx+si+idata]来访问结构体中的数据。用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每一个元素。所以汇编语言提供了更为贴切的书写格式如[bx].idata、[bx].idata[si]。</p><p>在C语言中我们又可以看到，如dec.cp[i]，dec是一个变量名，指明了结构体变量的地址，cp是结构体中的一个变量，指明了数据项cp的地址，而i用来定位cp中的每一个字符。所以看看dec.cp[i]和[bx].10H[si]是不是很像呢？</p><h1 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h1><p>div指令是除法指令，使用div要注意如下事情：</p><ol><li>除数：有8位和16位，在一个reg或内存单元中。</li><li>被除数：默认放在AX或者DX和AX中，如果除数是8位，被除数为16位，默认存放在AX中；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。注意！被除数的位数一定是除数的两倍。</li><li>结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</li></ol><p>div指令的格式是这样的：div reg 或 div 内存单元</p><p>我们举几个例子来看一下div指令：</p><p>div byte ptr ds:[0]</p><p>首先，我们根据操作符确定了除数是8位的，所以被除数是16位的，被存放在AX中了，执行后商被存储在AL中，余数被存放在AH中。用符号表达就是 (AL)=(AX)/((ds)×16+0)的商， (AH)=(AX)/((ds)×16+0)的余数。</p><p>div  word ptr es:[0]</p><p>首先，我们还是根据操作符确定了除数是16位的，所以被除数就是32位的，需要AX和DX共同存储，其中DX存储了高16位，AX存储了低16位，执行时DX中的数据要先乘10000H（左移四位）再加上AX中的数据才能组成被除数，例如被除数是8b1d7eecH那么就意味着(DX)=8b1dH,(AX)=7eecH，所以被除数就等于(DX)×10000H+(AX)。用符号表达就是 (AX)=[(DX)×10000H+(AX)]/((es)×16+0)的商， (DX)=[(DX)×10000H+(AX)]/((es)×16+0)的余数。</p><h1 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a>伪指令dd</h1><p>前面我们用db和dw定义字节型数据和字型数据，dd是用来定义dword（双字）型数据的，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">db 1</span><br><span class="line">dw 1</span><br><span class="line">dd 1</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>在data段定义了3个数据：</p><p>第一个数据为01H,在data:0处，占1个字节；</p><p>第一个数据为0001H,在data:1处，占1个字；</p><p>第一个数据为00000001H,在data:3处，占2个字。</p><h1 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h1><p>dup是一个操作符，在汇编语言中和db、dw、dd等一样，也是编译器识别处理的符号。它是和db、dw、dd等数据定义伪指令配合使用的，用来数据的重复。例如：</p><p>db 3 dup(0) 就是定义了三个字节，它们的值都是0，相当于db 0,0,0</p><p>db 3 dup(1,2,3) 就是定义了九个字节，它们的值是0,1,2,0,1,2,0,1,2，相当于db 0,1,2,0,1,2,0,1,2</p><p>可见dup的使用格式如下：</p><p>db 重复的次数 dup （重复的字节型数据）</p><p>dw 重复的次数 dup （重复的字型数据）</p><p>dd 重复的次数 dup （重复的双字型数据）</p><p>dup是一个非常实用的操作符，比如要定义一个200个字节大小的栈段，原本你需要使用dw声明100个字型数据，但现在你可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack segment</span><br><span class="line">db 200 dup(0)</span><br><span class="line">stack ends</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（七）</title>
    <link href="http://example.com/2022/08/31/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>http://example.com/2022/08/31/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%83%EF%BC%89/</id>
    <published>2022-08-30T23:47:28.000Z</published>
    <updated>2022-09-01T12:17:00.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li></ol><p>话不多说我们马上开始。</p><h1 id="AND和OR指令"><a href="#AND和OR指令" class="headerlink" title="AND和OR指令"></a>AND和OR指令</h1><p>今天的开场比较直接，我们要学习一下and和or指令，因为我们想有一种更为灵活的定位内存地址的方法和相关的编程方法，话不多说开干！</p><p>我们来看一下and指令，and指令是逻辑与指令，按位进行与运算，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,01100011B</span><br><span class="line">and AL,00111011B</span><br></pre></td></tr></table></figure><p>这两个指令运行后的结果是(AL)=00100011B，可以通过and指令设定操作对象的相应位为0，其余位不变。</p><p>比如AND AL，10111111B 设置了AL的第6位为0。AND AL，11111110B设置了AL的第0位为0。</p><p>之后我们来看一下or指令，or指令是逻辑或指令，按位进行或运算，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,01100011B</span><br><span class="line">or AL,00111011B</span><br></pre></td></tr></table></figure><p>这两个指令运行后的结果是(AL)=00111011B，可以通过and指令设定操作对象的相应位为1，其余位不变。</p><p>比如OR AL，01000000B 设置了AL的第6位为0。OR AL，00000001B设置了AL的第0位为0。</p><h1 id="以字符的形式给出数据"><a href="#以字符的形式给出数据" class="headerlink" title="以字符的形式给出数据"></a>以字符的形式给出数据</h1><p>在上一篇我们定义了很多数据，但这些数据都是数字，在我们编程的过程中肯定会有用到字符的时候，所以在汇编语言中我们用’……’的方式指明数据是以字符的形式给出的，编译器将这些数据转化为对应的ASCII码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;unIX&#x27;</span><br><span class="line">db &#x27;foRK&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:  mov AL,&#x27;a&#x27;</span><br><span class="line">mov BL,&#x27;b&#x27;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>上述代码中，db’ unIX’相当于“db 75H,6EH,49H,58H”。这样我们就以字符的形式给出了一组数据。</p><h1 id="大小写转换问题"><a href="#大小写转换问题" class="headerlink" title="大小写转换问题"></a>大小写转换问题</h1><p>现在考虑这个问题，我们定义两个段，分别是codesg和datasg，我们在datasg中声明两个字符串’BaSiC’和’iNfOrMaTiOn’，我们要把第一个字符串转化为大写，第二个字符串转化为小写。那么我们要如何操作呢？</p><p>我们先来分析一下，我们知道在ASCII码标准中小写字母的ASCII码比大写字母的ASCII码大20H，所以只要大写字母减去20H，小写字母加上20H就可以实现大小写字母的转化。知道这点后，我们只要将第一个字符串中的小写字母转化为大写字母，第二个字符串的大写字母变小写字母就可以了，所以我们的程序还要能判断那个字母是大写的那个是小写的。OK！就这么干。呃呃，等会儿，这里有人知道怎么判断一个字母是大写还是小写嘛。。。。呃呃，这可有点难办。我们还没学怎么去判断呢。。那看来我们要从新找一个规律了。</p><table><thead><tr><th align="center">二进制</th><th align="center">十六进制</th><th align="center">大写字符</th><th align="center">二进制</th><th align="center">十六进制</th><th align="center">小写字符</th></tr></thead><tbody><tr><td align="center">01000001</td><td align="center">41</td><td align="center">A</td><td align="center">01100001</td><td align="center">61</td><td align="center">a</td></tr><tr><td align="center">01000010</td><td align="center">42</td><td align="center">B</td><td align="center">01100010</td><td align="center">62</td><td align="center">b</td></tr><tr><td align="center">01000011</td><td align="center">43</td><td align="center">C</td><td align="center">01100011</td><td align="center">63</td><td align="center">c</td></tr><tr><td align="center">01000100</td><td align="center">44</td><td align="center">D</td><td align="center">01100100</td><td align="center">64</td><td align="center">d</td></tr><tr><td align="center">01000101</td><td align="center">45</td><td align="center">E</td><td align="center">01100101</td><td align="center">65</td><td align="center">e</td></tr><tr><td align="center">01000110</td><td align="center">46</td><td align="center">F</td><td align="center">01100110</td><td align="center">66</td><td align="center">f</td></tr><tr><td align="center">01000111</td><td align="center">47</td><td align="center">G</td><td align="center">01100111</td><td align="center">67</td><td align="center">g</td></tr><tr><td align="center">01001000</td><td align="center">48</td><td align="center">H</td><td align="center">01101000</td><td align="center">68</td><td align="center">h</td></tr><tr><td align="center">01001001</td><td align="center">49</td><td align="center">I</td><td align="center">01101001</td><td align="center">69</td><td align="center">i</td></tr><tr><td align="center">01001010</td><td align="center">4A</td><td align="center">J</td><td align="center">01101010</td><td align="center">6A</td><td align="center">j</td></tr><tr><td align="center">01001011</td><td align="center">4B</td><td align="center">K</td><td align="center">01101011</td><td align="center">6B</td><td align="center">k</td></tr><tr><td align="center">01001100</td><td align="center">4C</td><td align="center">L</td><td align="center">01101100</td><td align="center">6C</td><td align="center">l</td></tr><tr><td align="center">01001101</td><td align="center">4D</td><td align="center">M</td><td align="center">01101101</td><td align="center">6D</td><td align="center">m</td></tr><tr><td align="center">01001110</td><td align="center">4E</td><td align="center">N</td><td align="center">01101110</td><td align="center">6E</td><td align="center">n</td></tr><tr><td align="center">01001111</td><td align="center">4F</td><td align="center">O</td><td align="center">01101111</td><td align="center">6F</td><td align="center">o</td></tr><tr><td align="center">01010000</td><td align="center">50</td><td align="center">P</td><td align="center">01110000</td><td align="center">70</td><td align="center">p</td></tr><tr><td align="center">01010001</td><td align="center">51</td><td align="center">Q</td><td align="center">01110001</td><td align="center">71</td><td align="center">q</td></tr><tr><td align="center">01010010</td><td align="center">52</td><td align="center">R</td><td align="center">01110010</td><td align="center">72</td><td align="center">r</td></tr><tr><td align="center">01010011</td><td align="center">53</td><td align="center">S</td><td align="center">01110011</td><td align="center">73</td><td align="center">s</td></tr><tr><td align="center">01010100</td><td align="center">54</td><td align="center">T</td><td align="center">01110100</td><td align="center">74</td><td align="center">t</td></tr><tr><td align="center">01010101</td><td align="center">55</td><td align="center">U</td><td align="center">01110101</td><td align="center">75</td><td align="center">u</td></tr><tr><td align="center">01010110</td><td align="center">56</td><td align="center">V</td><td align="center">01110110</td><td align="center">76</td><td align="center">v</td></tr><tr><td align="center">01010111</td><td align="center">57</td><td align="center">W</td><td align="center">01110111</td><td align="center">77</td><td align="center">w</td></tr><tr><td align="center">01011000</td><td align="center">58</td><td align="center">X</td><td align="center">01111000</td><td align="center">78</td><td align="center">x</td></tr><tr><td align="center">01011001</td><td align="center">59</td><td align="center">Y</td><td align="center">01111001</td><td align="center">79</td><td align="center">y</td></tr><tr><td align="center">01011010</td><td align="center">5A</td><td align="center">z</td><td align="center">01111010</td><td align="center">7A</td><td align="center">z</td></tr></tbody></table><p>我们掏出来我们的小对照表，我们再来分析分析。从十六进制的角度我们已经走不通了，那我们来看看二进制吧！</p><p>我们观察到大写字母的二进制ASCII码的第五位一定是0，小写字母的二进制ASCII码的第五位一定是1，而且大小写字母的二进制ASCII码也只有这个区别除了这个第五位，其他位都是一样的，所以我们只要将数据的第五位变成1就可以将大写字母变成小写字母，同样我们只要把数据的第五位变成0就可以将小写字母变为大写字母，那如何将一个二进制数据的某一位变成1或者0呢？当然是AND和OR啦！我们来看具体代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,5</span><br><span class="line">S: mov AL,[bx]</span><br><span class="line">and AL,11011111B</span><br><span class="line">mov [bx],AL</span><br><span class="line">INC bx</span><br><span class="line">loop S</span><br><span class="line">mov bx,5</span><br><span class="line">mov cx,11</span><br><span class="line">S0: mov AL,[bx]</span><br><span class="line">or AL,00100000B</span><br><span class="line">mov [bx],AL</span><br><span class="line">INC bx</span><br><span class="line">loop S0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h1><p>相信小伙伴们，知道[bx]的含义后，肯定也能猜到[bx+idata]的含义，没错[bx+idata]也代表一个内存单元，它的偏移地址是(bx)+idata。我们举个例子，mov ax，[bx+200]，这条指令的含义是将一个内存单元中的内容送入寄存器AX中，这个内存单元长度为2个字节，偏移地址为寄存器BX中的数值加上200，段地址在ds中，物理地址为（ds）×16+（bx）+200。当然了我们更习惯这样写：mov ax，[200+bx]、mov ax,200[bx]或者mov ax,[bx].200。</p><h1 id="用-bx-idata-的方式进行数组的处理"><a href="#用-bx-idata-的方式进行数组的处理" class="headerlink" title="用[bx+idata]的方式进行数组的处理"></a>用[bx+idata]的方式进行数组的处理</h1><p>相信仔细研究过高级语言中数组的小伙伴们看到这个标题就已经隐隐约约的能体会到[bx+idata]如何进行数组的处理的了，那我们来好好的讨论一下到底是怎么进行数组处理的。我们稍微改一下问题条件，这次我们提供的两个字符串是’BaSiC’和’MinIX’，也是将他们分别转变成大写字符串和小写字符串。</p><p>我们来分析分析，首先字母’B’的地址是datasg:0,而字母’M’的地址是datasg:5,恰好这两个字符串还都是五个字符，所以我们可以这样做，来看具体代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;MinIX&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,5</span><br><span class="line">S: mov AL,0[bx]</span><br><span class="line">and AL,11011111B</span><br><span class="line">mov 0[bx],AL</span><br><span class="line">mov AL,5[bx]</span><br><span class="line">or AL,00100000B</span><br><span class="line">mov 5[bx],AL</span><br><span class="line">inc bx</span><br><span class="line">loop S</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>我们在写一个C语言的来对比一下，体会一下用[bx+idata]的方式进行数组的处理，来看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> a[<span class="number">5</span>]=<span class="string">&quot;BaSiC&quot;</span>;</span><br><span class="line"><span class="type">char</span> b[<span class="number">5</span>]=<span class="string">&quot;MinIX&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=a[i]&amp;<span class="number">0xDF</span>;</span><br><span class="line">        b[i]=b[i]|<span class="number">0x20</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言：a[i],b[i]  汇编语言：0[bx],5[bx]</p><p>相信大家经过对比可以体会到两种语言的相似之处，它们都有起始地址和偏移地址。[bx+idata]的方式为高级语言实现数组提供了便利机制。</p><h1 id="bx-si-和-bx-di"><a href="#bx-si-和-bx-di" class="headerlink" title="[bx+si]和[bx+di]"></a>[bx+si]和[bx+di]</h1><p>寄存器si和di是8086CPU中和bx功能相近的寄存器，si和di不能被分成两个8位寄存器使用。通过之前的学习我们可以使用[bx(si或di)]和[bx(si或di)+idata]的方式来指明一个内存单元，我们还有更灵活的方式：[bx+si]和[bx+di]。我们举个例子：mov ax，[bx+si]，这条指令的含义是将一个内存单元中的内容送入寄存器AX中，这个内存单元长度为2个字节，偏移地址为寄存器BX中的数值加上寄存器si中的数值，段地址在ds中，物理地址为（ds）×16+（bx）+（si）。当然了我们更习惯这样写：mov ax,[bx][si]。</p><h1 id="bx-si-idata-和-bx-di-idata"><a href="#bx-si-idata-和-bx-di-idata" class="headerlink" title="[bx+si+idata]和[bx+di+idata]"></a>[bx+si+idata]和[bx+di+idata]</h1><p>终极版本，我们可以使用[bx+si+idata]和[bx+di+idata]指定内存单元，我们举个例子：mov ax，[bx+si+200]，这条指令的含义是将一个内存单元中的内容送入寄存器AX中，这个内存单元长度为2个字节，偏移地址为寄存器BX中的数值加上寄存器si中的数值再加上200，段地址在ds中，物理地址为（ds）×16+（bx）+（si）+200。当然了我们更习惯这样写：mov ax,[bx+200+si]、mov ax,[200+bx+si]、mov ax,200[bx][si]、mov ax,[bx].200[si]、mov ax,[bx][si].200。</p><h1 id="总结不同寻址方式"><a href="#总结不同寻址方式" class="headerlink" title="总结不同寻址方式"></a>总结不同寻址方式</h1><p>我们比较一下前面用到的几种定位内存地址的方法，就可以发现：</p><p>1.[idata]用一个常量表示地址，这样可以用来直接定位一个内存单元。</p><p>2.[bx]用一个变量表示内存地址，这样可以用来间接定位一个内存单元。</p><p>3.[bx+idata]用一个变量和常量表示地址，这样可以用来在一个起始地址的基础上用变量间接的定位一个内存单元。</p><p>4.[bx+si]用两个变量表示地址。</p><p>5.[bx+si+idata]用两个变量和一个常量表示地址。</p><p>我们创建两个场景体验不同的寻址方法带来的便利。</p><h2 id="bx-idata-1"><a href="#bx-idata-1" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h2><p>我们来思考这个问题，现在我们声明6个单词，我们的任务是将单词的第一个字母变为大写字母：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;1. file          &#x27;</span><br><span class="line">db &#x27;2. edit          &#x27;</span><br><span class="line">db &#x27;3. search        &#x27;</span><br><span class="line">db &#x27;4. view          &#x27;</span><br><span class="line">db &#x27;5. options       &#x27;</span><br><span class="line">db &#x27;6. help          &#x27;</span><br><span class="line">datasg ends</span><br></pre></td></tr></table></figure><p>每个单词占用16个字节大小，不足的位置使用空格添补，这6个单词因为是连续存储进去的，可以将这6个单词看成一个6行16列的二位数组。按照要求，我们需要修改每一个单词的第一个字母，即二维数组的每一行的第4列。那我们完全可以使用[bx+idata]来定位这一列，使用BX+16来换行。我们来看具体代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;1. file          &#x27;</span><br><span class="line">db &#x27;2. edit          &#x27;</span><br><span class="line">db &#x27;3. search        &#x27;</span><br><span class="line">db &#x27;4. view          &#x27;</span><br><span class="line">db &#x27;5. options       &#x27;</span><br><span class="line">db &#x27;6. help          &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,6</span><br><span class="line">s:mov AL,[bx+3]</span><br><span class="line">and AL,11011111B</span><br><span class="line">mov [bx+3],AL</span><br><span class="line">add bx,16</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="bx-si"><a href="#bx-si" class="headerlink" title="[bx+si]"></a>[bx+si]</h2><p>我们再思考这个问题，现在我们再声明4个字符串，我们的任务是把所有字母都变为大写字母：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm             &#x27;</span><br><span class="line">db &#x27;dec             &#x27;</span><br><span class="line">db &#x27;dos             &#x27;</span><br><span class="line">db &#x27;vax             &#x27;</span><br><span class="line">datasg ends</span><br></pre></td></tr></table></figure><p>每个字符串占用16个字节大小，不足的位置使用空格添补，这4个字符串因为是连续存储进去的，可以将这4个字符串看成一个4行16列的二位数组。按照要求，我们需要修改每一个行的前三列，即二维数组的每一行的前三列。那我们可以使用[bx+si]来定位我们用si定位列，bx定位行，进行一次嵌套循环，我们来看一下具体代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm             &#x27;</span><br><span class="line">db &#x27;dec             &#x27;</span><br><span class="line">db &#x27;dos             &#x27;</span><br><span class="line">db &#x27;vax             &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s0:mov si,0</span><br><span class="line">mov cx,3</span><br><span class="line">s:mov AL,[bx+si]</span><br><span class="line">and AL,11011111B</span><br><span class="line">mov [bx+si],AL</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">add bx,16</span><br><span class="line">loop s0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>不知道大家会不会感觉哪里不太对，没错这个代码的逻辑是错误的，我们在两个循环中使用了一个循环计数器，这就导致了我们在内部循环中将外部循环的数值，多一个计数器又不可能，因为loop指令默认的计数器是cx，怎么办？</p><p>我们可以选择使用另一个寄存器来存储外部循环的计数，但万一别的寄存器也被用了呢？万一没有多余的寄存器给我暂存这种数据呢？所以使用另一个寄存器的方案不太可行，那我们可不可以使用内存来存储这个数据呢？我们只需要开辟一段内存空间来存储这个数据就好，只需要在数据段添加一句“dw 0”。</p><p>问题虽然被解决了但如果我们要同时保存多个这样的数据呢？那我们就要记住数据到底放到了哪个单元中，这太麻烦了，我们怎么优化一下这个方案呢？想想我们学到现在能使用的好像只有栈了，没错，一般来讲，我们在需要暂存数据的时候，我们都应该使用栈。这样我们只需要使用PUSH指令和POP指令就可以很方便存取数据。我们看一下最后改进好的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg，ss:stacksg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm             &#x27;</span><br><span class="line">db &#x27;dec             &#x27;</span><br><span class="line">db &#x27;dos             &#x27;</span><br><span class="line">db &#x27;vax             &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,stacksg</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,datasg</span><br><span class="line">mov ds,0</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s0:push cx</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,3</span><br><span class="line">s:mov AL,[bx+si]</span><br><span class="line">and AL,11011111B</span><br><span class="line">mov [bx+si],AL</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">add bx,16</span><br><span class="line">pop cx</span><br><span class="line">loop s0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（六）</title>
    <link href="http://example.com/2022/08/29/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://example.com/2022/08/29/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AD%EF%BC%89/</id>
    <published>2022-08-29T15:18:59.000Z</published>
    <updated>2022-08-31T06:07:48.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li></ol><p>话不多说我们马上开始。</p><h1 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h1><p>在学习这一章之前，我们也写了不少程序了，但这些程序都是只使用了一个段的，就好像一个程序只有Main函数。这种写程序的手法是很低端的，一点都不符合我们高端程序员的身份，更何况万一我的程序需要其他地方放数据怎么办？在上一篇中，我们讲到了要使用一段安全的空间，但是那段空间只有256个字节大小，万一我们需要的空间大于256个字节怎么办？其实在操作系统的管控下，程序可以取得任意容量的内存，操作系统会为我们安排好。</p><p>程序获取空间的手段有两种，一种是在加载程序时为程序分配好，另一种是在程序执行的过程中向系统申请。第二种就是我们在高级语言中使用的malloc或者new函数等等，这里不多讨论。我们之前在源程序中定义段来进行内存空间的获取，这就是我们为了程序加载过程中得到所需空间做的准备。</p><p>大多数有用的程序，都要处理数据，使用栈等等操作，为了设计上看起来清晰，我们也会定义很多段来做不同的事情，就像是我们会写很多函数而不是把代码全都堆放在Main中。我们慢慢的去体验由一个段的程序到多个段的程序这个过程。</p><h1 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h1><p>试想这样一个问题，现在我们有这样8个数据，分别是0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H。我们要做这样一件事情将他们累加起来放在AX中。之前我们也做过类似的事情，只不过那个时候我们还没有要求将特定的数据累加起来。自从学会loop指令后，总是想用一下看看，没错这次的问题是使用loop指令来完成，但这就代表着我们在累加前，要想办法把这8个数据存放在一组地址连续的内存单元中，就像是我们在高级语言中会做的那样，把他们放在数组中。但问题是我们要上那找到再这样一组内存单元呢？我们不能自己随便找一段内存单元就把它们丢进去了，这样太不负责任了，我们应该告诉系统我们需要一个地方来放这些数据，由系统分配给我们。那具体我们要怎么做呢？来看看代码叭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>首先，解释一下什么是“dw”，dw即“define word”翻译过来就是定义字型数据，在这里dw定义了8个字型数据，大小16个字节，那么这些数据存在哪里了呢？数据既然是跟着代码一起被加载到内存中的，那肯定是在代码段中啦，因为dw定义数据的位置在整个代码段的最上面，所以这8个数据的偏移地址就是0,2,4,6,8,A,C,E。所以在循环中bx每次加2来累加这8个字型数据。</p><p>在编写完成程序以后我们编译、连接，等等先别急，我们用debug追踪一下看看，debug使用U指令！</p><p><img src="1.jpg" alt="debug使用U指令！"></p><p>啊！什么？这是什么？！这不是我的代码啊！哎别急别急，你仔细看看这些汇编指令对应的机械码，是不是看起来很眼熟，没错这16个字节对应的就是程序所定义的字型数据，它们也是程序的一部分。我们跳过这个部分，从0B3D:0010后面看。</p><p><img src="2.jpg" alt="其实在这里呐"></p><p>所以我们想要正确的运行程序就要手动的使用r指令将寄存器IP改为10H。但我们的程序要怎么直接运行呢？总不能让所有人都会使用debug，都手动更改IP吧！当然不需要这样我们只需要对源程序进行小小的改动就可以解决这个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H</span><br><span class="line">start:mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>注意啦！我们在程序的第一条指令前面加了一个标号，并且在伪指令end后面也加上了同名标号。这里我们就要再一次的讨论end的作用啦，end除了可通知编译器程序到此结束外，还可以通知编译器程序到底从哪里进入。正如修改后的代码所做，伪指令end告诉编译器这个程序要从start后面开始，”mov bx,0“才是第一条指令。</p><p>我们之前说过，一个程序运行首先由一个其他程序装载到内存中将CPU的控制权递交给程序，根据第一条指令的段地址和偏移地址来设置寄存器CS和寄存器IP，最后程序运行完将CPU的控制权归还。可问题是，怎么才能知道那一条才是程序的第一条指令呢？我们知道一个可执行文件由描述信息和程序组成，程序就是我们写的代码，描述信息就是处理伪指令后得到的信息，我们在上面在这个程序中使用end告知编译器程序的起始位置与程序的结束位置，在编译后end start就变成了入口地址，储存在描述信息中，所以可以知道程序第一条指令的位置。所以我们若要CPU从何处开始执行程序，只要使用”end 标号“指明就好。</p><h1 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h1><p>我们再来思考这样的问题还是上述8个数据：0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H。现在我们希望将它们逆序存放，我们要怎么做呢？我们来慢慢想，想要逆序一组数据，使用栈是一个非常好的选择，只需要将所有数据入栈，再出栈就可以实现逆序了，那么我们就需要一段可以用来当做栈的内存空间，同样我们不可以自己取用，要通过程序来得到这个空间。来看看代码叭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">code segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">start: movax,cs</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,30H</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>注意啦我们定义了16个字型数据，并将它们所占用的32个字节大小的空间作为栈使用，也就是说我们打算使用CS:10~CS:2F这段内存空间作为栈使用，初始情况下栈为空SS:SP要指向栈底，所以我们设置寄存器SP内容为30H。这样我们就的到了32个字节大小的栈。我们描述dw的作用时，可以说它定义了数据，同时也可以说它开辟了空间，看程序员具体希望得到的东西到底是空间还是数据。</p><h1 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h1><p>我们已经知道怎么把数据、代码、栈放入一个段中啦！但这样做会有两个问题，一是这样写整个程序会很乱，二是一个段的大小不可以超过64KB（这是8086模式的限制，不是所有处理器都这样）。所以我们应该考虑怎么把这些东西放到不同的段里面。其实很简单我们只需要定义多个段然后放进去不就好了嘛（额好废的废话。。），我们量来看具体代码叭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0fedH,0cbaH,0987H</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: movax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20H</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>怎么样是不是真的很简单！下面我们对程序仔细的说明一下：</p><h2 id="定义多个段的方法"><a href="#定义多个段的方法" class="headerlink" title="定义多个段的方法"></a>定义多个段的方法</h2><p>很简单，我们从程序中就可以看出，定义一个段的方法和前面所讲的定义代码段的方法一样，只不过不同的段，我们要命不同的名。</p><h2 id="对段地址与偏移地址的取用"><a href="#对段地址与偏移地址的取用" class="headerlink" title="对段地址与偏移地址的取用"></a>对段地址与偏移地址的取用</h2><p>现在程序里面有多个段了，我们访问数据就需要知道这些数据的地址，可是我们如何知道这些数据的地址呢？首先，在程序中段名就相当于一个标号，它就代表了段地址，比如data就代表了数据段的段地址，stack就代表了栈段的段地址。其次偏移地址，这些数据在自己的段中偏移地址都是从0开始的，就类似一个数组，数组名代表数组的起始位置，其中的数据的偏移地址就是自己的标号（当然数组的偏移地址不会是简单的0,1,2·····还要根据数组类型计算）。</p><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><p>首先，思考这样一个问题，我们定义一个段，如果段中的数据占N个字节，则程序加载后该段占用的实际空间为多少？我们一点点思考，一个段内可以根据段地址被分为一个个小段，这些小段每个大小为16字节。哪怕一个小段里面只存储了1字节大小的数据，其余都是空的那么也需要一整个小段。所以确定一个段到底占用多大空间，我们要先确定有多少个小段 ，这个很简单就是N/16+1，这里N/16的意思是向下取整的意思，先确定有多少个装满了的小段，加上1就是所用的全部小段，确定有多少个小段之后再乘16就是占用的空间大小了。所以答案是（N/16+1）×16。</p><p>想明白这个问题，我们另一个问题，现有如下程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">push ds:[0]</span><br><span class="line">push ds:[2]</span><br><span class="line">pop ds:[2]</span><br><span class="line">pop ds:[0]</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 0123H,0456H</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>假设code段的段地址为X，那么data段的段地址为多少？stack段的段地址为多少？</p><p>其实博主看到这个问题时候也是一头雾水，这可怎么办？我也不知道code段占用多大的空间啊，那我怎么知道要加多少才可以。后来博主在网上找到了答案，当你使用debug跟踪一个程序时，寄存器CX最开始会存储整个源程序无论是代码段还是栈段或者其他段的整体大小（这里博主试验了一下，使用d指令查看程序占用大小为8，寄存器CX中也确实存储了0008H）。</p><p><img src="3.jpg" alt="CX中存储源程序大小"></p><p>所以当我们使用debug跟踪问题提供的程序以后，可以看到(CX)=0044H，也就是68个字节，我们可以把这68个字节看成一个大段它使用了5个小段来存储内容，其中stack和data使用了1个段（这是根据stack和data中数据占用大小计算的出的，和上一个问题相同），这样代码段就使用了3个段，根据程序从上到下的顺序可以知道代码段的段地址加上3就是data段的段地址，加上4就是stack段的段地址，所以答案是data段的段地址为X+3，stack段的段地址为X+4。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学习到这里，我们已经掌握了很多汇编知识了，所以在这里写一个总结（其实是有个事情我不知道写在哪里好随便插在总结里叭），汇编语言的学习是为了让我们深刻的理解计算机硬件，对于计算机的运作有深刻的认知，但要记住汇编语言也是人类创造出来方便人类的语言，它并不是计算机的母语，汇编语言最后还是会转变为二进制代码，变成高电平，低电平来工作的，所以我们写下的代码不代表CPU会根据我们的认知来运作，不是说我们定义一个栈CPU就会承认它是个段，SS:SP才决定了哪里是栈段，其余的也是如此。最后，汇编语言的旅程才刚刚开始，加油叭！少年！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（五）</title>
    <link href="http://example.com/2022/08/24/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://example.com/2022/08/24/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%94%EF%BC%89/</id>
    <published>2022-08-23T16:52:41.000Z</published>
    <updated>2022-09-06T13:48:42.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li></ol><p>话不多说我们马上开始。</p><h1 id="对前言更新的解释"><a href="#对前言更新的解释" class="headerlink" title="对前言更新的解释"></a>对前言更新的解释</h1><p>相信小伙伴们都发现了，我们的老伙伴前言终于更新啦！！这次更新了两条第一条是使用()，第二条是idata，我们一一说明。</p><p>首先是(地址或寄存器名称)，为了描述上的简洁以后我们就都用(地址或寄存器名称)来表示一个内存单元或者寄存器中的内容啦。比如(ax)就代表寄存器ax中的内容，(20000H)代表20000H处内存单元中存放的内容。至于()所得到的内容到底是字型数据还是字节型数据要根据具体的运算决定，()中可以出现三种元素：</p><ol><li>寄存器名</li><li>段寄存器名</li><li>地址（注意这里的地址是且必须是一个物理地址）</li></ol><p>所以(AX)、(DS)、(AL)、(20000H)、((ds)×16+(bx))都是正确的使用方式，但(2000:0)这样是不被允许的。学会了这个我们举一个应用的实际例子，对于PUSH AX的过程我们可以这样描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(SP)=(SP)-2</span><br><span class="line">((SS)×16+(SP))=(AX)</span><br></pre></td></tr></table></figure><p>其次是idata，这个很简单，“[0]”偏移地址过去用此类形式表示，我们使用idata代替0,1,2,3这样的常量。</p><p>(Tips:寄存器DS不可以直接使用mov指令对其赋值。)</p><h1 id="BX-与内存单元的描述"><a href="#BX-与内存单元的描述" class="headerlink" title="[BX]与内存单元的描述"></a>[BX]与内存单元的描述</h1><p>相信看到”[]”有的小伙伴已经展开回忆了，我们先来复习一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[0]</span><br><span class="line">MOV AL,[0]</span><br></pre></td></tr></table></figure><p>这就是[]最基本的使用方法了，CPU在执行这两条指令的时候从寄存器DS中取出段地址，在[]中取出偏移地址，组成物理地址后再进行其他的处理。这两条指令分别完成了这样两件事：</p><p>第一条指令将一个长度为2的内存单元中的内容放在了寄存器AX中。</p><p>第二条指令将一个长度为1的内存单元中的内容放在了寄存器AL中。</p><p>注意这其中的不同点，对于不同大小的寄存器，CPU送入的数据大小也不相同。是的，我们在完整的描述一个内存单元需要两种信息：</p><ol><li>内存单元的地址</li><li>内存单元的大小</li></ol><p>其中内存单元的地址会由寄存器DS与[address]指明，内存单元的大小会由具体的操作对象指出。[BX]也是指出偏移地址的作用，只不过[BX]的意思是偏移地址在寄存器BX中。</p><h1 id="试着用用-BX"><a href="#试着用用-BX" class="headerlink" title="试着用用[BX]"></a>试着用用[BX]</h1><p>这里我们通过一段代码理解[BX]。(Tips:inc指令代表自增1，当还有一个dec指令代表自减1。)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000H  </span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,[bx]</span><br><span class="line">inc bx</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],ax</span><br><span class="line">inc bx</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],ax</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],al</span><br></pre></td></tr></table></figure><p>其中0地址字单元内容为00BEH，2100:2-2100:7为空，试着写出程序运行完后的21000H-21007H单元中的内容。</p><p>答案：</p><p>21000H~21006H BE 00 BE 00 BE BE BE  21007H为空。</p><p>看完这段代码相信你也学到了一招，可以使用[BX]与inc指令实现偏移地址的改变。</p><h1 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h1><p>loop n. 循环。相信学习过C，JAVA等高级语言的小伙伴对循环一定不陌生，循环为我们简化代码做出了极大地贡献，在汇编语言中也是如此。先给大家剧个透loop指令有点像do····while。先来看一段使用loop指令的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line">code segment</span><br><span class="line">mov ax,2</span><br><span class="line">mov cx,11</span><br><span class="line">s:add ax,ax</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>可能有的小伙伴已经可以猜的八九不离十了，没错这段代码计算了2的12次幂。</p><p>我们来根据这段代码讲述一下loop指令到底怎么工作的，当程序运行至loop时，首先做了(cx)=(cx)-1，然后判断cx中的值，不为0则跳转标号(也就是程序中的S)处执行，若为0则结束loop指令继续向下执行。标号S在程序运行阶段会变成一个地址，loop指令在判断CX的值不为0后，loop s(地址)将寄存器IP设置为S。了解了loop的工作机理后，我们发现寄存器CX的值会影响loop指令的执行结果，是的，通常我们用loop指令实现循环，会用寄存器CX存放循环次数，当然这也不是绝对的，不同场合，我们会有不同的处理方式。注意哦！loop指令不会跳过内部的程序段，它一定是先执行一次在去执行loop指令，这点和do····while很像。</p><h1 id="Debug和MASM对指令的不同处理"><a href="#Debug和MASM对指令的不同处理" class="headerlink" title="Debug和MASM对指令的不同处理"></a>Debug和MASM对指令的不同处理</h1><p>这里的内容是为了下面的学习顺利进行所提供的预备知识。</p><p>还记得吗？我们在Debug中写过这样的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure><p>这条指令表示将DS:0处的数据送入AX中，但是在汇编源程序中，MASM会把它看做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br></pre></td></tr></table></figure><p>OMG!这可不好，这完全是两种意思。那我们要在源程序中将内存单元的内容送入寄存器中怎么办呢？有两种解决办法：</p><p>1.使用[BX]</p><p>先将段地址送入DS中，再将偏移地址送入BX，使用MOV AL,[BX]就可以将((DS)×16+(BX))中的内容送入AL中啦。(Tips:寄存器DS不可以直接使用mov指令对其赋值。)</p><p>2.在偏移地址前显示指出段地址</p><p>这个方法就比较简单了，我们将段地址送入DS后，只需要使用DS，在偏移地址前显示的指明段地址如MOV AL,DS:[0]这样就可以将((DS)×16+(0))中的内容送入AL里啦。</p><h1 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h1><p>上面我们讲到了两种方法用来解决MASM操作内存单元的问题，其中第二种方法使用了段寄存器显示指明段地址的方式，当然了这个段寄存器不止可以是DS还可以是CS、SS、ES这都可以用来指明内存单元的段地址，CS：、SS：、ES：、DS：在汇编语言中被称作段前缀。</p><h1 id="一段安全的空间"><a href="#一段安全的空间" class="headerlink" title="一段安全的空间"></a>一段安全的空间</h1><p>还记得吗？我们最最开始讲到过的内存地址空间，我们抽象了各个硬件的内存将他们汇总为一个整体叫做内存地址空间，其中有一部分存放着一些重要的系统数据和代码，这就意味着随意的修改一个地址中的内容是十分危险的。比如修改0:26H处内容，这将导致你的DOSBOX卡死，这是因为0:26H处放着重要的系统数据。可见，我们不可以在不能确定一段内存空间是否存放重要的数据或代码时，随意的向其中写入内容，我们要使用操作系统分配给我们的内存空间，下一章我们会对这一空间有所认识。</p><p>因为运行在CPU实模式下的DOS无法对硬件进行严格的管理，所以我们可以真正的去尝试、理解、体会硬件的工作，诸如Windows、Unix这些运行在CPU保护模式下的操作系统中，想要使用汇编语言去操作硬件这是不可能的。而且我们使用DOXBOX也不需要为这些危险行为买单，所以不要害怕这些危险操作。</p><p>虽然我们不需要为危险行为买单，但在学习过程中，因为不小心修改了某个关键的系统数据就要从头来过还是非常痛苦的事情，所以我们要找到一段安全的空间供我们使用。一般来讲0:200~0:2ff这256个字节空间就是非常好的选择。至于为什么一定是这里安全，我们以后会再讨论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
</feed>
