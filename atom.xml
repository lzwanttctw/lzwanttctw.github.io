<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuzheng&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-11-21T09:14:55.183Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>liu zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>就决定是你了!IO多路复用!</title>
    <link href="http://example.com/2022/11/18/%E5%B0%B1%E6%98%AF%E4%BD%A0%E4%BA%86-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://example.com/2022/11/18/%E5%B0%B1%E6%98%AF%E4%BD%A0%E4%BA%86-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2022-11-18T09:13:56.000Z</published>
    <updated>2022-11-21T09:14:55.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可恶！这怎么办！"><a href="#可恶！这怎么办！" class="headerlink" title="可恶！这怎么办！"></a>可恶！这怎么办！</h1><p>还记得上一次，我们接触网络编程后出现的问题吗？我们当时写了一个简单的服务端，可以接收到客户端传输给我们的信息，但我们有一些问题没有解决，我们的服务端是一次性的，我们加上了while(1)，但是，断开连接后又出现了问题，我们的服务器会一直进行接收动作，而且其他的客户端连接不上我们了，所以显然单纯的一个while是不可以的。可恶啊！这该怎么办？</p><h1 id="一个线程一个客户端？"><a href="#一个线程一个客户端？" class="headerlink" title="一个线程一个客户端？"></a>一个线程一个客户端？</h1><p>单纯的加while已经是彻底失败了，现在我们的一个线程就能处理一个客户端连接，和消息的接收发送……嘶，那我们何不开多个线程呢？一个线程负责一个客户端，这不就好了嘛！咱说干就干：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">routine</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> clientfd = *(<span class="type">int</span> *)arg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buffer[BUFFER_LENGTH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ret = recv(clientfd, buffer, BUFFER_LENGTH, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">close(clientfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buffer : %s, ret: %d\n&quot;</span>, buffer, ret);</span><br><span class="line"></span><br><span class="line">ret = send(clientfd, buffer, ret, <span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line"><span class="keyword">if</span> (listenfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = fcntl(listenfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(listenfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">listen(listenfd, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line"><span class="type">int</span> clientfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;len);</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> threadid;</span><br><span class="line">pthread_create(&amp;threadid, <span class="literal">NULL</span>, routine, &amp;clientfd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们再来测试一下，这一会程序没有问题了，无论是连接发送消息还是断开连接，亦或是多个客户端连接都没问题，但这之中还是有一个问题，线程是需要占用内存的越多的线程就意味着内存也要被占用更多，如果我们现在有100w人连接，显然我们需要超级多的内存，显然这个方法在高并发中并不是很好的解题方法，一定还有更好的……</p><h1 id="就决定是你啦-IO多路复用"><a href="#就决定是你啦-IO多路复用" class="headerlink" title="就决定是你啦!IO多路复用!"></a>就决定是你啦!IO多路复用!</h1><p>IO多路复用是一种同步IO模型，单个进程/线程就可以同时处理多个IO请求。一个进程/线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu控制权。多路是指多条网络连接，复用指的是同一个进程/线程。一个进程/线程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程/线程，这就是多路复用。多路复用主要有三种实现分别是select、poll、epoll，我们接下来一个一个的认识一下。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>在写代码之前，我们先来仔细的了解一下整体的流程和工作原理，接下来的poll、epoll我们也是如此，磨刀不误砍柴工，理解工作原理十分重要。</p><p>首先我们来看看select的故事叭！select最开始会找三个“数组”，这三个“数组”分别是读集合，写集合，异常集合（主要还是看你想要关注的事件是什么，如果你只关心读事件，那么select就只会找一个“数组”），如果我们想让select监听某一个fd是否可以读了，那么我们就把它放到读集合里面并标记一下，如果监听一个fd是否可写了那我们就把它放在写集合里面并标记一下，之后select就拿着小树枝一遍一遍的轮询，一个一个的指，如果有某个fd或者多个fd出现了事件，那么select就停止轮询，将没有事件发生的位置0，然后返回一个正整数（这个正整数实际上是三个集合里面有事件的fd的数量总和，但好像没啥用……），之后我们就开始遍历这些fd看看到底是那个fd在那个集合里面被标记了，然后根据所在集合和是否被标记，来判断一个fd有什么事件，然后我们去处理，select很听话，如果我们不告诉它等多久，它就会乖乖的一直等待，等到有事件了才会继续进行下面的程序，所以select是一个阻塞函数。</p><p><img src="1.png" alt="select的工作流程（一个集合版）"></p><p>select的”数组”设计的十分巧妙：select选取了3个128个字节大小的空间当做这三个“数组”，它把这128个字节展开为1024比特，每一个比特位就代表一个文件描述符，如果一个文件描述符被加入了“数组“中就以fd为索引，将对应索引位的值置1，这就是标记，“数组”其实应该叫做位图。</p><p>这里插一句题外话，一般来讲<strong>文件描述符的分配规则是在 files_struct 数组当中，找到当前没有被使用的最小的一个下标，作为新的文件描述符。所以分配的fd一般都是按照顺序分配的，当你关闭了之前的fd那么新的fd就会使用这个被关闭了的fd。</strong>比如我们之前分配的fd是3,4,5，那么下一个fd应该是6，如果现在我关闭了3号fd，然后我再分配一个fd那么这个fd应该是3，而不是7。</p><p>好了，我们已经知道select工作的整体流程了，接下来我们就来看看代码怎么写。根据故事我知道select需要三个位图，这个位图系统已经为我们封装好了叫做fd_set。之后我们当然还需要select函数喽，没有select谁帮我们看着呀，然后我们还需要四个工具，一个给我们用来看看哪一个被标记了，剩下三个给select，让它帮我们标记用。有了这些我们就可以开始写代码啦，我们先来看看这些东西是什么样子的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span></span><br><span class="line"><span class="comment">       from the global namespace.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">select</span> <span class="params">(<span class="type">int</span> __nfds, fd_set *__restrict __readfds,</span></span><br><span class="line"><span class="params">   fd_set *__restrict __writefds,</span></span><br><span class="line"><span class="params">   fd_set *__restrict __exceptfds,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> timeval *__restrict __timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>FD_SET(fd, fdsetp)__FD_SET (fd, fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>FD_CLR(fd, fdsetp)__FD_CLR (fd, fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>FD_ISSET(fd, fdsetp)__FD_ISSET (fd, fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>FD_ZERO(fdsetp)__FD_ZERO (fdsetp)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="type">__kernel_time_t</span>tv_sec;<span class="comment">/* seconds */</span></span><br><span class="line"><span class="type">__kernel_suseconds_t</span>tv_usec;<span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>fd_set虽然看起来有点……可怕，但没关系我们先不用注重里面是怎么回事，我们先来看下面的select函数：</p><ol><li>select函数有五个参数，第一个参数是最大fd值+1，这里为啥要指定是“最大fd值+1”nie？因为如果只是最大fd值的话，那么最大这个fd就不会被检测了，就好像是数组一样，如果你说最大的索引值要是10的话，那声明的时候应该是11，那如果比10还小，那最大索引就更不可能是10了，同样select第一个参数也是如此，如果我们要检测fd0~4，那么我们这里的参数应该填5。</li><li>第二个，第三个，第四个参数就是故事里所说的三个位图啦，分别是读位图，写位图，异常位图，如果你需要检测就把对应的参数填上，如果你说你一个都不想监听，那就填NULL就好了，这样select就变成了一个高精度的计时器。</li><li>最后一个参数是等待时间，它有三种情况，如果是NULL，那么select就会坐在那里乖乖的等着，如果我们指定了时间，也就是第五个参数struct timeval这个结构体被指定了，那么select就会严格的按照规定好的时间等待，期间有时间就停止等待然后告诉我们有事件啦，如果没有就会一直等待，直到超时了就不再等待了。timeval结构体有两个属性，一个是tv_sec代表秒，一个是tv_usec代表微秒，所以如果你什么都不想监听，那可以设置select的时间，让它成为一个微秒级的计时器。</li></ol><p>之后是四个工具：</p><ol><li>FD_ZERO函数的参数只有一个，那就是一个fd_set，这个函数会将传入的fd_set全部位设为0，我们每一次声明一个fd_set后都要记得将它置0哦~</li><li>FD_SET函数的参数有两个，一个是fd，一个是fd_set，这个函数会将传入的fd值当做索引，然后去传入的位图中，找到对应索引位，并将该位置1</li><li>FD_CLR函数也是两个参数，它的作用和FD_SET正好相反，它会将对应索引位置0</li><li>FD_ISSET函数就是留给我们自己的啦，虽然select函数很乖，但有点笨笨~，它不会告诉我们到底是哪一位被标记了，那我们也没办法知道到底是哪一个fd有事件发生，所以我们就要拿着所有fd号去我们想要监听的集合里面问，这个fd有没有在这里被标记呀？如果你社恐的话，FD_ISSET可以帮你问，如果你不社恐的话……也请用FD_ISSET问。</li></ol><p>好，我们知道了这些都是做什么用的了，我们来写代码叭！！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_LENGTH128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// </span></span><br><span class="line"><span class="keyword">if</span> (listenfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listen(listenfd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">fd_set rfds, wfds, rset, wset;</span><br><span class="line"></span><br><span class="line">FD_ZERO(&amp;rfds);</span><br><span class="line">FD_SET(listenfd, &amp;rfds);</span><br><span class="line">FD_ZERO(&amp;wfds);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maxfd = listenfd;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buffer[BUFFER_LENGTH] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">rset = rfds;</span><br><span class="line">wset = wfds;</span><br><span class="line"></span><br><span class="line">select(maxfd+<span class="number">1</span>, &amp;rset, &amp;wset, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;listenfd --&gt; \n&quot;</span>);</span><br><span class="line">            </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line"><span class="type">int</span> clientfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;len);</span><br><span class="line"></span><br><span class="line">FD_SET(clientfd, &amp;rfds);</span><br><span class="line"><span class="keyword">if</span> (clientfd &gt; maxfd) maxfd = clientfd;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = listenfd+<span class="number">1</span>; i &lt;= maxfd;i ++) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(i, &amp;rset)) &#123; </span><br><span class="line">ret = recv(i, buffer, BUFFER_LENGTH, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">close(i);</span><br><span class="line">FD_CLR(i, &amp;rfds);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buffer : %s, ret: %d\n&quot;</span>, buffer, ret);</span><br><span class="line">FD_SET(i, &amp;wfds);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (FD_ISSET(i, &amp;wset)) &#123;</span><br><span class="line">ret = send(i, buffer, BUFFER_LENGTH, <span class="number">0</span>); <span class="comment">// </span></span><br><span class="line">FD_CLR(i, &amp;wfds); <span class="comment">//</span></span><br><span class="line">FD_SET(i, &amp;rfds);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看起来好像有点长，不过没关系，我们一点点的看，最开始还是老三件socket，bind，listen。</p><p>之后我们声明了，四个位图，两个是读位图一个是原先的版本rfds，一个是副本rset，同样写位图也有两个，也是一个原版本，一个副本，至于为什么每样要声明两个，我们继续往下看，声明好了之后我们把rfds，wfds清零，并把listenfd放到rfds中，这样等一下select就可以监听listenfd是否有可读事件发生了。之后我们还要声明一个最大的fd并把listenfd的值赋给它，我们之前也说正常来讲fd的分配都是按照一定顺序来的，我们现在只往里面放了listenfd所以最大的fd号就是listenfd的值（这个值应该是3，因为在linux中0是标准输入，1是标准输出，2是标准异常）。然后我们还声明了一个字符串用来接收和发送消息，一个ret用来接收recv的返回值。</p><p>之后我们写了一个while循环，因为我们希望我们的服务器是可以重复使用的而不是一次性的，之后我们就用到了我们的副本，我们将原版本中的值赋给副本，然后使用select去监听副本rset和wset，因为select会清除没有事件发生的fd，这个不是我们希望的，我们只希望我们客户端断开连接后才清除，所以采用了监听副本的方式。当监听到了有事件了，就开始继续执行下去，我们首先要看一下这个事件是不是listenfd发出的读事件，别的fd发出的fd并不需要连接，所以我们要对listenfd的读事件进行单独的处理，我们也知道listenfd我们关心的也只是读事件，所以我们直接使用FD_ISSET看看，listenfd在rset中有没有被标记，如果有那么我们就accept建立连接，并且将新分配的客户端fd加入到rfds中，那为什么不一起加入到wfds中呢？因为我们这个业务是客户给我们发啥，我们就给客户返回啥，客户都还没发我们怎么给人返回呢？</p><p>如果没有那么这个事件应该是某一个客户端发出的，所以我们就开始拿着所有的fd去一个一个集合问。之后我们使用了一个for循环，循环从listenfd+1开始直到maxfd，因为我们刚才已经判断过listenfd了所以不需要再一次判断了，判断到maxfd也没有必要继续下去了，因为剩下的我们都没有分配怎么可能有事件发生。之后我们开始拿着fd问问读集合，我这个fd这里还有没有标记呀，有就是有事件没有就是没事件，然后我再去问问写集合，如果也没有那么这个fd就是没有事件发生，我们就换下一个fd在问，直到我们找到了发生事件的fd，然后我们处理事件。</p><p>这样就完成了IO多路复用，多个连接多个事件通过select在一个线程上得到处理。</p><p><img src="2.png" alt="select IO多路复用"></p><p>select虽然很好，但这个笨笨的小家伙还是有点缺点：</p><ol><li>每次调用都需要重新设置fd_set</li><li>频繁的从用户态切换内核态进行拷贝，效率不高效</li><li>底层采用轮询机制，大量连接下效率很低。</li><li>select 支持监听的fd有限。</li><li>我们没有办法知道到底是那个fd发生事件了，只能再一次轮询</li></ol><p>因为这些缺点的存在所以人们又发明了其他的实现IO多路复用的方法，poll。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll实际上和select的机制相同，也是通过轮询和判断状态进行的，根据描述符的状态进行处理，但是 poll() 没有最大文件描述符数量的限制（但是数量过大后性能也是会下降）。poll() 和 select() 同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><p>我们也简单的来看一下poll的函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;<span class="comment">/* File descriptor to poll.  */</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> events;<span class="comment">/* Types of events poller cares about.  */</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> revents;<span class="comment">/* Types of events that actually occurred.  */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *__fds, <span class="type">nfds_t</span> __nfds, <span class="type">int</span> __timeout)</span>;</span><br></pre></td></tr></table></figure><p>我们先来看pollfd这个结构体，这个结构体里面有三个属性，分别是一个文件描述符fd，一个等待的时间，一个实际发生的事件。fd很好理解，就是指定poll要监听的fd，事件events和实际发生事件revents也很好理解，事件events就是我们去指定我们监听的fd可能会发生什么事件，实际发生事件就是我们监听后实际发生过得事件，这个实际发生事件并不需要我们指定而是内核给我们返回的。事件和实际发生事件有这些取值：</p><p><img src="3.png" alt="poll事件取值"></p><p>这里面events无法取值异常事件的三个值，其他都可以取到，revent是都可以取到的。</p><p>然后我们看poll函数，poll函数三个参数，第一个就是我们刚才讲的我们可以声明一个pollfd的结构体数组，然后传给poll这样就可以监听多个fd了，第二个nfds是我们最多可以监听文件描述符的数量，第三个就是时间检测，如果我们没有指定那他就会一直等。之后我们就可以循环的去看数组中每一个pollfd的revents到底是什么，对不同的事件进行不同的处理。</p><p>虽然poll解决了select监听数有限，每一次都需要从新设定fd_set，这两个问题，但是其他问题几乎都没有解决，所以人们也没有很器重这个做法而是找到了更好的也可以说是现在最好的解决办法：epoll。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll是现在实现IO多路复用最好的技术，它解决了select和poll的问题，成为了高并发服务器的大杀器。</p><p>我们来看一看epoll的故事，epoll是一位优秀的快递员，不同于select和poll一家一户的上门询问，epoll采用了更好的办法，它在业主楼下设立了一个快递站，楼内居住的业主谁有快递了就把快递丢到快递点就好，epoll只要去从快递点取快递就好了，不需要一家一户的问有没有快递要收，而且epoll还可以根据快递上面的信息知道每一个快递的主人是谁。如果有新的业主入住或者以前的业主搬走了又或者是其他什么事情都需要告诉epoll一声，毕竟为大家带来了这么多便利，和大家的关系还是不错的。</p><p>epoll的故事很短，但是epoll也很强大，接下来我们就先来看看如何使用epoll吧！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *ptr;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">uint32_t</span> u32;</span><br><span class="line">  <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> events;<span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="type">epoll_data_t</span> data;<span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">epoll_create</span> <span class="params">(<span class="type">int</span> __size)</span> __THROW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">epoll_ctl</span> <span class="params">(<span class="type">int</span> __epfd, <span class="type">int</span> __op, <span class="type">int</span> __fd,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> epoll_event *__event)</span> __THROW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">epoll_wait</span> <span class="params">(<span class="type">int</span> __epfd, <span class="keyword">struct</span> epoll_event *__events,</span></span><br><span class="line"><span class="params">       <span class="type">int</span> __maxevents, <span class="type">int</span> __timeout)</span>;</span><br></pre></td></tr></table></figure><p>epoll有三个重要的函数分别是epoll_create、epoll_ctl、epoll_wait。我们分别来看看：</p><ol><li>epoll_create：这个函数是用来创建一个epoll实例的，它返回了一个int类型数据，我们知道的在linux下皆为文件，所以返回的int数据其实就是一个新的文件描述符，也就是epoll实例的fd，这个函数的参数很有意思，只要是一个非零数即可无论是1还是1000效果都是一样的，有兴趣的小伙伴可以看看这个是因为什么，欢迎留言告诉博主哦。</li><li>epoll_ctl：这个函数是业主用来告诉epoll事情的，它有四个参数，第一个就是平日里和自己打交道的epollfd，第二个是操作（业主要做的事情），操作有三个取值分别是EPOLL_CTL_ADD（你好呀！我要搬进来住啦！:)  ）、EPOLL_CTL_DEL（再见了我要搬走了 :(  ）、EPOLL_CTL_MOD（我们从8楼搬到2楼啦，爬楼好累 :| ）。第三个参数是业主，到底是那个业主需要通知epoll，这就是第三个参数，第四个参数是一个epoll_event结构体，那我们就来看看epoll结构体，epoll结构体有两个属性，一个是联合体epoll_data，一个是events，events就是我们关心的事情，我们快递只负责收，只负责发，或者有人可以发有人可以收，都体现在这个events上了，events可以是下面几个参数的集合：<img src="4.png" alt="events取值">data就是故事里所说的快递上的信息，这里面我们需要关注的就是联合体内的fd，这个需要我们初始化，最后一个参数的作用就是将关注的事件和对应的业主联系起来。</li><li>epoll_wait：这个函数是epoll定时去快递站看看有没有快递，它有四个参数，第一个是快递员epoll，第二个是事件集合，epoll虽然很厉害很勤奋，但他还是要把快递取回来让我们处理，这个事件集合就是我们需要处理的所有事件，第三个参数就是事件集合的大小，第四个代表epoll是按照什么样的频率去快递站，单位是毫秒，如果是0就代表立马返回，如果是-1就阻塞等待，如果是5000，那就是5秒一返回。</li></ol><p>知道了这些接下来我们就开始写代码吧！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_LENGTH10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENTS_LENGTH128</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> rbuffer[BUFFER_LENGTH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> wbuffer[BUFFER_LENGTH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// </span></span><br><span class="line"><span class="keyword">if</span> (listenfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> flag = fcntl(listenfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(listenfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">listen(listenfd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">EVENTS_LENGTH</span>];</span></span><br><span class="line">ev.events = EPOLLIN ;</span><br><span class="line">ev.data.fd = listenfd; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev); <span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nready = epoll_wait(epfd, events, EVENTS_LENGTH, <span class="number">-1</span>); <span class="comment">// -1, ms </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------------%d\n&quot;</span>,nready);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; nready;i ++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (listenfd == events[i].data.fd) &#123; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line"><span class="type">int</span> clientfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,clientfd);</span><br><span class="line"><span class="keyword">if</span> (clientfd == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">ev.data.fd = clientfd;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, clientfd, &amp;ev);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN ) &#123; </span><br><span class="line"></span><br><span class="line">fcntl(events[i].data.fd, F_SETFL, flag);</span><br><span class="line"><span class="type">int</span> n = recv(events[i].data.fd, rbuffer, BUFFER_LENGTH, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">rbuffer[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recv: %s, n: %d\n&quot;</span>, rbuffer, n);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">memcpy</span>(wbuffer, rbuffer, BUFFER_LENGTH);</span><br><span class="line"></span><br><span class="line">ev.events = EPOLLOUT | EPOLLET;</span><br><span class="line">ev.data.fd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_MOD, events[i].data.fd, &amp;ev);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_DEL, events[i].data.fd, &amp;ev);</span><br><span class="line">close(events[i].data.fd);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line"></span><br><span class="line">fcntl(events[i].data.fd, F_SETFL, flag);</span><br><span class="line"><span class="type">int</span> sent = send(events[i].data.fd, wbuffer, <span class="built_in">strlen</span>(wbuffer), <span class="number">0</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sent: %d\n&quot;</span>, sent);</span><br><span class="line"></span><br><span class="line">ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">ev.data.fd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_MOD, events[i].data.fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来一点点的看代码：</p><p>首先不用多说肯定是我们的socket、bind、listen。之后我们声明了ev和events[EVENTS_LENGTH]，分别用来等一下绑定事件与fd、充当事件集合。然后我们让listenfd入住。之后我们进入一个for循环，因为我们只需要处理事件集合中的全部事件即可所以我们的for循环判断终止条件是事件的个数即可。之后我们就开始判断了如果事件的fd是listenfd那么证明有人需要入住啦，所以我们就开始办理入住手续，如果不是listenfd，那么可能就是有人希望收快递，那我们就开始处理收快递的事件，如果收到的快递里面是空盒，那么说明有人要搬走了，我们就关闭当前事件的fd，然后调用epoll_ctl告诉epoll一声，要搬走了以后不用关心我了。同样如果是有人要发快递，那我们就处理发快递的事件。这样就解决了轮询效率低下的问题。</p><h1 id="水平触发和边缘触发"><a href="#水平触发和边缘触发" class="headerlink" title="水平触发和边缘触发"></a>水平触发和边缘触发</h1><p>刚刚我们介绍epoll的时候说到了一个边缘触发，而且是相对于水平触发说的，那什么是水平触发呢？什么又是边缘触发呢？这里我们简单的给出两条概念：</p><p>边缘触发(ET)，无论是对于读事件还是写事件，ET只会因为这三种情况被触发：</p><ol><li>buffer由不可读\不可写转变为可读\可写</li><li>buffer中内容变多\变少</li><li>当buffer不为空\满，且用户对对应的fd进行了epoll_mod_IN\epoll_mod_OUT事件</li></ol><p>水平触发(LT)，它的触发条件就更为宽松了，只要缓冲区有东西就会触发。</p><p>接下来我们看几个小例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> epfd,nfds;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev,events[<span class="number">5</span>];<span class="comment">//ev用于注册事件，数组用于返回要处理的事件</span></span><br><span class="line">    epfd=<span class="built_in">epoll_create</span>(<span class="number">1</span>);<span class="comment">//只需要监听一个描述符——标准输入</span></span><br><span class="line">    ev.data.fd=STDIN_FILENO;</span><br><span class="line">    ev.events=EPOLLIN|EPOLLET;<span class="comment">//监听读状态同时设置ET模式</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,STDIN_FILENO,&amp;ev);<span class="comment">//注册epoll事件</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">   &#123;</span><br><span class="line">     nfds=<span class="built_in">epoll_wait</span>(epfd,events,<span class="number">5</span>,<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nfds;i++)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span>(events[i].data.fd==STDIN_FILENO)</span><br><span class="line">           cout&lt;&lt;<span class="string">&quot;hello world!&quot;</span>&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="5.png" alt="边缘触发"></p><p>当我们输入一组字符后，这组字符被送到了缓冲区里面，因为这一次输入让缓冲区从空变成了非空，所以epoll_wait认为监听的STDIN_FILENO（标准输入）有事件发生了，所以就触发了一次，之后因为我们没有把字符从缓冲区读出来，所以缓冲区里面字符长度没变，还是非空的，所以epoll_wait就认为没有事件发生，所以会阻塞在epoll_wait。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> epfd,nfds;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev,events[<span class="number">5</span>];</span><br><span class="line">    epfd=<span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    ev.data.fd=STDIN_FILENO;</span><br><span class="line">    ev.events=EPOLLIN;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,STDIN_FILENO,&amp;ev);</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">   &#123;</span><br><span class="line">     nfds=<span class="built_in">epoll_wait</span>(epfd,events,<span class="number">5</span>,<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nfds;i++)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span>(events[i].data.fd==STDIN_FILENO)</span><br><span class="line">           cout&lt;&lt;<span class="string">&quot;hello world!&quot;</span>&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="6.png" alt="水平触发"></p><p>这一回，程序疯狂的打印hello world这也符合我们的预期，因为数据一直停留在缓冲区，而且epoll_wait监听的事件触发方式是水平触发，所以epoll_wait认为STDIN_FILENO一直有事，所以就一直打印hello world。</p><p>我们再来小小修改一下水平触发的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> epfd,nfds;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev,events[<span class="number">5</span>];</span><br><span class="line">    epfd=<span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    ev.data.fd=STDIN_FILENO;</span><br><span class="line">    ev.events=EPOLLIN;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,STDIN_FILENO,&amp;ev);</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">   &#123;</span><br><span class="line">     nfds=<span class="built_in">epoll_wait</span>(epfd,events,<span class="number">5</span>,<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nfds;i++)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">if</span>(events[i].data.fd==STDIN_FILENO)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">read</span>(STDIN_FILENO,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;hello world!&quot;</span>&lt;&lt;endl;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="7.png" alt="水平触发"></p><p>这回的结果很有意思，但不难理解，因为我们输入了三个字符每一次只能读两个，所以我们读了两次打印了两次把所有字符读完了之后epoll_wait认为所有事情都处理完了，所以就阻塞等待了。</p><p>最后我们再来看一个小例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> epfd,nfds;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev,events[<span class="number">5</span>];</span><br><span class="line">    epfd=<span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    ev.data.fd=STDIN_FILENO;</span><br><span class="line">    ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,STDIN_FILENO,&amp;ev);</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">   &#123;</span><br><span class="line">     nfds=<span class="built_in">epoll_wait</span>(epfd,events,<span class="number">5</span>,<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nfds;i++)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">if</span>(events[i].data.fd==STDIN_FILENO)</span><br><span class="line">        &#123;</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;hello world!&quot;</span>&lt;&lt;endl;</span><br><span class="line">          ev.data.fd=STDIN_FILENO;</span><br><span class="line">          ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">          <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,STDIN_FILENO,&amp;ev);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="8.png" alt="使用mod触发"></p><h1 id="epoll真的已经是强无敌了吗？"><a href="#epoll真的已经是强无敌了吗？" class="headerlink" title="epoll真的已经是强无敌了吗？"></a>epoll真的已经是强无敌了吗？</h1><p>我们之前说epoll是IO多路服用最好的实现方式了，可是难道真的已经是强无敌了嘛？我们可以看到在程序中还是存在着一些漏洞和瑕疵，比如我们所有的客户端都共用一个字符空间，这可能就会成为我们未来程序崩溃的原因之一，当然还有其他问题，或许我们需要借助某种设计来改善它，欲知后事如何，请听下回分解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;可恶！这怎么办！&quot;&gt;&lt;a href=&quot;#可恶！这怎么办！&quot; class=&quot;headerlink&quot; title=&quot;可恶！这怎么办！&quot;&gt;&lt;/a&gt;可恶！这怎么办！&lt;/h1&gt;&lt;p&gt;还记得上一次，我们接触网络编程后出现的问题吗？我们当时写了一个简单的服务端，可以接收到客户端</summary>
      
    
    
    
    <category term="C" scheme="http://example.com/categories/C/"/>
    
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>套接字编程？那是什么？</title>
    <link href="http://example.com/2022/11/17/%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%9F%E9%82%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://example.com/2022/11/17/%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%9F%E9%82%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2022-11-17T03:06:03.000Z</published>
    <updated>2022-11-21T05:29:50.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="套接字编程？那是什么？"><a href="#套接字编程？那是什么？" class="headerlink" title="套接字编程？那是什么？"></a>套接字编程？那是什么？</h1><p>这篇文章，我们来看看网络编程，一个合格的后端开发者，网络编程是他必经的一条道路，可能有的小伙伴接触过网络原理，知道OSI模型，TCP/IP模型等等，知道很多网络通信的流程，知道很多复杂的原理，虽然底层很复杂，但好在我们并不需要直接的去操作那些来进行网络通讯，已经有大佬为我们封装好了，我们只需要会使用封装好的接口就好了。实际上，网络编程就是围绕着socket也就是我们所说的套接字进行的。所以有的时候就会有人说，网络编程实际上就是套接字编程，从某些意义上也没啥问题。</p><h1 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h1><p>还记得那句经典的话吗？“Linux下一切皆文件”，Linux 系统中把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行 I/O 操作的系统调用都会通过文件描述符。网络的连接也是一种I/O操作，所以我通过fd来进行一系列操作。</p><h1 id="socket编程的流程"><a href="#socket编程的流程" class="headerlink" title="socket编程的流程"></a>socket编程的流程</h1><p>无论是服务端还是客户端，都是通过socket进行连接然后通信的，但两方需要进行的事情并不相同，具体流程如下：</p><p><img src="1.png" alt="socket通信的流程"></p><p>我们可以看到server端和client端都需要先通过socket()创建socket，然后server端需要绑定socket和端口号，在通过listen()让绑定好的socket进入监听状态，这个时候我们server端就已经准备好进行连接了，之后我们的client就可以通过connet()和server端进行连接了，成功连接以后，server端和client端就可以进行消息传输了，待传输就结束，双方断开连接，关闭socket。fd在这里的体现并不明显，甚至都没有提到fd，其实fd就是一个socket的索引，这个等一下我们介绍API写代码的时候就可以知道了。接下来我们着重从server方面来了解这些函数。</p><h1 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><p>这就是socket函数的原型，它返回一个int数据，这个返回的数据就是我们所说的fd，它用来标志是哪一个socket。socket函数需要三个参数，分别是domain，type，protocol。</p><p>domain代表的是用于设置网络通信的域，函数socket()根据这个参数选择协议族。它有以下这几个值：</p><table><thead><tr><th align="center">名称</th><th align="center">含义</th><th align="center">名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">PF_UNIX,PF_LOCAL</td><td align="center">本地通信</td><td align="center">PF_X25</td><td align="center">ITU-T X25 / ISO-8208协议</td></tr><tr><td align="center">AF_INET,PF_INET</td><td align="center">IPv4 Internet协议</td><td align="center">PF_AX25</td><td align="center">Amateur radio AX.25</td></tr><tr><td align="center">AF_INET6,PF_INET6</td><td align="center">IPv6 Internet协议</td><td align="center">PF_ATMPVC</td><td align="center">原始ATM PVC访问</td></tr><tr><td align="center">PF_IPX</td><td align="center">IPX-Novell协议</td><td align="center">PF_APPLETALK</td><td align="center">Appletalk</td></tr><tr><td align="center">PF_NETLINK</td><td align="center">内核用户界面设备</td><td align="center">PF_PACKET</td><td align="center">底层包访问</td></tr></tbody></table><p>我们常使用的是AF_INET和AF_INET6。</p><p>type代表的是用于设置套接字通信的类型，它的值如下：</p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>SOCK_STREAM</td><td>Tcp连接，提供序列化的、可靠的、双向连接的字节流。支持带外数据传输</td></tr><tr><td>SOCK_DGRAM</td><td>支持UDP连接（无连接状态的消息）</td></tr><tr><td>SOCK_SEQPACKET</td><td>序列化包，提供一个序列化的、可靠的、双向的基本连接的数据传输通道，数据长度定常。每次调用读系统调用时数据需要将全部数据读出</td></tr><tr><td>SOCK_RAW</td><td>RAW类型，提供原始网络协议访问</td></tr><tr><td>SOCK_RDM</td><td>提供可靠的数据报文，不过可能数据会有乱序</td></tr><tr><td>SOCK_PACKET</td><td>这是一个专用类型，不能呢过在通用程序中使用</td></tr></tbody></table><p>我们常用的是SOCK_STREAM和SOCK_DGRAM。</p><p>protocol用于制定某个协议的特定类型，即type类型中的某个类型。通常某协议中只有一种特定类型，这样protocol参数仅能设置为0；但是有些协议有多种特定的类型，就需要设置这个参数来选择特定的类型。</p><p>当我们写好这些函数，那么内核就会给我们一个fd，标志这个我们创建好的socket。</p><h1 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *my_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>好了，我们现在已经创建好了socket了，下一步我们要调用bind函数，将我们创建好的socket和端口进行绑定，那为什么一定要绑定端口呢？想象这样一个问题，现在我们在电脑上同时运行QQ和WeChat，那么我们通过WeChat发出的消息为什么不会被QQ接收到呢？因为两个进程创建的连接所绑定的端口号不同，所以才没有出现我们所说的问题，也就是说绑定端口号是为了将来别的程序和服务器进程连接后，不会出现数据错发的问题。所以我们服务端创建好socket后一定要绑定端口号。</p><p>我们来看bind函数，bind函数会返回一个int数据，这个数据如果是0就代表绑定成功，如果是-1就代表绑定失败，所以我们可以根据返回值来判断是否绑定成功了。bind函数有三个参数，分别是sockfd，sockaddr结构体，socklen_t，也就是结构体的大小。</p><p>sockfd代表一个socket的文件描述符，我们之前创建好的socket的文件描述符就可以在此传入。</p><p>接下来是一个sockaddr结构体指针，那我们先看看sockaddr结构体的内部：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sa_);<span class="comment">/* Common data: address family and length.  */</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];<span class="comment">/* Address data.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>__SOCKADDR_COMMON(sa_prefix) \        <span class="comment">//这里是个宏定义，传进来一个sa_然后和family拼接，就变成了sa_family</span></span></span><br><span class="line">  <span class="type">sa_family_t</span> sa_prefix#<span class="meta">#family</span></span><br></pre></td></tr></table></figure><p>我们可以看到sockaddr结构体内部有两个参数，一个sa_family，一个是sa_data[14]。sa_family代表的是地址族，sa_data[14]包含套接字中的目标地址和端口信息，但它们两个混在了一起并不是我们喜欢的，所以就有了一个新的结构体sockaddr_in：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin_);</span><br><span class="line">    <span class="type">in_port_t</span> sin_port;<span class="comment">/* Port number.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/* Internet address.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr&#x27;.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr)</span><br><span class="line">   - __SOCKADDR_COMMON_SIZE</span><br><span class="line">   - <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>)</span><br><span class="line">   - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;sockaddr_in;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>__SOCKADDR_COMMON(sa_prefix) \        <span class="comment">//这里是个宏定义，传进来一个sin_然后和family拼接，就变成了sin_family</span></span></span><br><span class="line">  <span class="type">sa_family_t</span> sa_prefix#<span class="meta">#family</span></span><br><span class="line">     </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到sockaddr_in就将目标地址和端口信息分开了。而且看起来好像还多了一个属性sin_zero，这个属性是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节，所以我们使用的时候不需要考虑它。</p><p>知道了这些，我们看看在编程的时候应该如何做，我们先声明一个sockaddr_in变量，然后初始化，将sin_family初始化成我们创建socket的时候使用的协议族(也就是domain属性)。之后我们需要绑定的是目的地址和端口号，这里要注意的是我们所输入的数据需要被转换为网络字节序才可以，所以我们需要使用htons(port)和htonl(address)函数才可以比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(<span class="number">9999</span>);</span><br></pre></td></tr></table></figure><p>这里INADDR_ANY代表的是任意地址，比如一台电脑有3块网卡，分别连接三个网络，那么这台电脑就有3个ip地址了，如果某个应用程序需要监听某个端口，那他要监听哪个网卡地址的端口呢？如果绑定某个具体的ip地址，你只能监听你所设置的ip地址所在的网卡的端口，其它两块网卡无法监听端口，如果我需要三个网卡都监听，那就需要绑定3个ip，也就等于需要管理3个套接字进行数据交换，这样岂不是很繁琐？所以我们使用INADDR_ANY不管是那个地址的端口给我返回的信息我们都处理，这样就将三个地址当做了一个地址对待。所以我们使用INADDR_ANY，<strong>当然我们需要使用htonl将它转换为网络字节序</strong>然后在放到.sin_addr.s_addr中。</p><p>之后就是绑定端口号了，计算机端口号从0到65535，其中众所周知端口： 1 - 1023 （1-25之间为众所周知的端口 ， 256 - 1023 为UNIX系统占用），这里说的众所周知端口是一些早已经被固定的端口号，比如80端口分配给WWW服务，21端口分配给FTP服务。注册端口： 1024 -49151 分配给进程或者应用。这些端口号在还没有被服务器资源占用时，可以由用户的APP动态注册获得。动态端口号：49152 - 65535 被称为动态端口号一般不固定分配某种服务而是动态分配的。一般可以使用 65000以上的就可以随便用。我们这里使用9999就可以，<strong>当然我们需要使用htons将它也转换为网络字节序</strong>。</p><p>之后我们进行一次强转就可以了：(struct sockaddr*)&amp;servaddr。</p><p>最后一个参数是我们写好的地址大小了，我们使用sizeof就可以了。</p><p>所以完整的使用应该是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line"><span class="keyword">if</span> (listenfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//如果创建失败就会返回</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr))) &#123;    <span class="comment">//如果绑定失败就会返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="listen"><a href="#listen" class="headerlink" title="listen()"></a>listen()</h1><p>好啦现在已经到了倒数第二步了，我们需要调用listen函数让绑定好的socket进入被动监听模式，让服务器一直监听端口是否有人连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">listen</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">int</span> __n)</span> __THROW;</span><br></pre></td></tr></table></figure><p>我们可以看到listen函数需要两个参数一个是fd，一个是n。其中fd就是socket的fd，我们需要那个socket进入监听状态我们就将那个socket的fd放到里面，n代表的是等待队列10假如我们建立一个连接需要1秒，但同时有12个连接，我们设置的等待队列长度为10，那么有一个会进行连接，剩下10个会等待连接，1个会拒绝连接。</p><h1 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h1><p>我们来看最后一步，accpet接受连接：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">accept</span> <span class="params">(<span class="type">int</span> __fd, __SOCKADDR_ARG __addr,<span class="type">socklen_t</span> *__restrict __addr_len)</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __SOCKADDR_ARGstruct sockaddr *__restrict</span></span><br></pre></td></tr></table></figure><p>accept函数会返回一个int数据，这个数据就是我们之前监听到的连接过来的socket的fd，就好比说，我们原先在本机上打开了一个文件，让这个文件监听端口，然后等到客户端连接服务端后，监听文件检测到端口可读，就将端口的信息读取了出来，在本机上打开，所以我们本机通过accpet接受这个文件，并为它分配一个fd去管理它，如果连接失败了就返回-1。</p><p>accept函数需要三个参数，分别是fd，sockaddr，socklen_t。</p><p>fd，这个fd我们需要的是监听文件的fd，sockaddr和socklent_t代表的是监听到的文件的地址结构体和地址的长度。我们可以理解，我们从监听fd中获取到了客户端连接过来的fd的地址信息，长度，并把信息装进sockaddr中，长度装在socklen_t里面。</p><p>我们一般会这么写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> len =<span class="keyword">sizeof</span>(client);</span><br><span class="line"><span class="type">int</span> clientfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, &amp;len);</span><br></pre></td></tr></table></figure><p>默认情况下，当程序执行到accept后会阻塞在这里不动，当有外来连接之后才会继续进行。当然了其实这是因为监听文件是阻塞的，我们也可以修改监听文件为非阻塞的，那么它就不会等待，当运行到accept后发现如果没有连接那么就跳过继续执行下面的。</p><p>将监听文件修改为非阻塞的代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag = fcntl(listenfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">flag |=O_NONBLOCK;</span><br><span class="line">fcntl(listenfd, F_SETFL,flag);</span><br></pre></td></tr></table></figure><p>设置为非阻塞后，如果没有连接accpet就会返回-1，然后继续下去。</p><h1 id="数据的接收和发送—recv和send"><a href="#数据的接收和发送—recv和send" class="headerlink" title="数据的接收和发送—recv和send"></a>数据的接收和发送—recv和send</h1><p>数据的接收和发送很简单，用到了两个函数一个是recv函数，一个是send函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">ssize_t</span> <span class="title function_">recv</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">void</span> *__buf, <span class="type">size_t</span> __n, <span class="type">int</span> __flags)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">ssize_t</span> <span class="title function_">send</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">const</span> <span class="type">void</span> *__buf, <span class="type">size_t</span> __n, <span class="type">int</span> __flags)</span>;</span><br></pre></td></tr></table></figure><p>我们可以看到两个函数非常相似，他们都需要四个参数，分别是fd，字符数组，字符串长度，flag。</p><p>在recv中，fd表示我要从那个客户端接收消息，第二个字符数组用来装我们接收到的字符，第三个代表我们要接受的字符串长度，第四个参数我们一般置0就好。recv会返回一个int数据，表示我们实际接收到的字符串长度是多少，这里要提的是。</p><p>在send中，fd表示我要向那个客户端发送消息，第二个字符数组用来装我们要发送的字符，第三个代表我们要发送的字符串长度，第四个参数我们同样置0就好。</p><h1 id="简单的服务器和客户端通信"><a href="#简单的服务器和客户端通信" class="headerlink" title="简单的服务器和客户端通信"></a>简单的服务器和客户端通信</h1><p>接下来我们使用一个简单的例子来看看代码是如何书写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> msg_length 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listenfd == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    servaddr.sin_family=AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port=htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">-1</span> == bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0   <span class="comment">//修改为1开启非阻塞</span></span></span><br><span class="line">    <span class="type">int</span> flag = fcntl(listenfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    flag |=O_NONBLOCK;</span><br><span class="line">    fcntl(listenfd, F_SETFL,flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    listen(listenfd,<span class="number">10</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len =<span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> clientfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, &amp;len);</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> msg[msg_length]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ret = recv(clientfd ,msg , msg_length, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;msg: %s\n&quot;</span>,msg);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> returnmsg[msg_length] = &#123;<span class="string">&quot;this is server,success recive msg&quot;</span>&#125;;</span><br><span class="line">    send(clientfd, returnmsg, msg_length , <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;clientfd: %d\n&quot;</span>,clientfd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看一下结果：</p><p><img src="2.png" alt="服务端和客户端沟通"></p><p>看消息顺利的沟通了，但好像有一个问题，我们的服务器怎么只能用一次啊！我们加一个while(1)试试，发现当客户端断开连接后，服务端会重复的打印出我们消息，这不是我们想要的，那我们怎么解决呢？卖个关子，我们下回分解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;套接字编程？那是什么？&quot;&gt;&lt;a href=&quot;#套接字编程？那是什么？&quot; class=&quot;headerlink&quot; title=&quot;套接字编程？那是什么？&quot;&gt;&lt;/a&gt;套接字编程？那是什么？&lt;/h1&gt;&lt;p&gt;这篇文章，我们来看看网络编程，一个合格的后端开发者，网络编程是他必经</summary>
      
    
    
    
    <category term="C" scheme="http://example.com/categories/C/"/>
    
    <category term="Socket" scheme="http://example.com/categories/Socket/"/>
    
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
    <category term="Socket" scheme="http://example.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>C/C++后端开发基础</title>
    <link href="http://example.com/2022/11/15/CC++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/11/15/CC++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2022-11-15T06:28:42.000Z</published>
    <updated>2022-11-19T04:12:35.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一篇作为C/C++后端开发的前导篇，讲述一些比较基本的东西，比如多线程、网络API、新特性、操作系统、计算机网络、数据结构等等，内容非常琐碎，但对于想涉足后端开发的小伙伴们来讲这些都常见到的，万字长文警告，建议搭配目录食用，话不多说，我们立上开始。</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>这一块讲的是linux下一些必须要知道的知识</p><h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>接下来是C++的一些好用的工具，和一些琐碎的知识，建议搭配目录食用。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>博主一直都认为C/C++有两大经典的特性，一个就是宏定义，另一个就是指针了，指针可以方便我们直接的访问地址，大大的提高了程序的性能，也给C/C++程序员更高的自由度，最常见的操作就是我们经常会用new（malloc）在堆上开辟一段空间，然后通过指针去管理它，虽然指针给我们带来了很多好处但同样指针也给我们带来了一定的问题，就好比刚才，带来自由度的同时，也增加了我们操作的复杂度，我们手动开辟空间后，也需要手动的去释放，但你知道的懒也是科技进步的一大原因，人们都知道一个类在销毁的时候会自动调用析构函数，那么我们只要在析构函数中销毁开辟的内存空间不就可以实现自动嘛，就这样智能指针诞生了。</p><p>使用智能指针主要有这么两点好处：</p><ol><li>使用智能指针可以自动释放占用的内存</li><li>共享所有权指针的传播和释放，解决了多线程同时析构一个对象的问题</li></ol><p>C++中原本有四个智能指针分别是auto_ptr、shared_ptr、unique_ptr、weak_ptr，但auto_ptr在后来被C++11弃用了所以我们也不多介绍，下面我们来简单的介绍一下其余三个指针的特点：</p><ul><li>unique_ptr：独享对象的所有权，由于没有引用计数，所以性能会比较好</li><li>shared_ptr：共享对象的所有权，但性能略微逊色</li><li>weak_ptr：和shared_ptr配合使用，解决循环引用的问题</li></ul><p>接下来我们分别详细的介绍一下三个指针：</p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>我们打乱顺序先来介绍一下shared_ptr，在shared_ptr内部包含两个指针，一个指向对象，一个指向控制块，控制块里最关键的部分就是一个引用计数。</p><p><img src="2.png" alt="shared_ptr内部"></p><p>为什么shared_ptr要使用一个引用计数的机制呢？我们刚才说共享指针会共享对象的所有权，也就是可以由多个共享指针指向一个对象，一块内存空间，如果现在我们要销毁一个shared_ptr指针，那么如果它直接就把所指向的内存空间销毁了，那么其他的shared_ptr就没有办法使用了，所以shared_ptr中使用引用计数的方式来解决这个问题，每当有一个shared_ptr指针指向一块相同的地址，那么引用计数就会加1，当所有的shared_ptr都析构了，也就是引用计数归零了，内存才会被释放。我们可以通过shared_ptr的use_count属性看看堆上对象有多少个引用。</p><p>知道了shared_ptr的一些内部原理，我们来看看怎么使用吧！最基本的我们可以通过赋值的方法来进行声明，但是要注意的是不可以将原始指针赋值给一个之智能指针，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p2 = p1;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3;</span><br></pre></td></tr></table></figure><p>OH！我们好像忘记给一个shared_ptr初始化了，不过没关系，我们还可以通过reset方法来初始化它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>当然也要注意当一个shared_ptr有值的时候reset方法会将引用计数减1。</p><p>当然我们还有更高效的方法，我们也更推荐使用这种方法make_shared：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; sp1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>在使用shared_ptr的过程中我们需要取得数据，所以我们需要使用一些函数这里介绍三个：</p><ol><li>get()：返回shared_ptr中指向对象的指针</li><li>use_count()：返回当前引用计数的值</li><li>unique()：若use_count()=1那么返回true，否则返回false</li></ol><p>这里要强调的是get()是一个危险的函数，如果你不知道它有多么危险那么请不要调用它。如果你还是需要调用它，那么请遵守以下三个约定：</p><ul><li>不要保存get函数的返回值，无论是保存为一个普通指针还是一个shared_ptr</li><li>保存为普通指针不一定什么时候它就会变成空指针了，保存为shared_ptr则产生了独立指针</li><li>不要delete掉get函数的返回值，那样会出现对一块内存delete两次的错误</li></ul><p>接下来比较重要的知识点是指定删除器：</p><p>如果用shared_ptr管理非new对象或是没有析构函数的类时，应为其传递一个合适的删除器，我们可以用回调函数或者lambda表达式来实现。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteIntPtr</span><span class="params">(<span class="type">int</span> *p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;call DeleteIntPtr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>), DeleteIntPtr)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>),[](<span class="type">int</span> *p)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call DeleteIntPtr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们使用shared_ptr管理动态数组的时候，需要指定删除器，因为shared_ptr的默认删除器不支持数组对象，所以我们要指定删除器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">p3</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>],[](<span class="type">int</span> *p)&#123; <span class="keyword">delete</span> []p;&#125;);</span><br></pre></td></tr></table></figure><p>接下来我们再来讲三个在使用shared_ptr过程中需要注意的问题：</p><p>1.不要使用一个原始指针初始化多个shared_ptr，因为那样shared_ptr并不会累加计数，这样就会出现一块内存delete两次的错误。</p><p>2.不要在函数实参中创建shared_ptr，因为C++的函数参数的计算顺序在不同的编译器不同的约定下，一般是从右到左的，但也可能是左到右，假如有这样的一条代码，那么应该会先进行new int，然后调用g()，万一g()出现了异常，那么new int 就发生内存泄露了，所以要先创建shared_ptr。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">function</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="type">int</span>),<span class="built_in">g</span>())</span><br></pre></td></tr></table></figure><p>3.不要将this指针作为shared_ptr返回出来，因为本质上this是一个普通指针，因此可能会导致重复delete的问题。如果我们需要这样做的话，正确做法是让当前类继承于enable_shared_from_this &lt; class&gt;然后使用基类方法shared_from_this()。</p><p>最后我们来讨论一下shared_ptr一个比较重要的问题，循环引用和如何避免循环引用。</p><p>首先我们来看一下什么是循环引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::shared_ptr&lt;B&gt; bptr;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">new1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt;<span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>() &#123;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;A is deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::shared_ptr&lt;A&gt; aptr;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">new1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">B</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B is deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::shared_ptr&lt;A&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;B&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> B)</span></span>;</span><br><span class="line">ap-&gt;bptr = bp;</span><br><span class="line">bp-&gt;aptr = ap;</span><br><span class="line">ap-&gt;<span class="built_in">new1</span>();</span><br><span class="line">bp-&gt;<span class="built_in">new1</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ap-&gt;bptr:&quot;</span> &lt;&lt; ap-&gt;bptr &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bp-&gt;aptr:&quot;</span> &lt;&lt; bp-&gt;aptr&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ap:&quot;</span> &lt;&lt; ap &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bp:&quot;</span> &lt;&lt; bp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main leave&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个典型的循环引用的例子，我们可以运行一下，看看结果：</p><p><img src="3.png" alt="循环引用"></p><p>我们可以看到我们new出来A,B的地址，也可以看到分别有两个指针指向它们，这样的一个循环的结构，就导致了当程序执行完当前程序块后，引用计数并不会归零，自然也不会将我们开辟的空间回收，这就导致了内存泄漏，我们常用的解决办法就是把A或者B里的shared_ptr改为weak_ptr，这个我们等以后再说。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr是一个独占型的智能指针，不能将其赋值给另一个unique_ptr，unique_ptr需要指定删除器的类型。虽然unique_ptr不允许赋值给其他unique_ptr但可以通过函数返回给其他的unique_ptr比如move函数，move函数会将自身的所有权转移给其他指针，执行完move函数后自身便不再拥有所有权了。</p><p><img src="1.png" alt="move函数的执行过程"></p><p>unique_ptr的独占的特性，也就导致了它不能直接的被装入任何一个STL容器，不过我们仍然可以通过移动所有权的方式来将它装到容器里面。接下来我们看一下如何声明一个unique_ptr我们可以通过最为普通的方法去声明例如这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;T&gt;<span class="built_in">my_ptr</span>(<span class="keyword">new</span> T)</span><br></pre></td></tr></table></figure><p>我们可以通过new开辟一块空间然后让my_ptr指向它，但这样做有一个缺点，这违背了软件工程中一个重要原则：应该避免代码的重复，代码的重复会引起编译次数的增加，导致目标代码膨胀，所以C++14就将make_unique加入了标准库：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">upw1</span><span class="params">(make_unique&lt;T&gt;(初始化的值))</span></span></span><br></pre></td></tr></table></figure><p>创建好unique_ptr后我们就可以像使用正常指针一样对其解引用等操作了。</p><p>unique_ptr删除器的指定和shared_ptr也不一样，unique_ptr在指定删除器的时候也要指定删除器的类型，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>, <span class="title">void</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>*)</span>&gt; <span class="title">ptr4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>), [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>关于shared_ptr和unique_ptr的使用场景是要根据实际应用需求来选择。如果希望只有一个智能指针管理资源或者管理数组就用unique_ptr，如果希望多个智能指针管理同一个资源就用shared_ptr。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>我们之前介绍的shared_ptr已经很好了，但有的时候shared_ptr仍然会导致内存泄漏，就比如我们所说的循环引用问题。weak_ptr是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象，管理对象内存的还是原先的那个强引用的shared_ptr，weak_ptr只是为管理对象提供了另一个访问手段。weak_ptr设计的目的是为了配合shared_ptr而引入的一种智能指针来协助shared_ptr工作，它只可以从一个shared_ptr或另一个weak_ptr对象构造，它的构造和析构并不会引起引用计数的增加或减少。</p><p>还是那个循环引用的例子，我们稍微修改一下再看一下结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::shared_ptr&lt;B&gt; bptr;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">new1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt;<span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>() &#123;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;A is deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::weak_ptr&lt;A&gt; aptr;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">new1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">B</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B is deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::shared_ptr&lt;A&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;B&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> B)</span></span>;</span><br><span class="line">ap-&gt;bptr = bp;</span><br><span class="line">bp-&gt;aptr = ap;</span><br><span class="line">ap-&gt;<span class="built_in">new1</span>();</span><br><span class="line">bp-&gt;<span class="built_in">new1</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ap-&gt;bptr:&quot;</span> &lt;&lt; ap-&gt;bptr &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bp-&gt;aptr:&quot;</span> &lt;&lt; bp-&gt;aptr.<span class="built_in">lock</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ap:&quot;</span> &lt;&lt; ap &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bp:&quot;</span> &lt;&lt; bp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main leave&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="4.png" alt="move函数的执行过程"></p><p>看！虽然对象还是互相引用了，但因为其中有一个对象中存放的指针是weak_ptr所以并没有使得循环计数增加，所以也就可以正确的释放内存了。</p><p>知道了weak_ptr和shared_ptr之间的配合关系，我们也来看一下三个操作weak_ptr的基本方法：</p><ol><li>use_count()：返回当前引用计数的值</li><li>expired()：可以判断所观察的资源是否已经释放了</li><li>lock()：可以获得所监视\指向的shared_ptr</li></ol><p>我们之前在shared_ptr中还提到过不要直接的返回一个this指针，要通过继承enable_shared_from_this类并通过方法shared_from_this来返回一个指针，原因是enable_shared_from_this类中有一个weak_ptr，这个weak_ptr用来观察this指针，调用shared_from_this()就会调用内部weak_ptr的lock方法，将所观察的shared_ptr返回。需要注意的是，获取自身智能指针的函数尽在shared_ptr的构造函数被调用之后才能使用，因为enable_shared_from_this内部的weak_ptr只有通过shared_ptr才能构造。</p><p>最后在使用weak_ptr之前我们应该调用一次expired()以保weak_ptr是合法的。</p><h3 id="智能指针线程安全的问题"><a href="#智能指针线程安全的问题" class="headerlink" title="智能指针线程安全的问题"></a>智能指针线程安全的问题</h3><p>智能指针尤其是shared_ptr，在多线程中有些时候是不安全，我们主要需要考虑这三点：</p><ol><li>引用计数的加减操作是否线程安全</li><li>修改shared_ptr指向是否线程安全</li><li>shared_ptr&lt; T&gt;的T的并发操作的安全性</li></ol><p>首先是对于引用计数的思考，我们知道shared_ptr有引用计数，这个引用计数被存放在堆上，所以不必担心这个，那每一次增加或者减少引用计数的操作呢？这个也不必担心，因为增加或减少计数这个操作是一个原子操作，所以并不会引发线程安全问题。所以对于引用计数的加减操作是安全的。</p><p>之后是对于修改shared_ptr的思考，我们假设一个场景，我们现在有三个shared_ptr分别是A,B,C：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;FOO&gt; <span class="title">A</span><span class="params">(<span class="keyword">new</span> FOO)</span></span>;</span><br><span class="line">shared_ptr&lt;FOO&gt; B;</span><br><span class="line"><span class="function">shared_ptr&lt;FOO&gt; <span class="title">C</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br></pre></td></tr></table></figure><p>现在A,B,C分别在不同的线程中，我们要将A赋值给B，那么最开始会将A中对象的地址赋值给B中指向对象的指针，然后将控制块的地址赋值给B中指向控制块的指针，这两步操作不会一起进行，它们并不是一个原子操作，所以这个时候就有可能引发线程安全的问题，我们可以仔细的看一下到底会发生什么：</p><p>最开始A指向FOO(1)，B指向FOO(2)</p><p><img src="5.png" alt="智能指针在多线程中"></p><p>之后，本来我们是要让B的控制块指针指向控制块的，但不巧的是线程转换到了C上，那么B就没有顺利的连接到控制块。</p><p><img src="6.png" alt="智能指针在多线程中"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这一篇作为C/C++后端开发的前导篇，讲述一些比较基本的东西，比如多线程、网络API、新特性、操作系统、计算机网络、数据结构等等，内容非常琐</summary>
      
    
    
    
    <category term="C/C++" scheme="http://example.com/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的C/C++程序设计</title>
    <link href="http://example.com/2022/10/28/Linux%E4%B8%8B%E7%9A%84CC++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/10/28/Linux%E4%B8%8B%E7%9A%84CC++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-10-28T07:54:37.000Z</published>
    <updated>2022-11-15T06:26:09.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-中的文件操作"><a href="#C-中的文件操作" class="headerlink" title="C++中的文件操作"></a>C++中的文件操作</h1><p>这一篇开始，我们正式的接触Linux下的C/C++开发，我们使用两个案例帮助大家，快速的掌握流程。</p><p>首先，我们来复习一下C++中对文件应该如何操作。在C++中有一个标准库叫fstream，它其中有三个类，分别是：</p><ol><li>ofstream：该类表示输出文件流，用于创建文件并向文件中写入信息</li><li>ifstream：该类表示输入文件流，用于从文件读取信息</li><li>fstream：该类表示文件流，它同时具有ifstream和ofstream两种功能</li></ol><p>要想在C++中对文件进行处理，那么我们就要同时将头文件fstream和iostream同时引入。</p><h2 id="打开-关闭文件"><a href="#打开-关闭文件" class="headerlink" title="打开/关闭文件"></a>打开/关闭文件</h2><p>我们对文件操作，那我们必然是先打开文件，所以我们实例化一个对象，通过调用实例的open方法来打开一个文件，open含有两个参数一个是文件名，一个是打开模式。打开模式有以下几种：</p><ol><li>ios::app：追加模式，所有的写入都将追加到文尾</li><li>ios::ate：文件打开后定位到文件尾部</li><li>ios::in：打开文件用来读取</li><li>ios::out：打开文件用来写入</li><li>ios::trunc：如果文件存在，其内容将在打开文件之前被截断，即把文件长度设为0</li></ol><p>这些打开模式可以结合使用，比如如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在那么你可以使用<strong>ios::out|ios::trunc</strong>模式打开文件。</p><p>当然有打开就要有关闭，关闭也很简单也是通过对象调用close()函数。</p><h2 id="读取与写入"><a href="#读取与写入" class="headerlink" title="读取与写入"></a>读取与写入</h2><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，使用流提取运算符（ &gt;&gt; ）从文件读取信息，要注意的的是，在这里需要使用 <strong>ofstream</strong> 或 <strong>fstream</strong> 对象。</p><h1 id="C文件的读写"><a href="#C文件的读写" class="headerlink" title="C文件的读写"></a>C文件的读写</h1><p>都说C和C++不分家，那我们也来复习一下C的文件读写。在C里面我们使用FILE*类型数据进行操作。</p><h2 id="打开-关闭文件-1"><a href="#打开-关闭文件-1" class="headerlink" title="打开/关闭文件"></a>打开/关闭文件</h2><p>在C里我们使用fopen函数创建一个新的文件或者打开一个已有的文件并且返回一个FILE类型的指针，fopen函数的原型是这样的**FILE *fopen(const char *filename,const char *mode)**。这里，filename是字符串，用来命名文件，mode是访问模式，mode的值可以是以下的值中的一个：</p><ol><li>r：打开一个已有的文本文件，允许读取文件。</li><li>w：打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，你的程序会从文件的开头写入内容。如果文件存在，则会被截断为零长度，重新写入。</li><li>a：打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。</li><li>r+：打开一个文本文件，允许读写文件。</li><li>w+：打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</li><li>a+：打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</li></ol><p>如果处理的是二进制文件需要使用下列访问模式取代上列访问模式：</p><p>“rb”, “wb”, “ab”, “rb+”, “r+b”, “wb+”, “w+b”, “ab+”, “a+b”。</p><p>在C里面我们使用int fclose(FILE *fp)关闭一个文件。</p><h2 id="读取与写入-1"><a href="#读取与写入-1" class="headerlink" title="读取与写入"></a>读取与写入</h2><p>下面是把字符写入到流中的最简单的函数：*<em>int fputc( int c, FILE <em>fp )</em></em></p><p>函数 <strong>fputc()</strong> 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <strong>EOF</strong>。你可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：**int fputs( const char <em>s, FILE <em>fp );</em></em></p><p>函数 <strong>fputs()</strong> 把字符串 <strong>s</strong> 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <strong>EOF</strong>。您也可以使用 <strong>int fprintf(FILE *fp,const char *format, …)</strong> 函数把一个字符串写入到文件中。但记得这样写的时候和和**fflush(FILE * fp)**组合使用，才能将fprint写到缓存里的数据，落盘到磁盘里。</p><p>下面是从文件读取单个字符的最简单的函数：<strong>int fgetc( FILE * fp );</strong></p><p><strong>fgetc()</strong> 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 <strong>EOF</strong>。下面的函数允许您从流中读取一个字符串：**char *fgets( char <em>buf, int n, FILE <em>fp );</em></em></p><p>函数 <strong>fgets()</strong> 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 <strong>buf</strong>，并在最后追加一个 <strong>null</strong> 字符来终止字符串。</p><p>如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 <strong>int fscanf(FILE *fp, const char *format, …)</strong> 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>C/C++ 数组允许定义可存储相同类型数据项的变量，但是结构体是C/C++ 中另一种用户自定义的可用的数据类型，它允许你存储不同类型的数据项。比如我们可以定义一个书类，我们可以在其中使用string当做书名，int当做价格等等，然后我们可以使用这个自定义的类型声明变量，通过使用操作符“.”来访问它们。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   string  title;</span><br><span class="line">   string  author;</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Books Book1;    </span><br><span class="line">    </span><br><span class="line">   <span class="comment">// Book1 详述</span></span><br><span class="line">   Book1.title=<span class="string">&quot;clean code&quot;</span>;</span><br><span class="line">   Book1.author=<span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">   Book1.book_id = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出 Book1 信息</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;第一本书标题 : &quot;</span> &lt;&lt; Book1.title &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;第一本书作者 : &quot;</span> &lt;&lt; Book1.author &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;第一本书 ID : &quot;</span> &lt;&lt; Book1.book_id &lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="4.jpg" alt="输出结构体内容"></p><h1 id="案例1：文件中有多少个单词？"><a href="#案例1：文件中有多少个单词？" class="headerlink" title="案例1：文件中有多少个单词？"></a>案例1：文件中有多少个单词？</h1><p>接下来的案例，我们来统计一个文件中有多少个单词，我们用C++实现这样的功能，我们先对案例进行分析，首先，我们要有个文件，如果没有文件我们是不能进行处理的，所以我们在开始要有一个判断，是否有文件传给我们了，然后我们要想一个方法去计算到底有多少个单词，这里我们使用的办法是用有穷状态机去解决，我们一个一个字符的读取，然后判断它在不在一个单词里面，如果是单词里面的字符那么我们就把状态更改为in_word，如果不是单词里的字符那么我们就把状态更改为out_word，这样我们只需要记录有多少次状态转换就可以记录有多少个单词了。下面来看详细代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> out_word 0<span class="comment">//定义在词语外的状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_word 1<span class="comment">//定义在词语内的状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> init out_word        <span class="comment">//定义初始状态</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">bool</span> <span class="title">is_split</span><span class="params">(<span class="type">char</span> *word)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27; &#x27;</span>==*word||<span class="string">&#x27;,&#x27;</span>==*word||<span class="string">&#x27;!&#x27;</span>==*word||<span class="string">&#x27;\n&#x27;</span>==*word)  <span class="comment">//因为我们给的文本很简单只包含这几个分隔符</span></span><br><span class="line">    &#123;    <span class="comment">//所以我们只需要进行这几个判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;           <span class="comment">//如果还有别的分隔符，就要进行更多的判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_words</span><span class="params">(<span class="type">char</span>* file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> word_nums=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> status=init;</span><br><span class="line">    ifstream countedfile;</span><br><span class="line">    countedfile.<span class="built_in">open</span>(file,ios::in);</span><br><span class="line">    <span class="keyword">if</span>(!countedfile.<span class="built_in">is_open</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!countedfile.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> SingleWord;</span><br><span class="line">        countedfile &gt;&gt; noskipws;<span class="comment">//这个的意思是我们文件读取的时候不跳过空格</span></span><br><span class="line">        countedfile &gt;&gt; SingleWord;</span><br><span class="line">        countedfile &gt;&gt; skipws;<span class="comment">//这个的意思就是我们文件读取的时候跳过空格，它就想一个开关，一定要有开有关。</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_split</span>(&amp;SingleWord))<span class="comment">//如果是分隔符，就将状态转换为out_word</span></span><br><span class="line">        &#123;</span><br><span class="line">            status=out_word;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(status==out_word)<span class="comment">//如果不是分隔符且状态还是在out_word，就将状态转换为in_word并记一次状态转换</span></span><br><span class="line">        &#123;</span><br><span class="line">            status=in_word;</span><br><span class="line">            word_nums++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> word_nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>  <span class="comment">//还记得吗？我们之前说argc是命令行传进来的参数总量，而argv就是一条条参数</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果参数总数小于2，我们就退出程序，也就是说算上程序本身（argv[0]），再传输一个文本路径才可以开始计数。</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;word:&quot;</span>&lt;&lt;<span class="built_in">count_words</span>(argv[<span class="number">1</span>])&lt;&lt;endl;<span class="comment">//因为我们只传输了一个参数所以argv[1]就是文件路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了现在我们已经在vscode里面写好了业务逻辑，我们将它保存到我们之前建立的share文件中，之后我们打开xshell。进入share文件。</p><p>接下来我们先编译一下我们写好的cpp文件。编译链接代码的指令是<strong>g++  源文件名  -o  生成的可执行文件名</strong>，也可以使用gcc进行编译但我们编译c++还是建议使用g++。</p><p><img src="1.jpg" alt="编译链接源文件"></p><p>编写一个测试用例。我们可以看到测试用例有15个单词。</p><p><img src="2.jpg" alt="编写测试用例"></p><p>运行编译好的程序。</p><p><img src="3.jpg" alt="运行程序"></p><p>看程序成功的运行了，我们已经迈出了前往星辰大海的第一步。</p><h1 id="案例2：实现一个通讯录"><a href="#案例2：实现一个通讯录" class="headerlink" title="案例2：实现一个通讯录"></a>案例2：实现一个通讯录</h1><p>接下来我们要实现一个通讯录，通讯录包括的功能有：</p><ol><li>添加一个人员</li><li>打印显示所有人员</li><li>删除一个人员</li><li>查找一个人员</li><li>保存文件</li><li>加载文件</li></ol><p>根据需求，我们得到了以下问题：</p><ol><li>人员如何存储 —— 因为不涉及排序问题所以我们这里使用双向链表来存储。</li><li>人员信息——最基本的我们要有姓名和信息</li><li>文件存储——我们以最简单的name=xxx,phone=xxx的格式保存，每一行对应一个人</li></ol><p>这一次我们使用C来完成这些功能，因为C的编译指令和C++些许不同，在着我们可以借机复习一下链表。接下来看详细代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> insert_person(person,address_book)\<span class="comment">//宏定义函数 这里要注意的是如果多行定义一定要在每一行行末加上\作为延续符</span></span></span><br><span class="line"><span class="keyword">do</span>&#123;\</span><br><span class="line">   <span class="keyword">if</span>(address_book-&gt;people==<span class="literal">NULL</span>)\</span><br><span class="line">   &#123;\</span><br><span class="line">      address_book-&gt;people=person;\</span><br><span class="line">      person-&gt;next_people=<span class="literal">NULL</span>;\</span><br><span class="line">      person-&gt;front_people=<span class="literal">NULL</span>;\</span><br><span class="line">   &#125;<span class="keyword">else</span>\</span><br><span class="line">   &#123;\</span><br><span class="line">      person-&gt;next_people=address_book-&gt;people;\</span><br><span class="line">      address_book-&gt;people-&gt;front_people=person;\</span><br><span class="line">      person-&gt;front_people=<span class="literal">NULL</span>;\</span><br><span class="line">      address_book-&gt;people=person;\</span><br><span class="line">   &#125;\</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remove_person(person,address_book)\</span></span><br><span class="line"><span class="meta">do&#123;\</span></span><br><span class="line"><span class="meta">   <span class="keyword">if</span>(person-&gt;front_people!=NULL)person-&gt;front_people-&gt;next_people=person-&gt;next_people;\</span></span><br><span class="line"><span class="meta">   <span class="keyword">if</span>(person-&gt;next_people!=NULL)person-&gt;next_people-&gt;front_people=person-&gt;front_people;\</span></span><br><span class="line"><span class="meta">   <span class="keyword">if</span>(address_book-&gt;people==person)&#123;\</span></span><br><span class="line"><span class="meta">      address_book-&gt;people=person-&gt;next_people;\</span></span><br><span class="line"><span class="meta">      address_book-&gt;people-&gt;front_people=NULL;\</span></span><br><span class="line"><span class="meta">      &#125;\</span></span><br><span class="line"><span class="meta">   person-&gt;front_people=person-&gt;next_people=NULL;\</span></span><br><span class="line"><span class="meta">&#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_name_length 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_phone_length 13 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max_buffer_length 255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mini_token 20</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span>Add=<span class="number">1</span>,Print,Delete,Search,Save,Load&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span>                               //结构体 人</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">person</span>* <span class="title">next_people</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">person</span>* <span class="title">front_people</span>;</span></span><br><span class="line">   <span class="type">char</span> name[MAX_name_length];</span><br><span class="line">   <span class="type">char</span> phonenumber[MAX_phone_length];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_book</span>//结构体 通讯录</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">person</span> *<span class="title">people</span>;</span></span><br><span class="line">   <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//define interface         定义接口层</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_person_into_address_book</span><span class="params">(<span class="keyword">struct</span> address_book *ab,<span class="keyword">struct</span> person *people)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (people==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   insert_person(people,ab);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">remove_person_from_address_book</span><span class="params">(<span class="keyword">struct</span> person *person,<span class="keyword">struct</span> address_book *ab)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (person==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   remove_person(person,ab);</span><br><span class="line">   <span class="built_in">free</span>(person);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//define business          定义业务层</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_person</span><span class="params">(<span class="keyword">struct</span> address_book* ab)</span></span><br><span class="line">&#123; </span><br><span class="line">   <span class="keyword">if</span>(ab==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">person</span>* <span class="title">people</span>=</span>(<span class="keyword">struct</span> person*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> person));</span><br><span class="line">   <span class="keyword">if</span>(people==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;input name:&quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,people-&gt;name);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;input phone number:&quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,people-&gt;phonenumber);</span><br><span class="line">   add_person_into_address_book(ab,people);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete_person</span><span class="params">(<span class="keyword">struct</span> address_book* ab)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> name[MAX_name_length]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">person</span>* <span class="title">item</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;input name:&quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);</span><br><span class="line">   <span class="keyword">for</span> (item = ab-&gt;people; item != <span class="literal">NULL</span>; item=item-&gt;next_people)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(name,item-&gt;name))<span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(item==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   remove_person_from_address_book(item,ab);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">print_address_book</span><span class="params">(<span class="keyword">struct</span> address_book* ab)</span></span><br><span class="line">&#123;  </span><br><span class="line">   <span class="keyword">if</span>(ab==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">person</span>* <span class="title">item</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">for</span> (item = ab-&gt;people; item != <span class="literal">NULL</span>; item=item-&gt;next_people)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;name=%s,phonenumber=%s\n&quot;</span>,item-&gt;name,item-&gt;phonenumber);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">search_person</span><span class="params">(<span class="keyword">struct</span> address_book* ab)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> name[MAX_name_length]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">person</span>* <span class="title">item</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;input name:&quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);</span><br><span class="line">   <span class="keyword">for</span> (item = ab-&gt;people; item != <span class="literal">NULL</span>; item=item-&gt;next_people)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(name,item-&gt;name))</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;name=%s,phonenumber=%s\n&quot;</span>,item-&gt;name,item-&gt;phonenumber);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">parser_token</span><span class="params">(<span class="type">char</span>* buffer,<span class="type">int</span> length,<span class="type">char</span>*name,<span class="type">char</span>*phonenumber)</span>   <span class="comment">//解析我们文件中的数据，将有用的数据截取出来</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(buffer==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,status=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (;buffer[i]!=<span class="string">&#x27;,&#x27;</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(buffer[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         status=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(status==<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         name[j++]=buffer[i];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   status=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (;i &lt; length; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(buffer[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         status=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(status==<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         phonenumber[j++]=buffer[i];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">load_address_book</span><span class="params">(<span class="keyword">struct</span> address_book* ab)</span></span><br><span class="line">&#123;</span><br><span class="line">   FILE* fp=fopen(<span class="string">&quot;save.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="type">int</span> status=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (!feof(fp))           <span class="comment">//feof函数表示是否到达文末，如果到达文末返回1</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">char</span> buffer[Max_buffer_length]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">      fgets(buffer,Max_buffer_length,fp);</span><br><span class="line">      <span class="type">int</span> length=<span class="built_in">strlen</span>(buffer);</span><br><span class="line">      <span class="keyword">if</span>(length&gt;Mini_token)&#123;<span class="comment">//在文末会有标识符，这里的判断是长度必须大于最小的可处理长度解析数据</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">person</span>* <span class="title">people</span>=</span>(<span class="keyword">struct</span> person*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> person));</span><br><span class="line">         parser_token(buffer,length,people-&gt;name,people-&gt;phonenumber);</span><br><span class="line">         add_person_into_address_book(ab,people);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">save_address_book</span><span class="params">(<span class="keyword">struct</span> address_book* ab)</span></span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp=fopen(<span class="string">&quot;save.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">person</span>* <span class="title">item</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">for</span> (item = ab-&gt;people; item != <span class="literal">NULL</span>; item=item-&gt;next_people)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(fp,<span class="string">&quot;name= %s,phonenumber= %s\n&quot;</span>,item-&gt;name,item-&gt;phonenumber);</span><br><span class="line">      fflush(fp);</span><br><span class="line">   &#125;</span><br><span class="line">   fclose(fp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;success, the date in the save.txt\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> choose = <span class="number">0</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">address_book</span> *<span class="title">ab</span>=</span>(<span class="keyword">struct</span> address_book*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> address_book));</span><br><span class="line">   <span class="built_in">memset</span>(ab,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> address_book));</span><br><span class="line">   <span class="keyword">if</span>(ab==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   ab-&gt;people = <span class="literal">NULL</span>;</span><br><span class="line">   ab-&gt;count=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;  </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;1.add a person\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;2.print all of person\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;3.delete a person\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;4.search a person\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;5.save all of person in file\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;6.load all of person from file\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;other input to exit\n&quot;</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;choose);</span><br><span class="line">      <span class="keyword">switch</span>(choose)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">case</span> Add:</span><br><span class="line">            add_person(ab);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> Print:</span><br><span class="line">            print_address_book(ab);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> Delete:</span><br><span class="line">            delete_person(ab);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> Search:</span><br><span class="line">            search_person(ab);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> Save:</span><br><span class="line">            save_address_book(ab);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> Load:</span><br><span class="line">            load_address_book(ab);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">   <span class="built_in">free</span>(ab);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样我们将文件放到share里面，然后打开xshell，进入share文件，输入<strong>gcc -o 可执行文件名 源代码名</strong>，编译并链接。</p><p><img src="5.jpg" alt="编译链接程序"></p><p>编写一个测试用例。最小处理长度就是**name= ,phonenumber= **的长度 。</p><p><img src="6.jpg" alt="编写测试用例"></p><p>运行我们的程序，这里我们只演示从文件中加载出来所有信息，其余可自行测试。</p><p><img src="7.jpg" alt="运行程序"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-中的文件操作&quot;&gt;&lt;a href=&quot;#C-中的文件操作&quot; class=&quot;headerlink&quot; title=&quot;C++中的文件操作&quot;&gt;&lt;/a&gt;C++中的文件操作&lt;/h1&gt;&lt;p&gt;这一篇开始，我们正式的接触Linux下的C/C++开发，我们使用两个案例帮助大家，快速的</summary>
      
    
    
    
    <category term="C/C++" scheme="http://example.com/categories/C-C/"/>
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程快速入门</title>
    <link href="http://example.com/2022/10/28/Shell%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/10/28/Shell%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2022-10-28T05:33:44.000Z</published>
    <updated>2022-11-15T06:24:35.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h1><p>我们使用ls -l(ll指令)指令的时候会发现有一串神秘的字符串，其实它就代表了文件的权限。它的每位都有特殊的含义。</p><p><img src="1.jpg" alt="文件权限"></p><p>我们来看看这9位字符都告诉了我们什么，首先是第0位，它确定了文件的类型，-表示普通文件，i相当于链接，相当于Windows的快捷方式，d是目录，相当于Windows的文件夹，c是字符设备文件，像是鼠标、键盘之类的，b是块设备，比如硬盘。其次1-3位确定所有者拥有该文件的权限，r代表可读，w代表可写，对于目录来讲代表可修改，x表示可执行，对于目录来讲就是可进入。在着4-6位确定所属组拥有该文件的权限。最后7-9确定其他用户拥有该文件的权限。在日期前面还有一些数字，这些数字代表文件大小，至于所有者前面的数字代表硬链接数目，一个文件至少一个，一个文件夹至少两个。在Linux中r可以用4代替，w可以用2代替，x可以用1代替，所以全部的权限可以用7代替。</p><h1 id="修改权限chmod指令"><a href="#修改权限chmod指令" class="headerlink" title="修改权限chmod指令"></a>修改权限chmod指令</h1><p>基本语法：</p><p>chmod u=rwx,g=rx,o=x 文件/目录名</p><p>chmod o+w 文件/目录名</p><p>chmod a-x 文件/目录名</p><p>其中u代表所有者，g代表所在组，o代表其他组，a代表所有，也就是u，g，o的总和。我们可以使用+，-，=变更权限。</p><p><img src="2.jpg" alt="chmod指令使用+，-，="></p><p>也可以用数字变更权限</p><p><img src="3.jpg" alt="chmod指令使用数字"></p><h1 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h1><p>当我们将来走上工作，学会怎么写一个shell脚本是必不可少的，比如我们在进行服务器维护的时候，可能就会需要编写一个脚本来定时备份数据库等等。</p><h1 id="shell是什么"><a href="#shell是什么" class="headerlink" title="shell是什么"></a>shell是什么</h1><p>知道shell可以做什么了，可是什么是shell呢？shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以通过shell来启动、挂起、停止甚至是编写一些程序。当然Linux不止一个shell，我们常用的是bash。</p><p><img src="1.jpg" alt="shell"></p><h1 id="shell脚本的执行方式"><a href="#shell脚本的执行方式" class="headerlink" title="shell脚本的执行方式"></a>shell脚本的执行方式</h1><p>学习shell和我们学习其他语言是一样的我们先来看一下格式的要求，首先脚本要以 <strong>#!/bin/bash</strong> 开头，其次脚本要有可执行的权限。脚本常用的执行方式有两种，一是要先赋予我们写好的脚本文件x权限，然后输入脚本的绝对路径或相对路径执行，二是使用 <strong>sh 脚本</strong>这个指令来执行。</p><p><img src="2.jpg" alt="执行一个向屏幕输出hello world的程序"></p><h1 id="shell的变量"><a href="#shell的变量" class="headerlink" title="shell的变量"></a>shell的变量</h1><p>之前我们在汇编的学习中提到了，一个有用的程序，多半会存在变量，shell编程也是如此。Linux shell中的变量分为，系统变量和用户自定义变量，系统变量包括$HOME、$PWD、$SHELL、$USER等等，我们可以用<strong>set</strong>指令显示所有变量。</p><p>用户自定义变量的基本语法是：<strong>变量名=值</strong>，注意在Linux中指令对空格的检测很严格，所以一定要仔细看接下来的指令中是否含有空格，这点很重要！当我们需要删除一个变量的时候我们可以使用指令<strong>unset 变量名</strong>来进行销毁，我们还可以声明一个静态变量使用指令<strong>readonly变量</strong>，静态变量不可以被unset销毁掉。当我们输出一个变量的时候我们可以使用指令<strong>echo $A</strong>，注意$符号，当我们定义变量的时候不需要$但输出的时候需要（tips：#表示注释，多行注释为:&lt;&lt;!……!）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">定义一个变量A</span></span><br><span class="line">A=100</span><br><span class="line">:&lt;&lt;!</span><br><span class="line">输出变量需要$</span><br><span class="line">echo指令可以使用“”也可以省略</span><br><span class="line">!</span><br><span class="line">echo A=$A</span><br><span class="line">echo &quot;A=$A&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">撤销变量A</span></span><br><span class="line">unset A</span><br><span class="line">echo A=$A</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">声明静态变量B=2，不能被<span class="built_in">unset</span></span></span><br><span class="line">readonly B=2</span><br><span class="line">echo B=$B</span><br><span class="line">exit 0                                                                    </span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="3.jpg" alt="shell中的变量"></p><p>在高级语言中，变量的定义是有规则的，在shell编程中也不例外，shell编程中，变量的名称可以由字母、数字和下划线组成，但不能以数字开头，变量定义时等号两边不能有空格，变量名称一般习惯为大写。</p><p>当我们希望将一个指令的返回值赋给一个变量，那我们需要使用反引号`（~键）或$()将指令包起来，否则shell认为是将指令本身赋给变量。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">A=date</span><br><span class="line">B=`date`</span><br><span class="line">C=$(date)</span><br><span class="line">echo $A</span><br><span class="line">echo $B</span><br><span class="line">echo $C</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="4.jpg" alt="将指令返回值赋给变量"></p><h1 id="shell字符串"><a href="#shell字符串" class="headerlink" title="shell字符串"></a>shell字符串</h1><p>字符串是 shell 编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号。</p><p>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。而双引号里可以出现变量，而且双引号里面可以含有转义字符。接下来是几个常用的字符串操作：</p><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">your_name=&quot;liuzheng&quot;</span><br><span class="line"># 使用双引号拼接</span><br><span class="line">greeting=&quot;hello, &quot;$your_name&quot; !&quot;</span><br><span class="line">greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;</span><br><span class="line">echo $greeting $greeting_1</span><br><span class="line"># 使用单引号拼接</span><br><span class="line">greeting_2=&#x27;hello, &#x27;$your_name&#x27; !&#x27;</span><br><span class="line">greeting_3=&#x27;hello, $&#123;your_name&#125; !&#x27;</span><br><span class="line">echo $greeting_2 $greeting_3</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="22.jpg" alt="字符串拼接"></p><h2 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">your_name=&quot;liuzheng&quot;</span><br><span class="line">echo $&#123;#your_name&#125;</span><br></pre></td></tr></table></figure><p><img src="23.jpg" alt="字符串拼接"></p><h2 id="提取字符串"><a href="#提取字符串" class="headerlink" title="提取字符串"></a>提取字符串</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">your_name=&quot;liuzheng&quot;</span><br><span class="line">echo $&#123;your_name:0:3&#125;</span><br></pre></td></tr></table></figure><p><img src="25.jpg" alt="提取字符串"></p><p>:0:3的意思是从第0位开始截取3个长度的字符。</p><h2 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">your_name=&quot;liuzheng&quot;</span><br><span class="line">echo $&#123;#your_name&#125;</span><br></pre></td></tr></table></figure><p><img src="24.jpg" alt="查找子字符串"></p><h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><p>基本语法：export 变量名=变量值，用来将shell变量输出为环境变量（可以理解为全局变量，需要在/etc/profile中定义）</p><p>source 配置文件，用来让修改后的配置信息立即生效</p><p>echo $变量名，用来查询环境变量的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">vim /etc/profile最下面,如果出现swap交换文件输入e即可</span></span><br><span class="line">export myname=liuzheng</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令行中</span></span><br><span class="line">source /etc/profile</span><br><span class="line">echo $myname</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="5.jpg" alt="设置环境变量"></p><h1 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h1><p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量比如./myshell.sh 100 200，这就是一个执行shell的命令行，可以在myshell中获取到参数信息。</p><p>基本语法：</p><p>$n，n为数字，0代表命令本身，1-9代表第一个到第九个参数，十以上的参数需要用大括号包含如：${10}。</p><p>$*，这个变量表示命令行中所有的参数，它把所有参数看成一个整体。</p><p>$@，这个变量也代表命令行中所有参数，不过它把每个参数区分对待。</p><p>$#，这个变量表示命令行中所有参数个数，类似高级语言中main函数的变量argc。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo 0=$0</span><br><span class="line">echo 1=$1</span><br><span class="line">echo 2=$2</span><br><span class="line">echo 所有参数=$*</span><br><span class="line">echo $@</span><br><span class="line">echo 参数个数$#</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="6.jpg" alt="位置参数变量"></p><h1 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h1><p>预定义变量是shell设计者已经实现定义好的变量，可以直接在shell脚本中使用，常用的有三个：</p><ol><li>$$，代表当前进程的进程号PID</li><li>$!，代表后天运行的最后一个进程的进程号PID</li><li>$?，代表最后一次执行的命令的返回状态，如果上一个命令正确执行那么返回的值为0，如果这个值非0着表示上一个命令执行不正确，至于错误后返回的到底是多少，由命令自己决定。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo 当前进程号为$$</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当我们需要在后台执行一个脚本的时候只需要在执行的指令后面加一个&amp;即可</span></span><br><span class="line">sh /home/liuzheng/shell/hello.sh &amp;</span><br><span class="line">echo 后台运行的最后一个进程号为$!</span><br><span class="line">echo 最后一个命令是否成功执行$?</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="7.jpg" alt="预定义变量"></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>我们在学习C语言的时候，肯定做过加法减法的程序，当然这也是计算机最基本的操作了，现在我们在shell中看看如何进行运算。</p><p>基本语法：</p><ol><li>$((运算式))或$[运算式]或者expr m +(-) n(注意格式)</li><li>注意运算符间要有空格</li><li>注意expr中乘法的写法为\*做转义操作</li><li>在使用expr进行运算时，如果要将计算结果赋值给一个变量，需要将运算式用反引号``括起来</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo $[100+200]</span><br><span class="line">A=`expr 100 \* 2`</span><br><span class="line">echo $A</span><br><span class="line">echo $(((2*4)+3))</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="8.jpg" alt="运算符"></p><p>我们也可以通过之前学习的位置参数变量来优化脚本！</p><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>我们在编写一个程序的时候，会对一些事情进行判断，如果满足了某一条件，我们就进行一系列操作，反之我们有别的应对，这个时候就要知道流程控制语句。</p><h2 id="if语句和if……else语句"><a href="#if语句和if……else语句" class="headerlink" title="if语句和if……else语句"></a>if语句和if……else语句</h2><p>基本语法：if [ condition ]then …… fi，如果非空返回true。（注意格式，condition前后都有空格，if和中括号之间也有空格）</p><p>if [ condition ]then…… else…… fi，如果非空返回true。</p><p>我们在shell编程中常用的判断条件有四类：</p><p>1.字符串比较</p><ul><li>=</li></ul><p>2.两个整数比较</p><ul><li>-lt 小于</li><li>-le 小于等于</li><li>-eq 等于</li><li>-gt 大于</li><li>-ge 大于等于</li><li>-ne 不等于</li></ul><p>3.按照文件权限进行判断</p><ul><li>-r 有读的权限</li><li>-w 有写的权限</li><li>-x 有执行的权限</li></ul><p>4.按照文件类型进行判断</p><ul><li>-f 文件存在且是一个常规的文件</li><li>-e 文件存在</li><li>-d 文件存在且是一个目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">if [ &quot;ok&quot;=&quot;ok&quot; ]</span><br><span class="line">then</span><br><span class="line">        echo isequal</span><br><span class="line">fi</span><br><span class="line">if [ 21 -ge 22 ]</span><br><span class="line">then</span><br><span class="line">        echo yes</span><br><span class="line">fi</span><br><span class="line">echo exist?</span><br><span class="line">if [ -f /home/liuzheng/shell/hello.sh ]</span><br><span class="line">then</span><br><span class="line">        echo yes</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="9.jpg" alt="if语句"></p><h2 id="if-elif语句"><a href="#if-elif语句" class="headerlink" title="if elif语句"></a>if elif语句</h2><p>我们已经学会了如何使用if，但有的时候判断会进行很多次，这个时候就要用到了else if，所以我们来看一下shell编程中else if是什么样子的。</p><p>基本语法（注意格式）：</p><p>if [ condition ]then …… fi 或者 if [ condition ]then …… elif  [ condition ] then …… fi</p><p>注意[ condition ]，中括号和condition之间，if和中括号之间，elif和中括号之间必须有空格！！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">if [ $1 -ge 60 ]</span><br><span class="line">then</span><br><span class="line">        echo 及格</span><br><span class="line">elif [ $1 -lt 60 ]</span><br><span class="line">then</span><br><span class="line">        echo 不及格</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="10.jpg" alt="if elif语句"></p><h2 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h2><p>基本语法：</p><p>case $变量名 in 值1 )程序1;; 值2)程序2;; 值3)程序3;;…… * )如果变量的值都不是以上的值，执行本程序;; esac</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">case $1 in</span><br><span class="line">1 )echo monday;;</span><br><span class="line">2 )echo tuesday;;</span><br><span class="line">3 )echo wednesday;;</span><br><span class="line">4 )echo thursday;;</span><br><span class="line">5 )echo friday;;</span><br><span class="line">6 )echo saturday;;</span><br><span class="line">7 )echo sunday;;</span><br><span class="line">* )echo good day!;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="11.jpg" alt="case语句"></p><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>现在我们需要像屏幕上输出1行hello world，你会选择使用echo hello world完成，如果我们需要输出10条，你可能会使用yy，p来完成，可是如果我们需要输出100条甚至更多呢？这个时候就要使用循环。</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>基本语法：</p><p>for 变量 in 值1 值2 值3 … do …… done，这里的值1，值2，值3代表一个集合 ，我们可以用省略号代表一个集合，比如1到100就是{1…100}</p><p>for (( 初始值;循环控制条件;变量变化 ))do……done</p><p>我们这里顺便使用for循环来看一下$*和$@的区别。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo *:</span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">        echo num is $i</span><br><span class="line">done</span><br><span class="line">echo =================</span><br><span class="line">echo @:</span><br><span class="line">for j in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">        echo num is $j</span><br><span class="line">done</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：<img src="12.jpg" alt="for循环1"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">A=0</span><br><span class="line">for (( i=1; i&lt;=100; i++ ))</span><br><span class="line">do</span><br><span class="line">        A=$[$A+$i]</span><br><span class="line">done</span><br><span class="line">echo $A</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：<img src="13.jpg" alt="for循环2"></p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>基本语法：</p><p>while [ 条件判断式 ]do……done，注意while和[之间的空格，条件判断式前后的空格。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">i=0</span><br><span class="line">sum=0</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">        sum=$[$sum+$i]</span><br><span class="line">        i=$[$i+1]</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：<img src="14.jpg" alt="while循环"></p><h1 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h1><p>基本语法：read (选项) (参数) 变量，用来读取键盘输入</p><p>选项：-p：指定读取值时的提示符</p><p>-t：指定读取值时等待的时间(秒)，如果没有在指定的时间输入，就不在等待了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">read -p &quot;请输入数字1&quot; num1</span><br><span class="line">echo &quot;数字1为&quot;$num1</span><br><span class="line">read -t 10 -p &quot;请在10s内输入数字2&quot; num2</span><br><span class="line">echo &quot;数字2为&quot;$num2</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：<img src="15.jpg" alt="read读取控制台输入"></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>shell编程和其它的编程语言一样有函数的存在，函数可以被分为系统函数和自定义函数，接下来我们就来了解一下。</p><h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><p>1.基本语法：basename [pathname] [suffix]</p><p>basename [string] [suffix]</p><p>basename指令会删掉所有的前缀包括最后的一个/字符，然后将字符串显示出来。</p><p>选项：suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。</p><p>结果：<img src="C:/Users/29421/Desktop/blog/16.jpg" alt="basename指令"></p><p>2.基本语法：dirname 文件绝对路径</p><p>dirname指令从给定的包含绝对路径的文件名中去除文件名，然后返回剩下来的路径。</p><p>结果：<img src="C:/Users/29421/Desktop/blog/17.jpg" alt="dirname指令"></p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function funname()</span><br><span class="line">&#123;</span><br><span class="line">Action;</span><br><span class="line">[return int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要调用我们的自定义函数的时候，只需要写函数名即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">function getsum()</span><br><span class="line">&#123;</span><br><span class="line">        sum=$[$n1+$n2]</span><br><span class="line">        echo &quot;和为&quot;$sum</span><br><span class="line">&#125;</span><br><span class="line">read -p &quot;输入数字1：&quot; n1</span><br><span class="line">read -p &quot;输入数字2：&quot; n2</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>结果：<img src="18.jpg" alt="自定义函数"></p><h1 id="案例：who-is-up-sh"><a href="#案例：who-is-up-sh" class="headerlink" title="案例：who_is_up.sh"></a>案例：who_is_up.sh</h1><p>接下来我们一个案例体验一下shell编程带来的便利。</p><p>我们之前使用过ping指令，ping指令会通过发送数据包的形式判断目的主机是否宕机。接下来我们就用这个来看看都有谁在工作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for i in &#123;1..254&#125;</span><br><span class="line">do</span><br><span class="line">        ping -c 2 -i 0.5 192.168.202.$i &amp;&gt; /dev/null</span><br><span class="line">        if [ $? -eq 0 ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;192.168.202.$i is up&quot;</span><br><span class="line">        else</span><br><span class="line">                echo &quot;192.169.202.$i is down&quot;</span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>结果：<img src="25.jpg" alt="who_is_up.sh"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;权限的基本介绍&quot;&gt;&lt;a href=&quot;#权限的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;权限的基本介绍&quot;&gt;&lt;/a&gt;权限的基本介绍&lt;/h1&gt;&lt;p&gt;我们使用ls -l(ll指令)指令的时候会发现有一串神秘的字符串，其实它就代表了文件的权限。它的每位</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    <category term="Shell" scheme="http://example.com/categories/Shell/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Shell" scheme="http://example.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux中基本的指令</title>
    <link href="http://example.com/2022/10/28/Linux%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8C%87%E4%BB%A4/"/>
    <id>http://example.com/2022/10/28/Linux%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8C%87%E4%BB%A4/</id>
    <published>2022-10-28T05:10:56.000Z</published>
    <updated>2022-11-15T06:23:58.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h1><p>Linux讲究的是一切皆文件，在Windows下是文件的东西，在Linux中也是，在Windows下不是文件的东西，比如套接字，进程，甚至是硬件设备，在Linux下还是文件，你可以通过访问文件的方式来获取它们的信息，所以说要记住Linux下一切皆文件。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p><img src="0.jpg" alt="Linux目录结构"></p><p>Linux目录结构十分重要，要熟练的掌握。接下来我们来看一看这些目录都是用来做什么的：</p><ol><li>/bin：bin是Binaries(二进制文件)的缩写，这个目录存放着最经常用的命令。</li><li>/sbin：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</li><li>/home：存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名。</li><li>/root：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li>/lib：系统开机所需要最基本的动态连接共享库，就类似于Windows下的DLL文件。几乎所有的应用程序都需要用到这些共享库</li><li>/lost+found：这个目录是一个被隐藏的目录，一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li>/etc：所有的系统管理所需要的配置文件和子目录。</li><li>/usr：这是一个非常重要的目录，用户很多的应用程序和文件都放在这个目录下，类似Windows的program files目录。</li><li>/boot：存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li>/proc：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。不要动它，可能导致系统崩溃。</li><li>/srv：service缩写，该目录存放一些服务启动后需要提取的数据。不要动它，可能导致系统崩溃。</li><li>/sys：这是Linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。不要动它，可能导致系统崩溃。</li><li>/tmp：用来存放一些临时文件。</li><li>/dev：类似Windows的设备管理器，把所有的硬件用文件的形式存储。</li><li>/media：Linux系统会自动识别一些设备，例如光驱，U盘等等，当识别后，Linux会把识别的设备挂载到这个目录下。</li><li>/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt上，然后进入该目录就可以查看里面的内容了。</li><li>/opt：这是主机额外安装软件用到的目录，默认为空。</li><li>/user/local：这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码方式安装的程序。</li><li>/var：这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。</li><li>/selinux：SELinux是一种安全子系统，它能控制程序只访问特定文件，有三种工作模式，可自行设定。</li></ol><h1 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h1><p>想必你也感觉到了，我们到现在为止虽然好像没做什么，但大多数都用到了各种指令，没错linux下我们需要熟练的使用这些指令，这样才方便我们的工作，所以接下来我们要开始接触各种指令，但在此之前我们先了解一个重要的指令，帮助指令。</p><p>第一个帮助指令是man [命令或配置文件]，比如man ls，我们可以通过这条指令知道ls命令是做什么的，以及它有没有其他的扩展选项，例如ls -a可以显示所有文件包括以“.”开头的隐藏文件。如果帮助信息很多没有显示完，可以使用space(空格键)翻页。（Tips：ls指令的选项可以叠加使用比如ls -la，单列显示所有文件，la选项不区分先后关系，也可以为al。）</p><p><img src="1.jpg" alt="man ls"></p><p>第二个帮助指令时help 命令，它可以获得shell内置命令的帮助信息。比如help cd。</p><p><img src="2.jpg" alt="help cd"></p><h1 id="文件目录指令"><a href="#文件目录指令" class="headerlink" title="文件目录指令"></a>文件目录指令</h1><p>Linux下一切皆文件，所以我们要想成为高手，就要知道怎么操作文件，所以我们接下来了解一下文件目录指令。</p><h2 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a>pwd指令</h2><p>基本语法：pwd，用来显示当前工作目录的绝对路径。</p><p><img src="3.jpg" alt="pwd指令"></p><h2 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h2><p>基本语法：ls [选项] [目录或是文件]，用来显示当前目录文件。</p><p>常用选项：-a，显示当前目录所有文件和目录，包括隐藏的。-l，以列表的方式显示信息，信息会展示的更为全面。</p><p><img src="4.jpg" alt="ls指令"></p><h2 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h2><p>基本语法：cd [参数]，用来切换到指定目录</p><p>cd~或cd，回到自己的家目录 cd..回到当前目录的上一级目录</p><p><img src="5.jpg" alt="cd指令"></p><h2 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a>mkdir指令</h2><p>基本语法：mkdir [选项] 要创建的目录，用来创建目录</p><p>常用选项：-p，创建多级目录</p><p><img src="6.jpg" alt="mkdir指令"></p><h2 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a>rmdir指令</h2><p>基本语法：rmdir（或rm） [选项] 要删除的空目录，用来删除目录</p><p>注意，因为rmdir删除的是空目录，如果目录下有内容是无法删除的，这个时候要使用rm -rf删除。</p><p><img src="7.jpg" alt="rmdir指令和rm -rf"></p><h2 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h2><p>基本语法：touch 文件名称，用来创建空文件</p><p><img src="8.jpg" alt="touch指令"></p><h2 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a>cp指令</h2><p>基本语法：cp [选项] 文件夹(或文件) 目的地址，用来拷贝文件到指定目录</p><p>常用选项：-r 递归复制整个文件夹</p><p><img src="9.jpg" alt="cp指令"></p><p>当我们重复的将一个文件(文件夹)复制到同一个目录时，就会发生覆盖，这个时候我们需要输入y才可以覆盖文件。当然我们也可以使用\cp [选项] 文件夹(或文件) 目的地址，强制覆盖。</p><p><img src="10.jpg" alt="cp指令覆盖问题"></p><h2 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h2><p>基本语法：rm [选项] 要删除的文件或目录，用来移除文件或目录</p><p>常用选项：-r：递归删除整个文件夹。-f：强制删除不提示</p><p><img src="11.jpg" alt="rm指令"></p><h2 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h2><p>基本语法：</p><p>mv oldfilename newfilename，用来重命名</p><p>mv 文件(文件夹)路径 目的路径，用来移动文件</p><p><img src="12.jpg" alt="mv指令"></p><p>我们也可以在移动文件的同时修改文件名称。</p><h2 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h2><p>基本语法：cat [选项] 要查看的文件，用来查看文件内容</p><p>常用选项：-n：显示行号</p><p><img src="13.jpg" alt="cat指令"></p><p>当然文件往往都有很多行所以为了方便浏览，我们可以加上管道指令|more，例如 cat -n pig.txt |more。</p><h2 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h2><p>基本语法：more 要查看的文件</p><p>more指令是一个基于vi编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干个快捷键。如下图：</p><p><img src="14.jpg" alt="more指令快捷键"></p><h2 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h2><p>基本语法：less 要查看的文件</p><p>less指令用分屏来查看文件内容，它和more类似，当比more更为强大，less对显示大型文件具有较高的效率。</p><p>less相较于more而言，还可以使用/ 关键词来进行搜索，输入n向前查找下一个匹配的文本，输入N向后查找前一个匹配的文本。</p><h2 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a>echo指令</h2><p>基本语法：echo [选项] [输出内容]，用来输出内容到控制台</p><p><img src="15.jpg" alt="echo指令"></p><h2 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h2><p>基本语法：</p><p>head 文件，用来显示文件开头部分，默认为头10行</p><p>head -n 5 文件，用来查看文件头5行内容，5是变数 </p><p><img src="16.jpg" alt="head指令"></p><h2 id="gt-指令和-gt-gt-指令"><a href="#gt-指令和-gt-gt-指令" class="headerlink" title="&gt;指令和&gt;&gt;指令"></a>&gt;指令和&gt;&gt;指令</h2><p>基本语法：</p><p>ls -l&gt;文件，列表的内容写入文件中(覆盖写)</p><p>ls -al&gt;&gt;文件，列表的内容追加到文件的末尾</p><p>cat 文件1&gt;文件2，将文件1的内容覆盖到文件2</p><p>echo “内容”&gt;&gt;文件，将内容写入文件</p><h2 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h2><p>基本语法：</p><p>tail 文件，查看文件尾内容，默认为10行</p><p>tail -n 5 文件，查看文件尾5行内容，5是变数</p><p>tail -f 文件，实时追踪该文档的所有更新，指令执行后监控文件，有新内容写入后立马显示。</p><p><img src="17.jpg" alt="tail指令"></p><h2 id="ln指令"><a href="#ln指令" class="headerlink" title="ln指令"></a>ln指令</h2><p>基本语法：ln -s [原文件或目录] [软链接名]，用来给文件创建一个软链接</p><p>软链接就类似于Windows下的快捷方式，我们为一个文件或目录创造一个软链接，当我们访问这个软链接时就相当于访问原文件或目录。</p><p><img src="18.jpg" alt="ln指令"></p><p>我们可以看到虽然我们通过软链接进入了原文件中，但路径还是软链接的路径，这点要注意。如果我们不想要这个软链接了，我们可以使用rm删除它。</p><h2 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a>history指令</h2><p>基本语法：history，用来查看已经执行过的历史指令。</p><p>你也可以在history后加上一个数字，显示你想显示的后几条指令，比如history 10会显示后十条指令。输入！标号，就可以标号对应指令。</p><p><img src="19.jpg" alt="history指令"></p><h1 id="时间日期指令"><a href="#时间日期指令" class="headerlink" title="时间日期指令"></a>时间日期指令</h1><p>Linux中还有其他功能的指令，比如时间日期指令</p><h2 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a>date指令</h2><p>基本语法：</p><p>date，显示当前时间</p><p>date “+%Y”，显示当前年份</p><p>date “+%m”，显示当前月份</p><p>date “+%d”，显示当前是哪一天</p><p>date “+%Y-%m-%d %H:%M:%S”，显示年月日时分秒</p><p>注意，这里指令的大小写是规定好的，一定要按照上述大小写输入。</p><p><img src="20.jpg" alt="date指令"></p><h2 id="date-s指令"><a href="#date-s指令" class="headerlink" title="date -s指令"></a>date -s指令</h2><p>基本语法：date -s 时间(字符串)</p><p>我们可以使用这个指令修改当前系统的时间。</p><h2 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h2><p>基本语法：cal [选项]</p><p>选项：-m：显示星期一作为一周的第一天，-y：显示当前年份的日历。</p><p><img src="21.jpg" alt="cal指令"></p><p>还可以使用cal+年份，显示指定年份的日历。</p><h1 id="查找指令"><a href="#查找指令" class="headerlink" title="查找指令"></a>查找指令</h1><p>我们在使用Linux的过程中，使用查找指令可以大大的方便我们的工作。</p><h2 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h2><p>基本语法：find [搜索范围] [选项]，用来从指定目录下递归地遍历其各个子目录，将满足条件的显示在终端。</p><p>选项：-name&lt;查询方式&gt;，按照指定的用户名查找模式查找文件。-user&lt;用户名&gt;，查找属于指定用户名所有文件。-size&lt;文件大小&gt;，按照指定的文件大小查找文件。</p><p><img src="22.jpg" alt="find指令"></p><h2 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h2><p>基本语法：locate 搜索文件，同样是用来查找文件的，但是locate指令可以快速定位文件路径。</p><p>注意，由于locate指令基于数据库进行查询，所以第一次运行前，要使用updatedb指令创造locate数据库。</p><p><img src="23.jpg" alt="locate指令"></p><h2 id="grep指令和管道符号"><a href="#grep指令和管道符号" class="headerlink" title="grep指令和管道符号|"></a>grep指令和管道符号|</h2><p>基本语法：grep [选项] 查找内容 源文件，用于过滤查找。管道符“|”表示将前一个命令的处理结果输出传递给后面的命令处理。两者多联合使用。</p><p>选项：-n：显示匹配行及行号。-i忽略字母大小写。</p><p><img src="24.jpg" alt="grep指令和|"></p><h2 id="which指令"><a href="#which指令" class="headerlink" title="which指令"></a>which指令</h2><p>基本语法：which 可执行文件名称，用来查看可执行文件的位置</p><p><img src="25.jpg" alt="which指令"></p><h1 id="压缩和解压指令"><a href="#压缩和解压指令" class="headerlink" title="压缩和解压指令"></a>压缩和解压指令</h1><p>我们在处理文件的时候也少不了压缩和解压的过程，Linux为我们提供了这样的指令。</p><h2 id="gzip-gunzip指令"><a href="#gzip-gunzip指令" class="headerlink" title="gzip/gunzip指令"></a>gzip/gunzip指令</h2><p>基本语法：</p><p>gzip 文件，用来压缩文件，只能将文件压缩为.gz格式</p><p>gunzip 文件，用来解压缩文件</p><p><img src="26.jpg" alt="gzip/gunzip指令"></p><h2 id="zip-unzip指令"><a href="#zip-unzip指令" class="headerlink" title="zip/unzip指令"></a>zip/unzip指令</h2><p>基本语法：</p><p>zip [选项] xxx.zip，用来压缩文件和目录</p><p>unzip [选项] xxx.zip，用于解压缩文件</p><p>zip常用选项：-r：递归压缩，即压缩目录</p><p>unzip常用选项：-d&lt;目录&gt;：指定压缩后文件的存放位置</p><p><img src="27.jpg" alt="zip/unzip指令"></p><h2 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h2><p>基本语法：tar [选项] xxx.tar.gz 打包内容，用来打包目录</p><p>选项：-c：产生.tar打包文件。-v：显示详细信息。-f：指定压缩后的文件名。-z：打包同时压缩。-x：解包.tar文件。</p><p><img src="28.jpg" alt="tar指令"></p><h1 id="vi和vim"><a href="#vi和vim" class="headerlink" title="vi和vim"></a>vi和vim</h1><p>我们知道Linux一切皆文件，文件大多数都应该是可以更改的，所以Linux系统内置了vi文本编辑器，vim也是一个文本编辑器，不过vim具有程序编辑的能力，可以看做是Vi的增强版本，可以主动以字体颜色辨别语法的正确性，方便程序设计。代码补完，编译以及错误跳转等功能丰富。</p><h2 id="vi和vim常用的三种模式"><a href="#vi和vim常用的三种模式" class="headerlink" title="vi和vim常用的三种模式"></a>vi和vim常用的三种模式</h2><p>vi和vim有三种常用模式分别是正常模式、插入模式、命令行模式。</p><p>首先是正常模式，以vim打开一个档案就直接进入了一般模式了。在这个模式中可以使用上下左右移动光标，删除字符，复制粘贴等操作处理文件数据。</p><p>之后是插入模式，按下i，I，o，O，A，R，r都可以进入插入模式，但一般习惯按i，按esc可以退出插入模式，回到正常模式。</p><p>最后是命令行模式，在正常模式下，当我们输入“：”就可以切换为命令模式，在这个模式中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等动作。</p><p><img src="29.jpg" alt="三种模式及切换方法"></p><h2 id="vi和vim快捷键"><a href="#vi和vim快捷键" class="headerlink" title="vi和vim快捷键"></a>vi和vim快捷键</h2><p>首先是基本的复制与粘贴操作，我们在正常模式下敲击yy就可以拷贝当前行，之后按p就可以粘贴当前行了，如果需要多行复制可以敲击数字加yy比如敲击5yy就可以复制当前行向下5行。有复制粘贴就会有删除，还是在正常模式下按dd就可以删除当前行，同样也可以进行多行删除操作。同样我们还有撤销操作，在正常模式下按u即可撤销。</p><p>我们还可以查找一个文本文件中的某个单词，我们在<strong>命令行模式</strong>下只需要使用“/关键字”，回车即可查找，输入n就是查找下一个。我们还可以使用<strong>“set nu”</strong>和<strong>“set nonu”</strong>显示和隐藏行号。我们也可以快速的转到最首行快捷键是gg，快速转到最末行<strong>G（shift+g）</strong>当然这个操作要在<strong>正常模式</strong>下进行。还有一个操作就是快速的转到某一行，比如我想转到20行只需要在正常模式下敲击<strong>2+0+shift+g</strong>即可，不过要注意的是<strong>20不要用键盘的小键盘输入</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一切皆文件&quot;&gt;&lt;a href=&quot;#一切皆文件&quot; class=&quot;headerlink&quot; title=&quot;一切皆文件&quot;&gt;&lt;/a&gt;一切皆文件&lt;/h1&gt;&lt;p&gt;Linux讲究的是一切皆文件，在Windows下是文件的东西，在Linux中也是，在Windows下不是文件的东西，</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的C/C++开发配置</title>
    <link href="http://example.com/2022/10/27/Linux%E4%B8%8B%E7%9A%84C++%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/10/27/Linux%E4%B8%8B%E7%9A%84C++%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/</id>
    <published>2022-10-27T09:22:34.000Z</published>
    <updated>2022-11-15T06:30:07.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从今天开始，我们开始学习如何在Linux下进行高性能的服务器开发，学习之前我们掌握基本的C/C++语法，配置好相关的环境，如果你觉得这些东西配置起来太过麻烦，没关系，博主会从头开始一步一步的配置，所以不必担心，旅途马上开始。</p><h1 id="安装Linux系统"><a href="#安装Linux系统" class="headerlink" title="安装Linux系统"></a>安装Linux系统</h1><p>首先我们进行最为基本的一步，在Windows系统下安装Linux系统，</p><p>首先我们要安装一个<a href="https://download3.vmware.com/software/WKST-1624-WIN/VMware-workstation-full-16.2.4-20089737.exe">VMware</a>，这里附上安装密匙：ZF3R0-FHED2-M80TY-8QYGC-NPKYF。我们来看具体操作：</p><p>1.取出VMware，安装在我们的电脑上，如果你直接安装成功可以去看第二步了，如果你没安装成功，可能是需要开启CPU虚拟化，开启虚拟化首先要根据你的电脑型号上网查找按哪个键进入BIOS，然后重启电脑，在重启的过程中狂按那个键，待进入BIOS界面后进入BIOS后，找到Configuration，选择Intel Virtual Technology（或AMD Virtual Technology）按回车，将光标移至Enabled，然后再回车，最后按F10保存并退出。</p><p>2.安装好VMware后，激活，我们要将光盘映像文件下载下来，这里我们使用的是<a href="https://pan.baidu.com/s/1Zydae3mG45C9hZkT7_H_gw?pwd=1ij0">Ubuntu</a>。</p><p>3.打开VMware，点击创建新的虚拟机，依次执行下列操作，选中典型、下一步、选中稍后安装操作系统、下一步、选中Linux、在版本的下拉菜单中选择Ubuntu、下一步、为你的Linux系统取一个心仪的名字、选择放在一个喜欢的位置、下一步、指定内存大小为30G、下一步。</p><p>4.点击关闭、完成，右键新建好的虚拟机，点击设置，点击CD/DVD，选择使用ISO映像文件，选中下载好的Ubuntu映像文件，点击确定。</p><p><img src="1.jpg" alt="装载Ubuntu映像"></p><p>5.开启创建好的虚拟机，选择语言推荐选择英文，选中安装Ubuntu，回车。</p><p><img src="2.jpg" alt="选择语言"></p><p>6.接下来的选择只要选择默认的即可。</p><p>7.之后会提示我们设置hostname，用户名，密码，我们只需要输入相应的即可。输入完成后会提示是否加密home文件我们选择no。</p><p>8.之后会询问我们的时区，我们选择yes，然后提示我们分区我们选择默认选项，然后在partition disks页面选择yes。</p><p><img src="3.jpg" alt="分区选择"></p><p>9.之后会提示我们配置http，这里我们直接跳过。</p><p>10.经过一段漫长的安装过程之后，我们选择不自动更新，然后我们安装我们需要的软件。一个是SSH，一个是Samba。</p><p><img src="4.jpg" alt="需要的软件"></p><p>11.最后会提示我们安装grub boot，我们选yes。</p><h1 id="安装Xshell"><a href="#安装Xshell" class="headerlink" title="安装Xshell"></a>安装Xshell</h1><p>在公司里，linux服务器是开发小组共享的，正式上线的项目是运行在公网之上的，因此程序员需要远程登录到linux进行项目管理或开发，所以我们要知道如何远程登录linux。当然我们远程登录也需要工具，Xshell6<a href="https://www.xshell.com/zh/free-for-home-school/">戳我下载</a></p><p>安装好后，我们开始使用Xshell，首先我们如果想远程登录linux，就要先知道linux的IP地址，我们可以在linux中断中输入ifconfig来查看IP地址。</p><p><img src="5.jpg" alt="查看IP地址"></p><p>之后我们打开Xshell新建一个连接，名称可以随便取，但主机一定是我们刚才拿到的主机号</p><p><img src="6.jpg" alt="建立连接"></p><p>之后会有一个弹窗，我们选择接受并保存。这样我们就可以使用Xshell远程登录linux了。</p><h1 id="配置Samba"><a href="#配置Samba" class="headerlink" title="配置Samba"></a>配置Samba</h1><p>我们刚才在安装Ubuntu的时候，我们已经安装好Samba了，接下来我们配置Samba。</p><p>1.我们在命令行中输入<strong>sudo passwd root</strong>，这个时候提示我们输入新的密码，这一步是设置管理员密码，然后我们输入su进入管理员模式。</p><p><img src="7.jpg" alt="输入su指令"></p><p>2.之后我们输入<strong>mkdir share</strong>，创建一个share文件夹，输入<strong>chmod 777 share</strong>更改文件夹的权限。</p><p><img src="8.jpg" alt="创建共享文件夹并授权"></p><p>3.输入<strong>vim /etc/samba/smb.config</strong>，进入smg.config文件，将光标移动到最后，在文件末尾按i，开始修改文件。</p><p><img src="9.jpg" alt="修改smg.config文件"></p><p>4.我们在文件末尾加上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[share]</span><br><span class="line">comment = My Samba   //这里只是个对外界显示的说明信息</span><br><span class="line">path = /home/你的用户名/share    //这是你的共享文件夹的路径</span><br><span class="line">browseable = yes</span><br><span class="line">writeable = yes</span><br></pre></td></tr></table></figure><p>按esc退出编辑模式，输入:wq退出。</p><p>5.在管理员模式下（如果不是输入su进入），输入smbpasswd -a 你的用户名，输入密码并确认密码。</p><p>6.在Windows下打开此电脑，在地址栏输入\\ip地址，之后会提示输入Samba的账号和密码，正常输入，之后我们就可以看到我们在linux下建立的分享文件了。</p><p>7.我们右键文件，选择映射网络驱动器（Map network drive），之后我们确认，这样Samba的配置就完成了。</p><h1 id="gcc安装"><a href="#gcc安装" class="headerlink" title="gcc安装"></a>gcc安装</h1><p>linux环境的最后一步，安装GCC，众所周知啊，国外的东西下载的都比较慢，所以我们这里提供一个更改下载源的方法，如果不嫌弃慢的同学可以直接向下寻找安装GCC的方法。更改下载源的方法是（注意一下操作均需管理员身份）：</p><p>1.在更改下载源之前，我们最好要备份一下原本的下载源以备不时之需，备份下载源的指令是<strong>cp /etc/apt/sources.list /etc/apt/sources.list.old</strong>。</p><p>2.备份好下载源后，我们输入<strong>vim /etc/apt/sources.list</strong>，将其中的内容替换为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>我们可以在非insert模式（insert模式会在左下角标注）下按键盘的d键两次（小写模式下），快速删除一行，右键命令行进行粘贴。这样我们的下载源就更改完了，接下来我们开始安装gcc：</p><p>1.我们在管理员模式下输入<strong>apt-get update</strong></p><p>2.待更新完毕后，输入<strong>apt-get install build-essential</strong>，之后会提示我们是否继续我们输入<strong>y</strong></p><p><img src="10.jpg" alt="gcc安装"></p><p>3.之后可能还会有一个安装选择，我们选<strong>yes</strong>即可</p><p>这样gcc也安装完毕了，我们可以在命令行中输入<strong>gcc -v</strong>，查看是否安装成功，如果安装成功就会出现gcc版本信息。</p><h1 id="vscode安装及配置"><a href="#vscode安装及配置" class="headerlink" title="vscode安装及配置"></a>vscode安装及配置</h1><p>现在我们已经安装好了Linux环境，那我们还需要一个写代码的地方，这里我们选择vscode作为编辑器。具体安装方式及配置如下：</p><p>1.我们安装好vscode，然后安装，安装的过程很简单，这里不展开说明。（附上安装包：<a href="https://pan.baidu.com/s/1V8sPlByLTTL79hrg3oC1-Q?pwd=uorb">戳我下载</a>）</p><p>2.接下来我们开始配置vscode，因为我们的代码多半都是放到Linux跑的，所以我们对vscode的设置没有那么复杂，我们只需要下载几个方便我们写代码的插件即可，这里推荐的是C/C++ Extension Pack，Tabnine AI。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从今天开始，我们开始学习如何在Linux下进行高性能的服务器开发，学习之前我们掌握基本的C/C++语法，配置好相关的环境，如果你觉得这些东西</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（二）</title>
    <link href="http://example.com/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-10-25T13:24:18.000Z</published>
    <updated>2022-10-26T10:39:49.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h1><p>在了解过计算机网络的几个分层模型后，我们来分别了解一下这些层，这一篇我们先来了解一下物理层，在计算机网络中用来连接各种网络设备的传输媒体有很多，大致可以分为两类，导引型传输媒体和非导引型传输媒体。导引型传输媒体有双绞线、同轴电缆、光纤，非导引型传输媒体常常是微波通信。物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，物理层会为上层的数据链路层提供透明的服务，为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层协议和服务，而不用考虑网络具体传输用到的媒体是什么。所以物理层协议的主要任务要解决四个问题：</p><ol><li>指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定的装置</li><li>指明接口电缆的各条线上出现的电压的范围</li><li>指明某条线上出现的某一电平的电压表示何种意义</li><li>指明对于不同功能的各种可能事件的出现顺序</li></ol><p>因为物理层用来传输的物理媒介众多，所以物理层的协议也很多，但每一个协议都包含上述四个问题的具体解决方案，所以我们要掌握的应该是一些基本概念，而不是某个具体的物理层协议。</p><h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><p>物理层讲究的是如何将比特流在信道上进行传输，所以我们就来了解一下物理层的传输方式。</p><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p>串行传输的意思是数据是一个比特一个比特被送上信道的，所以只需要一条信道就可以完成串行传输。而并行传输的意思是同一时间有n个比特被送上信道，这就需要n条信道进行传输了，并行传输的优点是速度为串行传输的n倍，但成本也高一点。在计算机内部CPU与其他电子器件进行数据传输用的是数据总线，数据总线的宽度有8位、16位、32位和64位，所以计算机内部往往使用并行传输，而在计算机网络中进行远距离的数据传输大多使用的是串行传输。</p><h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><p>同步传输，数据以稳定的比特流的形式传输，字节之间没有间隔，接收端在每一个比特信号的中间时刻进行检测，以判别接受的是0还是1，但每一个主机的时钟多少都会存在差异，这就会导致同步传输会出现误差，所以同步传输的同时要将收发双方的时钟同步，同步的方法有两种一种是外同步，一种是内同步。外同步指在收发双方之间添加一条单独的时钟信号线，传输数据的同时传输时钟信号以同步双方时钟。内同步是指发送端将时钟同步信号编码到发送数据中一同传输（例如曼彻斯特编码）。</p><p>异步传输，异步传输说的是数据以字节的形式在信道上传输，且每个字节间间隔时间不等，目的主机只需要与当前接收到的字节时钟同步即可，为此异步传输的字节前后要分别加上起始位和结束位。异步传输的异步体现在每两个字节间的间隔时间不等，但是字节中每一比特的持续时间仍然相同。</p><h2 id="单工通信、半双工通信、双工通信"><a href="#单工通信、半双工通信、双工通信" class="headerlink" title="单工通信、半双工通信、双工通信"></a>单工通信、半双工通信、双工通信</h2><p>这个我们之前已经有提到过，这里在复习一遍。</p><p>单工通信指的是在通信过程中只有一条单向的信道，一方作为发送端，一方作为接收端进行单向的通信，例如我们听广播，电台就是发送端，收音机就是接收端。</p><p>半双工通信指的是在通信过程中有两条信道，这两条信道方向相反，双方都可以作为发送端或接收端，但是在同一时间中，只有一方可以作为发送端，例如对讲机，在同一时间只有一台对讲机可以向其他对讲机发送信息。</p><p>双工通信指的是在在通信过程中有两条信道，这两条信道方向相反，双方都可以作为发送端或接收端，双方可以同时发送信息，也同时接收信息，例如我们平时打电话，就是这种传输方式。</p><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><p>在计算机网络中，计算机需要处理和传输用户的文字、图片、音频和视频，它们可以统称为消息，这些消息在计算机内会转变为二进制数据，之后这些二进制数据会被网卡转换为电信号，由发送端发出的原始电信号叫做基带信号，基带信号又被分为两种一种是数字基带信号，一种是模拟基带信号。数字基带信号就是计算机内部CPU和内存之间传输的信号，模拟基带信号可以是麦克风接收到声音后转换成的电信号。信号需要在信道中进行传输，根据信号的分类，信道也被分为了数字信道和模拟信道。<strong>在不改变信号性质的前提下，将数字信号/模拟基带信号的波形进行变化的行为叫做编码，编码后产生的信号还是数字信号/模拟信号，在数字信道中进行传输。把数字基带信号/模拟基带信号的频率范围搬移到较高的频段并转换为模拟信号的行为叫做调制，调制后的信号是模拟信号，在模拟信道中传输。</strong>一段信号中会有不同的波形用来表示0和1，这些表示0和1的波形片段我们称为<strong>码元</strong>。</p><h1 id="常用编码方式"><a href="#常用编码方式" class="headerlink" title="常用编码方式"></a>常用编码方式</h1><p>接下来我们看一看常用的编码方式都有哪些：</p><p><img src="1.jpg" alt="常用编码方式"></p><p>常用的编码有四种分别是：</p><ol><li>不归零编码：不归零编码和它的名字一样，意思是在比特流的每一个码元持续时间内，都不归零。若要实现不归零编码就要实现发送方的发送和接收方的接受做到严格的同步，我们可以加上一根传输线来传输时钟信号来让双方同步。在计算机网络中我们并不提倡这么做，所以因为不归零编码存在着同步问题所以计算机网络中的数据传输不使用这种办法。</li><li>归零编码：我们根据图片可以得知，在归零编码中，每一个码元传输结束后都要“归零”，所以接收方只需要接收信号归零后的信号即可，不需要单独的时钟信号，但本质上归零编码用归零的形式放到了数据之中，这种数据我们叫它自同步信号。虽然解决了时钟信号的传输问题，但是归零编码中大部分的数据带宽都用来传输“归零”了，这也是一种浪费。</li><li>曼彻斯特编码：曼彻斯特编码的特点是会发生跳变，如果发生了负跳变（由正电平变为负电平）表示1，正跳变（由负电平变为正电平）表示0，码元中间时刻的跳变即表示时钟也表示数据。</li><li>差分曼彻斯特编码：差分曼彻斯特编码也会发生跳变，但是它用码元开始处电平是否变化来表示数据，如果当前码元开始电平和上一个码元结束电平相同则当前码元表示1，反之表示0。差分曼彻斯特编码的跳变只表示时钟</li></ol><h1 id="常用调制方式"><a href="#常用调制方式" class="headerlink" title="常用调制方式"></a>常用调制方式</h1><p>我们再看看常用的调制方式有哪些:</p><p><img src="2.jpg" alt="常用调制方式"></p><p>常用的调制方式有三种:</p><ol><li>调幅（AM）：载波的振幅随基带数字信号而变化</li><li>调频（FM）：载波的频率随基带数字信号而变化</li><li>调相（PM）：载波的初始相位随基带数字信号而变化</li></ol><p>使用基本的调制方法，1个码元只能包含一个比特信息，如果希望一个码元中包含更多信息，我们可以使用混合调制的方式来调制，但因为频率和相位是相关的，所以一次只能调制频率和相位两个中的一个。一般情况下，我们常将相位和振幅结合在一起调制，称为正交振幅调制，QAM。</p><h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><p>信号的传输不是完整无误的进行传输的，尤其是在很远的距离进行传输，一个输入信号的波形在经过通信质量较好的信道后，接收端有能力根据失真不严重的信号还原出原信号，但如果一个输入信号经过了通信质量很差的信道后，接收端很难还原失真严重的信号。以下这些因素都会使信号失真：</p><ol><li>码元传输速率</li><li>信号传输距离</li><li>噪声干扰</li><li>传输媒体质量</li></ol><h1 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h1><p>1924 年，奈奎斯特 (Nyquist) 就推导出了著名的奈氏准则。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。</p><p>奈氏准则讲的是理想低通信道的<strong>最高码元传输速率为2W Baud，理想带通信道的最高码元传输速率为W Baud</strong>。这里说的W是信道（频率）带宽，Baud是单位波特，也就是码元/秒的意思。码元传输速率又称为波特率、调制速率、波形速率或者符号速率，它与比特率有一定的关系：</p><ol><li>当一个码元只携一比特的信息量时，波特率（码元/秒）与比特率（比特/秒）在数值上是相等的、</li><li>当一个码元携带n比特的信息量时，则波特率转换成比特率时，数值要成以n</li></ol><p>因为奈氏准则是在理想状态下推导出来的准则，所以实际信道所能传输的最高码元速率要明显的低于奈氏准则的上限速率。因为码元的传输速率受奈氏准则的制约，所以要提高信息的传输速率，就必须设法使每个码元能携带更多个比特的信息量。这就需要采用多元制的调制方法，如正交振幅调制 QAM 。那是不是我们有可以无限的提高码元携带的比特数量，就可以无限的提高信息的传输速率呢？答案是否定的，因为在信道的极限信息传输速率还要受限于实际的信号在信道中传输时的信噪比。噪声存在于所有的电子设备和通信信道中，噪声是随机产生的，它的瞬时值有时会很大。因此噪声会使接收端对码元的判决产生错误。信噪比就是信息量和噪音的比值。</p><h1 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h1><p>1984年，香农 (Shannon) 用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。公式为：</p><p><img src="3.jpg" alt="香农公式"></p><p>公式中C表示信道的极限信息传输速率（b/s），W表示信道（频率）带宽（HZ），S表示信道内所传信号的平均功率，N表示信道内得高斯噪声功率。我们还可以根据N和S计算信噪比，公式为：</p><p><img src="4.jpg" alt="信噪比公式"></p><p>根据公式我们可以知道信道带宽或信道中信噪比越大，信息传输的速率越高。在实际信道上能够达到的信息传输速率会远远低于该公式的极限传输速率，因为在实际信道中，信号还有其他的损失，比如脉冲干扰，信号在传输中的衰减和失真，香农公式并未考虑这些问题。因此根据香农公式和奈氏准则，诞生了大量的调制方法<strong>提高调制速度</strong>和<strong>提高信噪比</strong>的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;物理层的基本概念&quot;&gt;&lt;a href=&quot;#物理层的基本概念&quot; class=&quot;headerlink&quot; title=&quot;物理层的基本概念&quot;&gt;&lt;/a&gt;物理层的基本概念&lt;/h1&gt;&lt;p&gt;在了解过计算机网络的几个分层模型后，我们来分别了解一下这些层，这一篇我们先来了解一下物理层，</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（一）</title>
    <link href="http://example.com/2022/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-10-24T12:40:05.000Z</published>
    <updated>2022-10-26T04:05:20.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h1><p>计算机网络是将一个分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。说的直白点呢，就是我们可以理解为我们使用的电子设备，比如手机啊，电脑啊这类的东西，它们通过通信设备比如路由器，交换机，通过线路，信号等方式连接到了一起，这样我们就有了最基本的连接，也是实现网络的基础，之后我们可以通过一些软件，比如QQ，微信就可以和别人传输文件，聊天，也就是实现了资源共享和信息传递。所以我们说计算机网络是互联互通的、无主从关系的计算机集合。当然这句话说的也是有点遮遮掩掩的，所以我来为大家解释一下，互通互联就意思这些电子设备一定是相互连接到一起的，可能通过光纤，卫星信号等等方法，总之是连接到了一起。无主从关系的意思是虽然它们通过一种方式连接到了一起，但是它们并不会控制对方或者被对方控制，完全是一个独立的个体。</p><h1 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h1><p>计算机网络有四大基本的功能：</p><ol><li>数据通信：计算机网络可以实现数据的通信，比如我们经常会通过微信给别人传文件。</li><li>资源共享：资源共享又分为3类，分别是硬件资源共享，软件资源共享，数据资源共享，硬件资源共享可以体现在传真机上，我们并不一定要占有一个传真机才能使用。软件资源共享可以体现在现在的云服务，有些软件并不需要我们下载到本机上就可以使用。数据资源共享，这个就很常见了，比如我们经常在网络上搜索各种文档。</li><li>分布式处理：分布式处理的意思就是一个任务的工作量很大，那我们就把任务拆解，分给不同的计算机承担，提高工作效率，比如Hadoop平台，可以分布式的存储数据，处理数据。</li><li>提高可靠性：我们可以假象这样一个情况，我们有一个一直运行的主机，有一天它不堪重负，突然宕机了，如果我们只有这样的一个主机，那可就完了，但是计算机网络可以解决这样的问题，因为它为我们提供了更多的主机，当一个主机宕机之后，还可以有别的主机做它的替代机。  </li></ol><h1 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h1><p>计算机网络的组成可以通过不同的角度来区分：</p><p>从组成部分角度来看，计算机网络由硬件、软件、协议组成。硬件很好理解了，我们肯定需要一个设备才能参与到连接之中，软件我们之前也说到了，有了软件才可以进行数据，资源的传输。协议是计算机网络的核心，它是一系列规则和约定的集合，只有遵循协议才可以进行安全的传输。</p><p>从工作方式角度来看，计算机网络由边缘部分、核心部分组成。边缘部分是用户直接使用的，可以在这个工作方式下进行信息和文件的传输，通常分为C/S方式和P2P方式，C/S方式就是客户端服务器模式，而P2P方式就是对等方式。核心部分是为边缘部分服务的，说的简单点就是我们的基站，转换机这类的东西。</p><p>从功能组成角度来看，计算机网络由通信子网、资源子网组成，通信子网实现了数据通信，资源子网实现了资源共享、数据处理。</p><h1 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h1><p>计算机网络按照分布范围分类可以分为广域网WAN、城域网WAN、局域网WAN、个人区域网PAN。广域网的范围就和名字一样很广阔，一般是跨国的。城域网一般是一个城市内得网络，局域网可能大家听得比较多，局域网大多相差的距离在1000米内，一般我们在学校使用的校园网就是多个局域网相连的。个人区域网可能不常听到但其实每天我们都可以接触到，比如我们给别的电子设备开热点，我们的智能手表这些都是个人区域网的体现。广域网使用的技术叫做交换技术，而局域网使用的是广播技术，这个我们以后还会在提到。</p><p>计算机网络按照使用者分类可以分为公用网、专用网。这个就很好理解，公用网就是我们平常大家都可以用的网络，比如电信，联通这些网络，而专用网是需要一定的权限才可以进入的网络，就比如银行网络，军队网络这些一般人是不能随意进入的。</p><p>计算机网络按照交换技术分类可以分为电路交换、报文交换、分组交换，后续我们会详细的介绍这些。</p><p>计算机网络按照拓扑结构分类可以分为……等等什么是拓扑结构？网络拓扑是网络形状，或者是网络在物理上的连通性。网络拓扑结构是指用传输媒体互连各种设备的物理布局，即用什么方式把网络中的计算机等设备连接起来。拓扑图给出网络服务器、工作站的网络配置和相互间的连接。也就是说实际上就是我们硬件层面上基站啊交换机啊这些东西都是怎么连接的，所以按照这个结构分可以分为总线型、星型、环型、网状型，我们使用的广域网就是一个网状型的拓扑结构。我们可以看一下这些结构都长什么样子：</p><p><img src="1.jpg" alt="网络拓扑结构"></p><p>计算机网络按照传输技术分可以分为广播式网络、点对点网络。广播式网络的意思是设备共享公共通信信道，就好像是我们平时听广播，当一个设备向信道传输信息后，所有连接在一起的设备都可以接收到信息，接收到信息后会进行一些处理看看是不是传给自己如果是就收下，反之就丢弃。点对点网络，使用分组存储转发和路由选择机制，进行一对一的计算机通信。</p><h1 id="标准化工作及相关组织"><a href="#标准化工作及相关组织" class="headerlink" title="标准化工作及相关组织"></a>标准化工作及相关组织</h1><p>标准化对计算机网络至关重要！要实现不同厂商的硬件、软件之间相互连通，就必须要遵从统一的标准。</p><p>我们将标准分为两类：法定标准、事实标准。法定标准是由权威机构制定的正式的、合法的标准，比如我们接下来会介绍的OSI。事实标准是某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准，就比如现在很常用的TCP/IP协议。</p><h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><p>计算机网络有八个性能指标来表示计算机网络的性能，接下来我们一个一个的了解一下。</p><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>速率即数据率或称数据传输率、比特率都可以。我们知道计算机实际上存储的都是0 1这样的二进制数字，所以我们传输的也是这样的数据，数据传入信道都是1个比特1个比特的进入的，那么速率表示的就是连接在计算机网络上的主机在数字信道上传送数据位数的速率单位有b/s，kb/s，Mb/s，Gb/s，Tb/s。假如现在我们有两台电脑，一个是发送端，一个是接收端。发送端准备了0101010101这样的10b大小的数据要传输给接收端，如果它在1s内完成了传输。那我们就说传输的速率为10b/s。速率的换算都是1000一进位，比如1kb/s就等于1000b/s。 这里要注意区分速率和存储容量，当我们描述速率的时候是符合这样1000进率的，但如果我们描述的是数据的大小，那就不一样了，比如1KB=1024B。这里还有一个小细节可以区分描述的是速率还是存储容量，当我们描述存储容量的时候单位一般是全大写的。</p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>带宽原本指的是某个信号具有的频带宽度，即最高频率和最低频率之差，单位是赫兹(Hz)。在计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“最高数据率”，也可以理解为网络设备每秒向信道上发送的最大数据量，比如我们买了一个100M带宽的交换机，那代表的意思就是交换机每秒最多往信道上传输100M的数据。带宽的单位有b/s，kb/s，Mb/s，Gb/s。</p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量，单位也是b/s，kb/s，Mb/s等，吞吐量受网络的带宽或网络的额定速率的限制。吞吐量是实际传输速率的总和，如果我们的主机接收两个服务器的数据一个的速率是20Mb/s，一个是10Mb/s，那么吞吐量就是30Mb/s</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延指的是数据（报文、分组、比特流）从网络的一端传输到另一端所需要的时间，也称为延迟，单位是s。时延还可以划分为发送时延（传输时延），传播时延，排队时延，处理时延。发送时延指的是从发送分组第一个比特算起到最后一个比特发送完毕所需要的时间，换句话说就是主机将要发送的数据全部送到链路（信道）上所需要的时间，我们使用<strong>数据长度/信道带宽</strong>就可以得到发送时延。传播时延指的是信息传输到目的主机所需要的时间，我们可以通过<strong>信道长度/电磁波传播速率</strong>得到传播时延。排队时延和处理时延发生在信息传输的途中，我们的信息到达路由器的时候，路由器需要处理一下这些数据，那么因为我们的数据不是一次性的传输过来，所以就要一个一个的处理，这个时候就要排队，所以会有一个排队和处理的时延。</p><p>一般来讲我们只能通过提高信道的带宽去降低发送时延，很难去改变传播时延，因为那需要对现在的硬件层面有一定的提升才可以做到。</p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积=传播时延×带宽，我们刚才说传播时延就是数据从发送端传输到接收端所需要的时间，带宽是发送端每秒可以向链路上传输的数据量，那么时延带宽积就可以表示当前链路中有多少数据。所以时延带宽积又被称为以比特为单位的链路长度。</p><h2 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h2><p>当我们在打游戏的时候可能有的时候很卡，像是玩PPT一样，这就说明此时的往返时延RTT太高了，所以我们很卡。往返时延表示从发送方发送数据（当数据的第一个bit被放到链路上的时候）开始，到发送方收到接收方返回确认所用的时间（当接收方收到信息后立马就会发送确认）。RTT可以表示为传播时延×2+末端处理时间。我们可以在终端中使用ping命令来查看RTT：</p><p><img src="2.jpg" alt="往返时延RTT"></p><p>我们可以看到博主ping百度的往返时延就是18毫秒左右，在最下面也有体现。RTT越大，在收到确认之前，可以发送的数据也越多。这个很好理解我们在接收到确认之前只能不停的发送数据，时间越长，发的自然也越多。</p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>在计算机网络中我们将利用率分为两种，一种是信道利用率，一种是网络利用率。当两个主机进行信息传输的时候，信道中有百分之几的时间是被利用的，那我们就说信道利用率是多少，但我们想一个问题，如果我们在传输的过程中会有排队的情况出现，如果我们信道利用率很高，那么排队的时间也会很长，那么信道的利用率增大时，该信道引起的时延也会迅速增加，因此信道利用率并不是越高越好。但信道利用率过低又会浪费资源所以需要一个合理的机制来调控。</p><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p>丢包率即分组丢包率，指在一定时间的范围内，传输过程中丢失的分组数量与总分组数量的比率。丢包率具体可以分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等。分组丢失主要有两种情况：首先是分组在传输过程中出现误码，被结点丢失。其次是分组到了一台队列已满的分组交换机的时候就会被丢弃，在通信量较大的时候就可能造成网络拥塞。</p><h1 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h1><p>在了解分层结构之前，我们先来了解一下计算机进行数据传输之前需要做些什么。第一，发起通信的计算机必须将数据通信的通路进行激活。第二，要告诉网络怎么寻找目的主机。第三，发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。第四，发起通信的计算机要弄清楚对方计算机中文件管理程序是否已经做好了准备工作。第五，要确保差错和意外是可以解决的……</p><p>这些问题都是进行数据传输前要解决的，如果我们要将这些问题视为一个整体去处理显然是很难的，所以我们将这个大问题拆分成很多小问题再去解决，这也就是为什么我们要分层。</p><h2 id="分层的基本原则"><a href="#分层的基本原则" class="headerlink" title="分层的基本原则"></a>分层的基本原则</h2><p>了解了为什么要分层，我们来了解一下分层的几个原则：</p><ol><li>各层之间相互独立，每层只实现一种相对独立的功能</li><li>每层之间界面自然清晰，易于理解，相互交流尽可能少</li><li>结构上可分隔开，每层都采用最合适的技术来实现</li><li>保持下层对上层的独立，上层单向使用下层提供的服务</li><li>整个分层结构应该能促进标准化工作</li></ol><h2 id="一些分层结构中出现的名词"><a href="#一些分层结构中出现的名词" class="headerlink" title="一些分层结构中出现的名词"></a>一些分层结构中出现的名词</h2><p><img src="3.jpg" alt="具体的分层结构"></p><p>我们根据上面的图片，来了解一下具体的分层结构，以及分层结构中的一些名词。</p><p>第一个是实体，我们可以看到图片中每一层都有数据，这些数据我们就可以叫做实体，第n层的数据我们就叫它n层实体，而另一台主机上与它同层的数据就是它的对等实体。</p><p>第二个是协议，协议是为进行网络中的对等实体数据交换而建立的规则、标准或约定成为网络协议，网络协议只建立在对等实体之间，不对等的实体不存在协议。协议有三要素，语法，规定传输数据的格式，语义，规定要完成的功能，同步，规定各种操作的顺序。</p><p>第三个是接口，我们可以看到每一层之间都有一层接口，这是上层使用下层服务的入口，也是下层为上层提供服务的入口。</p><p>第四个是服务，下层为相邻上层提供的功能调用。</p><h1 id="具体的分层结构"><a href="#具体的分层结构" class="headerlink" title="具体的分层结构"></a>具体的分层结构</h1><p>现在我们已经了解了基本的分层结构，知道了分层结构中的名词，实际上分层结构有两种参考模型，一种是7层的OSI参考模型，一种是4层的TCP/IP参考模型，我们分别了解这两个模型。</p><h2 id="7层OSI参考模型"><a href="#7层OSI参考模型" class="headerlink" title="7层OSI参考模型"></a>7层OSI参考模型</h2><p>为了解决计算机网络复杂的大问题，所以产生了按功能划分的分层结构，所以各个公司都根据这种分层结构提出了不同的网络体系结构，比如IBM的SNA，DEC的DNA，美国国防部的TCP/IP等等，但这么多网络体系结构注定是不方便我们通信的，所以ISO在1984年秉承着支持异构网络系统互联互通的原则，提出了开放系统互联（OSI）参考模型。它的理论十分完美，只是在市场上有点……</p><p>OSI参考模型分为7层，从上至下分别是应用层、表示层、会话层、传输层、网络层、数据链路层、物理层，这7层每一层都负责一个或多个任务。下三层是通信子网负责数据通信，上面三层是资源子网负责数据处理，传输层是这两个子网之间的接口，用来连接两个子网。</p><p><img src="4.jpg" alt="7层OSI参考模型"></p><p>我们在看一下OSI模型通信的一些基本知识，OSI模型通信由源主机、中间系统和目的主机构成。上面四层，也就是应用层到传输层这四层是端到端的，也就是关注的是数据从源主机交付到了目的主机，而不关注每一步是如何传输的，而下三层是点到点的，关注数据在传输过程中下一步要去往哪里。每一层都会对数据进行处理然后传递给下一层。</p><p><img src="5.jpg" alt="OSI模型通信基本架构"></p><p>接来下我们来看一下OSI模型通信的过程。</p><p>当我们的主机A发出了一条消息后，应用层会先给它加上一个应用层头部也就是我们说的PCI，这个PCI包括用来检查错误的信息，传输过程中下一个地方的地址，数据的优先级等等，然后这个PCI和我们原先的DATA也就是SDU组成新的PDU传递给表示层，然后表示层加上表示层PCI继续往下传，重复这个过程，等到传输到数据链路层以后呢，数据链路层还要在给数据加上一个尾部再传给物理层，最后物理层将得到的已经加上了很多东西的数据变成二进制比特流传输给主机B。因为两个主机对应的层都建立了统一的协议，所以主机B可以反向将得到的比特流一步步还原成最开始的数据，这样就完成了数据的通信。</p><p><img src="6.jpg" alt="OSI模型通信过程"></p><p>我们再来看一下每一个层次对应的功能和一些比较重要的协议。</p><p>第一个是应用层，应用层是用户与网络交互的界面，所有能和用户交互产生网络流量的程序都属于应用层。应用层常见的几个服务有文件传输使用的协议是FTP，电子邮件使用的协议是SMTP，万维网使用的协议是HTTP。</p><p>第二个是表示层，表示层用来处理两个通信系统中交换信息的表示方式（语法和语义）。它的几个主要的协议有JPEG和ACSII。它有以下几个功能：</p><ol><li>数据格式变换：因为不同的主机编码和数据表示的形式可能会有些不一样，所以表示层要对数据格式进行转换。</li><li>数据加密解密：因为我们传递的数据可能具有一定的私密性，如果直接随意的送入信道，很有可能出现被人抓包的状况，所以表示层会对传输的数据进行加密，当然也可以对接收到的数据进行解密。</li><li>数据的压缩和恢复：我们在进行图片或者视频的传输的时候，这些文件往往都很大，所以我们会先压缩一下这些文件然后再进行传输。</li></ol><p>第三个是会话层，会话层向表示层实体/用户进程建立连接并在连接上有序地传输数据，也就是在两个进程中建立同步。所以会话层有这些功能：</p><ol><li>建立、管理、终止会话</li><li>使用校验点可使会话在通信失效的时候从校验点继续恢复通信，实现数据同步，会话层会将数据切开并在切口处插入一个校验点，当我们传输数据的过程中突然网络出现了错误，会话断开了，等到网络恢复，会话重新连接后，数据会从校验点继续传输，而不是从新传输。</li></ol><p>会话层的主要协议有ADSP、ASP。</p><p>第四个是传输层，传输层负责主机中两个进程的通信，即端到端的通信。传输单位是报文段或用户数据报。计算机中每一个进程都有一个端口号与之对应，所以端到端的通信就来源于这。传输层有四个功能：</p><ol><li>可靠传输、不可靠传输：可靠传输是先建立连接，然后发送数据，在接收到确认的数据后，再发送下一个数据的一个传输方式，通常在传输大型文件的时候使用，不可靠传输，通常是在传输一些小型数据的时候使用的，比如我们在QQ上给好友发了个你好，这种时候就没有必要使用可靠传输了，那样会比较浪费。</li><li>差错控制：当报文传输失序，丢失或者发生其他情况的错误的时候，传输层就会站出来修正这些错误。</li><li>流量控制：这个流量控制表达的是发送和接收的速率，当我们发送方发送的速度高于接收方接收的速度的时候，传输层就会调整发送的速度，这个过程就叫流量控制。</li><li>复用分用：复用指的是多个应用层进程可同时使用下面运输层的服务，分用指的是运输层把收到的信息分别交付给上面的应用层中相应的进程。听起来很复杂，我们举一个例子，假定QQ的端口号为1，微信的端口号为2，当我们将报文段放入链路层传输给对方后，对方的会话层就会读取端口号信息，假如对方会话层读到了端口号1，那么它就知道这条消息应该出现在QQ里，所以它就把数据送入了QQ，这就是复用和分用的过程。</li></ol><p>传输层主要的协议是TCP、UDP。</p><p>第五层是网络层，网络层主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，网络层传输单位是数据报。这里说到的数据报和分组就好像是一对父子，当数据报过长的时候，就将数据报切割开变成一个一个的分组。网络层有以下几个功能：</p><ol><li>路由选择：我们知道网络的连接不是简简单单的单线连接，而是错综复杂的连接到了一起，所以我们可以有多条道路和其他主机连接到一起，这就说明我们可以通过多条道路将数据传输到目的主机之上，但是我们应该选择哪条呢？网络层会通过路由选择算法来选择出最佳的路径，让数据报可以正确顺利的传输到目的主机上。</li><li>流量控制：这个功能和传输层做的事情是一样的。</li><li>差错控制：当出现错误的时候，网络层就会进行处理，如果可以处理那就处理，如果处理不了就会将分组丢掉以保证正确。</li><li>拥塞控制：拥塞控制是一种宏观上的控制，如果传输过程中所有节点，包括中间系统都来不及接收分组，而要丢弃大量分组的话，网络就处于了拥塞状态，因此要采取一定的措施，来缓解拥塞。</li></ol><p>网络层主要的协议是IP、IPX、ICMP、IGMP、ARP、RARP、OSPF。</p><p>第六层是数据链路层，数据链路层的主要任务是把网络层传下来的数据报，组装成帧。因此数据链路层的传输单位就是帧。当然数据链路层的功能也和帧有关：</p><ol><li>成帧：定义帧的开始和结束。</li><li>差错控制：主要错误是帧错和位错，数据链路层会采取相应的措施来解决这种错误。</li><li>流量控制：同样也是对发送方和接收方的速度进行协调。</li><li>访问（接入）控制：控制对信道的访问，在广播室网络中同一时间只能有一个主机发送信息，其余主机处于监听状态，所以需要控制主机对信道的访问。</li></ol><p>数据链路层主要的协议有SDLS、HDLC、PPP、STP。</p><p>第七层是物理层，物理层主要的任务是在物理媒体上实现比特流的透明传输，物理层传输单位是比特。透明传输指不管所传数据是什么样的比特组合，都应该能在链路上传送。物理层的功能也比较贴合硬件：</p><ol><li>定义接口特性：接口特性有很多，比如要确定连接电缆的插头有几个引脚。</li><li>定义传输模式：传输模式有单工、半双工、双工，单工就是指一方只发，一方只收的单向传导模式，半双工就是指双方都可以作为发送方或接收方，但是同一时间只能有一个人在发送，双工就是双方可以同时发送和接收。</li><li>定义传输速率</li><li>比特同步</li><li>比特编码</li></ol><p>物理层主要的协议有Rj45、802.3。</p><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><p>聊完了OSI模型现在我们来聊一下TCP/IP模型，我们刚才也说了OSI模型在市场层面有点……</p><p>TCP/IP模型分为四层分别是应用层、传输层、网际层、网络接口层。我们也可以将TCP/IP模型和OSI模型联系起来，OSI中的应用层、表示层、会话层合成TCP/IP模型的应用层，OSI中的数据链路层、物理层合成TCP/IP中的网络接口层。TCP/IP模型是基于协议栈出现的。</p><p><img src="7.jpg" alt="TCP/IP模型"></p><p>我们再看TCP/IP的协议栈，这里面最为主要的就是TCP协议和IP协议，因为我们这个模型就叫TCP/IP模型嘛，它们也非常常用。</p><p>接下来我们通过了解TCP/IP和OSI之间的异同来学习TCP/IP模型。首先是相同点：</p><ol><li>都分层</li><li>都是居于独立的协议栈的概念</li><li>都可以实现异构网络互联</li></ol><p>不同点：</p><ol><li>OSI定义三点：服务、协议、接口</li><li>OSI先出现，参考模型先于协议发明，不偏向特定协议</li><li>TCP/IP设计之初就考虑到了异构网互联的问题，所以将IP作为重要的层次，这也是为什么TCP/IP网络层使用无连接模式传输</li><li>在通信方式方面，OSI的网络层采用的是无连接+面向连接的混合模式，而TCP/IP采用的是无连接模式。OSI的传输层采用的是面向连接模式，而TCP/IP采用的是无连接+面向连接的混合模式</li></ol><p>这里补充一下，面向连接分为三阶段，第一阶段是建立连接，在此阶段，发出一个建立连接的请求，第二阶段是在连接成功建立之后，开始传输数据。第三阶段，当数据传输完毕，必须释放连接。而无连接就没有这么多阶段，它直接就可以开始数据传输。</p><h2 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h2><p>这个模型是综合OSI和TCP/IP的优点而诞生的模型，OSI每一层功能清晰，TCP/IP结构简单，这么一综合，五层模型就诞生了。它分为应用层、传输层、网络层、数据链路层、物理层。下图展示了每一层负责的工作。</p><p><img src="8.jpg" alt="五层参考模型"></p><p>五层模型的数据封装和解封装和OSI很相似，我们会在应用层加上控制信息产生报文，在传输层切断，加上控制信息变成报文段，在网络层再加上控制信息变成数据报，如果数据报过长就切开变成分组，到了数据链路层就将数据报组成帧，在头和尾加上控制信息变成帧，最后到了物理层将帧转变成比特流放到链路上传输，到中间系统会进行一次解封装，然后继续传输到达目的主机后，就会反向的一层一层的去掉控制信息，最后，目的主机获得数据。</p><p><img src="9.jpg" alt="五层模型的数据封装和解封装"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络的概念&quot;&gt;&lt;a href=&quot;#计算机网络的概念&quot; class=&quot;headerlink&quot; title=&quot;计算机网络的概念&quot;&gt;&lt;/a&gt;计算机网络的概念&lt;/h1&gt;&lt;p&gt;计算机网络是将一个分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C++面向对象编程（一）</title>
    <link href="http://example.com/2022/10/19/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/10/19/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-10-19T05:33:08.000Z</published>
    <updated>2022-10-19T13:53:43.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>欢迎，各位来到C++面向对象编程的学习，相信各位已经学习过C语言，已经进入到了程序的世界，本课程要求一些c++的基础知识，比如控制流程，循环，指针，引用等等概念，如果清楚可以B站搜索黑马程序员的C++课程，本系列基于侯捷老师的C++课程，为大家讲解C++面向对象的一些知识，同时规范一下程序的书写，事不宜迟，我们马上开始！</p><h1 id="面向过程？面向对象？"><a href="#面向过程？面向对象？" class="headerlink" title="面向过程？面向对象？"></a>面向过程？面向对象？</h1><p>相信各位，在学习C的过程中，一定已经动手写了很多程序了，我们通过写各种函数然后分析事物的指令步骤，依次调用相应的函数去解决问题，这样的操作有一个专有名词叫做面向过程编程，而面向对象编程，从过程中跳出来，将问题处理成转变成一个一个对象，通过对象去做一个行为进而解决问题。可能有的小伙伴还是有点晕，没关系我们举一个例子，写一个五子棋程序：</p><p>面向过程的设计思路就是首先分析问题的步骤：</p><p>1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。</p><p>面向对象的设计则是从事件中各个角色的行为出发来解决问题。</p><p>整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。他们只需要执行自己的行为就可以解决问题。</p><p>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。</p><p>当然我们并不是说面向对象优于面向过程，只是在不同的场合我们选择最为合适的设计。面向过程的性能比较高，面向对象的维护性，复用性，扩展性强。我们要根据场合有选择的使用。</p><h1 id="C-代码的基本形式"><a href="#C-代码的基本形式" class="headerlink" title="C++代码的基本形式"></a>C++代码的基本形式</h1><p>我们在编写代码的时候，建议分文件编写代码，这样的将各个功能模块化可以大大的方便代码的维护、扩展等等。</p><p>我们通常会将我们的类声明写在一个头文件中，其余实现写在另一个cpp中，当我们需要这个类的时候，我们只需要在主文件中使用#include即可使用我们写好的类。我们在编写一个头文件的时候，要记得写防御式声明，这样可以有效地避免头文件被多次引用的问题。防御式声明的语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _头文件名称(大写)_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _头文件名称(大写)_</span></span><br><span class="line">……</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">或者</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure><h1 id="面向对象——类"><a href="#面向对象——类" class="headerlink" title="面向对象——类"></a>面向对象——类</h1><p>在学会面向对象之前，我们要先知道什么是类，可能有的小伙伴会疑问类是什么？为什么面向对象编程要知道类？其实类和对象的关系密不可分，我们举一个例子，这天下的每一个人都是一个对象，我们有各自的名字，各自的性别等等属性，我们也都可以吃饭，可以学习等等，这个被叫做行为(方法)，所以我们将所有人抽象成人类，人类有名字，有性别这些属性，也有吃饭，学习这些行为。所以类就是我们根据实际抽象出来的拥有属性和行为的一个整体，而对象就是由类产出的个例。这就引出了面向对象的第一大特征：“抽象”。我们要学习如何抽象出一个类。类的基本语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">classname</span>             <span class="comment">//这被称为class head</span></span><br><span class="line">&#123;<span class="comment">//从此向下</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">classname</span>();</span><br><span class="line"><span class="function">type <span class="title">functionname1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function">type <span class="title">functionname2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">type <span class="title">functionname3</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    operate+(classname b)&#123; <span class="keyword">this</span>-&gt;属性<span class="number">1</span> += b.属性<span class="number">2</span>; &#125;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> type <span class="title">functionname4</span><span class="params">()</span></span>;</span><br><span class="line">type 属性<span class="number">1</span>;</span><br><span class="line">type 属性<span class="number">2</span>;</span><br><span class="line">……</span><br><span class="line">&#125;;<span class="comment">//从此向上称为class body</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> type <span class="title">functionname4</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以在类内完成函数的实现，也可以在类内声明，类外实现。声明好类以后我们就可以像使用其他基本数据类型一样声明一个对象了。</p><h1 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h1><p>如果你看过从0开始的汇编语言系列，那么你应该知道函数调用的一个过程是什么样子的，实际上函数调用是main函数将CPU的控制权转交给函数，自己停止运行，待函数运行完成将CPU的控制权返回给main函数后，main继续运行。如果函数内容很多，那么这样的转交带来的时间占用可以忽略，但如果函数内容不多，那么程序运行的大部分时间都将被这种转交的过程所占用，所以为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换。这种在函数调用处直接嵌入函数体的函数称为内联函数。实际上类内完成实现的函数都是内联函数，而类外完成的函数不是内敛函数。当然一个函数到最后是否会成为inline函数，我们是不得而知的，我们只能在<strong>函数的定义</strong>前面加上inline关键字，建议编译器将这个函数当做inline函数，至于是否真的会被当做inline函数，编译器要结合程序的复杂程度来确认。</p><h1 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h1><p>可能有的小伙伴已经注意到了，在类的声明中，我们使用了两个关键字public和private，这两个关键字的意思是公有和私有，公有代表可以在任何地方被访问到。私有表示只能在类内被访问。其实还有一种级别叫做protected，我们有序再来研究。</p><p>我们一般将类中数据部分放在private下，这就引出了我们面向对象程序设计的第二大特征：“封装”，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，就像是电视遥控器，我们只需要知道按下音量up键可以使声音变大就好，不需要知道按下按键后到底发生了什么使得音量变大。</p><p>我们在程序设计中要秉承着封装的原则，比如我们将数据放到private下禁止外界随意访问，当外界需要访问或者修改的时候，我们可以对外提供get和set接口。</p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>不知道小伙伴有没有注意到，在上面类的格式中，我们有一个函数很特别它的名字和类名相同，但是没有返回值类型，这个函数会在我们声明一个对象的时候自动调用，这个函数叫做构造函数。</p><p>我们看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classname</span>(type a=<span class="number">0</span>,type b=<span class="number">0</span>……):属性<span class="number">1</span>(a)，属性<span class="number">2</span>(b)……&#123;&#125;</span><br></pre></td></tr></table></figure><p>构造函数有参数，我们可以在参数列表中对这些参数赋值让这些参数变成默认实参，默认实参的意思是当我们声明一个对象的时候，如果我们没有指定对象的属性值，那么就使用默认实参，我们可以看到后面的属性1(a)，这就代表了将a的值赋给属性1，如果我们没有指定a的值，那默认a为0，赋值给属性1，当然这种特殊的语法是构造函数独享的。我们在编写构造函数的时候，要注意将属性初始化。</p><h1 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h1><p>当我们在写成员的行为的时候，我们希望一个行为可以对不同的事情做出不同应对，比如我们吃冰淇淋希望是用勺子挖着吃，吃饺子用筷子夹着吃等等。这个时候我们可以写多个函数比如EatIcecream()，EatDumpings()。但这样有一点麻烦，我们可以通过重载函数的方式解决，重载函数通常用来命名一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。<strong>重载函数要求函数名必须相同，但这些同名函数的指参数的个数、类型或者顺序至少有一个不同。</strong></p><p>几乎所有函数都可以重载，包括构造函数，就比如我们之前写的那条构造函数，我们可以将它重载为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classname</span>():属性<span class="number">1</span>(<span class="number">0</span>)，属性<span class="number">2</span>(<span class="number">0</span>)……&#123;&#125;</span><br></pre></td></tr></table></figure><p>这条代码表示，当我们声明一个对象时不可以指定属性，属性默认为0。编译器会根据我们声明对象的代码决定到底使用哪一个构造函数。</p><h1 id="将构造函数放在private下"><a href="#将构造函数放在private下" class="headerlink" title="将构造函数放在private下"></a>将构造函数放在private下</h1><p>我们要考虑一个问题，我们之前说过private下的无论是属性还是行为都不可以被外界随意访问，但如果我们将构造函数放在了private下呢？我们还可以正常的声明一个对象吗？显然，这是不行的，当我们声明一个对象的时候我们就需要调用构造函数而构造函数被放在了private下不能被访问，那么也就无法创建对象。但这样做有什么意义吗？当然有，这在设计模式中被称为单例模式。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="type">static</span> A a;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">setup</span>()&#123;……&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个经典的单例模式的例子，我们不允许外界声明处一个A类型的对象，我们在getInstance函数中声明一个A类型的对象并将它返回，当我们外界需要使用类A中的setup函数的时候我们可以这样调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A::getInstance().setup();</span><br></pre></td></tr></table></figure><p>我们通过A作用域下的getInstance获得A类对象，然后使用setup函数。</p><p>那么为什么要使用单例模式呢？</p><p>首先单例模式节省公共资源，如果大家都要喝水，但是没必要每人家里都打一口井是吧，通常的做法是整个村里打一个井就够了，大家都从这个井里面打水喝。对应到我们计算机里面，像日志管理、打印机、数据库连接池、应用配置这一类事情都会使用单例模式。其次是单例模式方便控制就像日志管理，如果多个人同时来写日志，你一笔我一笔那整个日志文件都乱七八糟，如果想要控制日志的正确性，那么必须要对关键的代码进行上锁，只能一个一个按照顺序来写，而单例模式只有一个人来向日志里写入信息方便控制，避免了这种多人干扰的问题出现。</p><h1 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h1><p>我们回过头看我们类声明那一部分的代码， 有一个函数后面有const标记，这代表着我这个函数将不会改变任何值，可能有人认为这种东西真的有必要吗？答案是肯定的，当我们在声明一个const的对象的时候，我们规定这个对象的属性不可以被更改，但如果我们调用了一个没有const标记的函数，无论我们这个函数是否修改了属性，编译器都会认为这个函数可能修改属性，这是不被允许的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> v):<span class="built_in">age</span>(v) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">getage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这样的代码将会产生这样的错误：</p><p><img src="1.jpg" alt="常量成员函数的必要"></p><p>只要我们在getage()后面加上const就不会再报这样的错误了。</p><h1 id="传值VS传引用"><a href="#传值VS传引用" class="headerlink" title="传值VS传引用"></a>传值VS传引用</h1><p>C++的函数参数传递方式，可以是传值方式，也可以是传引用方式。传值的本质是：形参是实参的一份复制。传引用的本质是：将我们要传的值所在的地址传输过去。</p><p>当我们要传递一个很大的参数的时候，显然我们先复制再赋值最后再销毁的操作会浪费很多性能，这个时候传递引用显然更为合适。因为传递引用一次只是传输了四个字节。所以我们建议传递参数和返回一个参数的时候，我们多传引用，而不是传值。如果我们是追求速度，不希望我们传递的值被改变，我们可以为引用加上const加以约束。</p><h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><p>在类的声明部分还有一个特殊的关键字值得我们关注，那就是friend，朋友，我们看这个函数直观的感觉它想表达的意思这个函数是这个类的friend，那么C++中的friend可以做什么呢？C++中的friend翻译过来叫做友元，被标记为友元的函数可以直接获取类中的属性。但这样做就打破了我们封装的原则，所以我们在写外部函数访问成员属性的时候，还是尽量的使用类内函数获取。</p><h1 id="相同class的各个objects互为友元"><a href="#相同class的各个objects互为友元" class="headerlink" title="相同class的各个objects互为友元"></a>相同class的各个objects互为友元</h1><p>我们修改之前的代码来解释这一块的内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> v):<span class="built_in">age</span>(v) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addage</span><span class="params">(A &amp;b)</span> </span>&#123; <span class="keyword">return</span> b.age + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">cout&lt;&lt;a.<span class="built_in">addage</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看结果：</p><p><img src="2.jpg" alt="相同class的各个objects互为友元"></p><p>我们可以看到现在类A中有一个addage函数，它接收一个A类对象，并把接收到的对象的age+1返回，可能听起来很正常，但仔细想想我们之前说一个对象的私有属性是不可以被外部随意获取的，那为什么addage函数中可以直接写b.age+1呢？这不符合我们所说的封装啊，这时候就要使用到这一块内容的标题了相同class的各个objects互为友元。也就是说一个类产生出的对象们，都是友元的，也就是大家都是同源的，不存在什么隔阂。</p><h1 id="关于返回引用或者返回值的取舍"><a href="#关于返回引用或者返回值的取舍" class="headerlink" title="关于返回引用或者返回值的取舍"></a>关于返回引用或者返回值的取舍</h1><p>当一个函数中需要使用一个新的变量去存储我们函数的结果的时候，我们一般选择返回值。我们在函数中创建的变量，如果我们返回了它的引用可能会造成程序的错误，我们来看这样一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">RetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=======&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; i = <span class="built_in">RetInt</span>();</span><br><span class="line">    cout &lt;&lt; i&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//split();</span></span><br><span class="line">    cout &lt;&lt; i&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码中RetInt函数返回了i的引用但i是一个局部变量，这个操作是十分危险的，我们来看一下结果：</p><p><img src="3.jpg" alt="返回局部变量的引用1"></p><p>看起来并没有很危险，i的值还是那个值，i的地址还是那个地址看起来没什么不妥，但是如果我们取消注释main函数中的split函数会发生什么呢？我们再看一下结果：</p><p><img src="4.jpg" alt="返回局部变量的引用2"></p><p>i的地址没有发生改变，但是i的值却变得很糟糕，这是为什么？这里要先理解函数调用的过程，我们说调用一个函数要先将函数压入栈中，然后待函数执行完成后弹栈，但这里要注意的是不要把弹栈想象成将函数从栈中移出，弹栈的意思只是栈顶指针向下移动而已，函数还是在栈中，还是那个地址。所以我们在没有另外压入别的函数前，我们都可以正常的访问到局部变量的引用，但是一旦我们重新压入了一个函数，那么我们后压入的函数将覆盖我们原先的函数，这样原先函数里的局部变量将消失，这样我们就没有办法访问到了。所以不要返回一个局部变量的引用，指针同理。</p><h1 id="运算符重载和this指针"><a href="#运算符重载和this指针" class="headerlink" title="运算符重载和this指针"></a>运算符重载和this指针</h1><p>我们可以将两个int相加，当两个数据类型可以转换的时候，我们也可以让它们相加，但如果我们让两个对象相加呢？我们可以写一个行为，它的参数列表是另一个对象，这样当我调用这个行为的时候就可以实现两个对象的相加，但这太麻烦了我们为什么不能用+将两个对象加在一起呢？接下来我们就来看看类声明部分的另一个新鲜事物operate运算符重载，以及它用到的this指针。在C++中我们可以使用operate进行运算符重载，我们赋予这个运算符新的功能，比如下面这些代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> v):<span class="built_in">age</span>(v) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> + (A &amp;b) &#123; <span class="keyword">this</span>-&gt;age += b.age; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">a + b;</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">getage</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下它的结果：</p><p><img src="5.jpg" alt="运算符重载和this指针"></p><p>当我们使用a+b的时候，编译器根据我们的参数类型调用了我们重载之后的+，执行重载+里面的操作，这里有一个新的关键字this，this是一个指针，它指向了当前这个对象本身，我们调用的语句是a+b，那么此时this指向的就是a。所以我们执行的操作就是将a的age加上b的age赋给a的age。所以我们得到了结果17。</p><h1 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h1><p>现在我们思考这样的一个问题，我们现在有三个A类数据，我们要将它们三个加在一起，我们要怎么做呢？可能有的小伙伴认为我们可以直接a+b+c，我们来看一下这样子可以不可以：</p><p><img src="6.jpg" alt="链式编程1"></p><p>看来是不可以的，因为我们重载的+运算符没有返回任何东西，我们不能将一个空的东西和类相加，所以我们需要修改重载+运算符的返回值才可以，我们来看优化后的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> v):<span class="built_in">age</span>(v) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span> + (A&amp; another)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += another.age;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="function">A <span class="title">c</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">a + b + c;</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">getage</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="7.jpg" alt="链式编程2"></p><p>我们得到了正确的结果，这样返回一个对象加入下一次运算的方法我们叫做链式编程，像一个链条一样。运算符重载符合基本的运算规律。</p><h1 id="属于全局函数的运算符重载"><a href="#属于全局函数的运算符重载" class="headerlink" title="属于全局函数的运算符重载"></a>属于全局函数的运算符重载</h1><p>我们知道+是一个双目运算符，它需要两个参数，但是在类中我们本身就是其中一个参数，所以我们的参数列表只有一个值，现在我们将重载运算符搬到类外，变成一个全局函数，这个时候我们的参数列表就应该是两个参数了，我们来看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> v=<span class="number">1</span>):<span class="built_in">age</span>(v) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">A <span class="keyword">operator</span> + (A&amp; one,A&amp; another)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">A</span>(one.<span class="built_in">getage</span>() + another.<span class="built_in">getage</span>());</span><br><span class="line">&#125;</span><br><span class="line">A <span class="keyword">operator</span> + (A&amp; one, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">A</span>(one.<span class="built_in">getage</span>() + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a,b,c,d;</span><br><span class="line">c = a + b;</span><br><span class="line">cout &lt;&lt; c.<span class="built_in">getage</span>() &lt;&lt; endl;</span><br><span class="line">c = a + <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; c.<span class="built_in">getage</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在重载+中使用了一种语法，classname()，这样我们就创建了一个临时的对象，并用两个对象相加得到的值初始化了它，把它返回回来，这里要注意的是我们不是重载+=符号，我们没有空间去存放两个对象相加的值所以只能创建一个新的对象，将它返回回来，这就意味着我们不能返回引用，同时也意味着如果我们希望实现链式编程，那我们的参数列表中要求的参数也要是以值传递的。最后运算符可以发生多次重载，和函数重载相同，要求的是重载同一运算符，但参数列表中参数顺序，参数类型，参数个数(重载加号和正号的区别)至少有一个不同。</p><h1 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h1><p>我们如果需要输出一个类的时候我们可以通过使用类提供的接口来输出，但是如果这个类的属性有很多那我们就要一条一条的输出，很麻烦，所以我们可以重载输出运算符&lt;&lt;来解决这个问题。我们直接看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> v = <span class="number">18</span>, string n = <span class="string">&quot;xiaoming&quot;</span>) :<span class="built_in">age</span>(v),<span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line"><span class="function">string <span class="title">getname</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os,A&amp; another)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> os&lt;&lt; another.<span class="built_in">getname</span>() &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; another.<span class="built_in">getage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意几件事，第一件事是重载&lt;&lt;运算符不能写成一个成员函数，想象一下如果&lt;&lt;成为了成员函数，当我们调用的时候应该是classexample1&lt;&lt;classexample2，这显然不符合我们的预期，我们要的效果是cout&lt;&lt;classexample。所以不可以将重载&lt;&lt;运算符写成一个成员函数，我们要将cout置于&lt;&lt;的左边，所以我们的第一个参数应该是和cout同一类型的，我们查阅资料得知cout的类型为ostream，所以为了实现链式编程，我们返回的类型也是一个ostream类型的引用。</p><p>我们来看一下程序运行的结果：</p><p><img src="8.jpg" alt="链式编程2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;欢迎，各位来到C++面向对象编程的学习，相信各位已经学习过C语言，已经进入到了程序的世界，本课程要求一些c++的基础知识，比如控制流程，循环</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十七）</title>
    <link href="http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <id>http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/</id>
    <published>2022-09-23T07:05:15.000Z</published>
    <updated>2022-10-03T11:44:09.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="int-9中断例程对键盘输入的处理"><a href="#int-9中断例程对键盘输入的处理" class="headerlink" title="int 9中断例程对键盘输入的处理"></a>int 9中断例程对键盘输入的处理</h1><p>大多数有用的程序都需要处理用户的输入，键盘的输入是最为基本的输入。程序和数据通常需要长期存储，磁盘是最常用的存储设备。BIOS为这两种外设的I/O提供了最基本的中断例程，接下来我们就对它们的应用和相关的问题进行讨论。</p><p>我们之间已经学习过，键盘的输入将引发9号中断，BIOS提供了int 9中断例程。CPU在9号中断发生后，执行int 9中断例程，从60H端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。</p><p>一般的键盘输入，在CPU执行完int 9中断例程后，都放到了键盘缓冲区中，键盘缓冲区有16个字单元，可以储存15个按键的扫描码和对应的ASCII码，接下来我们就从逻辑层面看一下键盘输入的扫描码和对应的ASCII码是如何写入键盘缓冲区的。事实上，键盘缓冲区是用环形队列结构管理的内存区。</p><p>下面想象这样一个场景，我们按下了键盘上的A，B，C，D，E，Shift_A，A。我们来简要的看一下int 9中断例程都做了什么叭！</p><p>1.初始状态下，没有键盘输入，键盘缓冲区空，此时没有任何元素。</p><p><img src="1.jpg" alt="键盘缓冲区内容"></p><p>2.按下A键，引发了键盘中断，CPU执行int 9中断例程，从60H端口读出A键的通码；然后检测状态字节，看看是否有Shift，Ctrl等切换键按下；发现没有切换键按下，就将A键的扫描码1eH和对应的ASCII码，即字母“a”的ASCII码61H，写入键盘缓冲区。缓冲区的字单元中，高位字节存储扫描码，低位字节存储ASCII码。此时缓冲区内容如下。</p><p><img src="2.jpg" alt="键盘缓冲区内容"></p><p>3.按下B键，引发了键盘中断，CPU执行int 9中断例程，从60H端口读出B键的通码；然后检测状态字节，看看是否有切换键按下；发现没有切换键按下，就将B键的扫描码30H和对应的ASCII码，即字母“b”的ASCII码62H，写入键盘缓冲区,此时缓冲区内容如下。</p><p><img src="3.jpg" alt="键盘缓冲区内容"></p><p>4.按下C，D，E键后，缓冲区中的内容如下。</p><p><img src="4.jpg" alt="键盘缓冲区内容"></p><p>5.按下左Shift键，引发键盘中断；int 9中断例程接收左Shift的通码，设置0040:17处的状态字节的第1位为1，表示左Shift按下。</p><p>6.按下A键，引发了键盘中断，CPU执行int 9中断例程，从60H端口读出A键的通码；然后检测状态字节，看看是否切换键按下；发现左Shift被按下，就将A键的扫描码1eH和Shift_A对应的ASCII码，即字母“A”的ASCII码41H，写入键盘缓冲区。此时缓冲区内容如下。</p><p><img src="5.jpg" alt="键盘缓冲区内容"></p><p>7.松开左Shift键，引发键盘中断；int 9中断例程接收左Shift的断码，设置0040:17处的状态字节的第1位为0，表示左Shift松开。</p><p>8.按下A键，引发了键盘中断，CPU执行int 9中断例程，从60H端口读出A键的通码；然后检测状态字节，看看是否切换键按下；发现没有切换键按下，就将A键的扫描码1eH和对应的ASCII码，即字母“a”的ASCII码61H，写入键盘缓冲区。缓冲区的字单元中，高位字节存储扫描码，低位字节存储ASCII码。此时缓冲区内容如下。</p><p><img src="6.jpg" alt="键盘缓冲区内容"></p><h1 id="使用int-16H中断例程读取键盘缓冲区"><a href="#使用int-16H中断例程读取键盘缓冲区" class="headerlink" title="使用int 16H中断例程读取键盘缓冲区"></a>使用int 16H中断例程读取键盘缓冲区</h1><p>BIOS提供了int 16H中断例程供程序员调用。int 16H中断例程中包含的一个最重要的功能是从键盘缓冲区读取一个键盘输入，该功能编号为0。下面的指令从键盘缓冲区读取一个键盘输入，并且将其从缓冲区中删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ah,0</span><br><span class="line">int 16H</span><br></pre></td></tr></table></figure><p>结果是(ah)=扫描码，(al)=ASCII码。接下来我们看一下int16H如何读取键盘缓冲区。</p><p>1.执行上述两条指令后，缓冲区中的内容如下：</p><p><img src="7.jpg" alt="键盘缓冲区内容"></p><p>2.再次执行，缓冲区中内容如下：</p><p><img src="8.jpg" alt="键盘缓冲区内容"></p><p>3.连续执行5次后，缓冲区为空：</p><p><img src="1.jpg" alt="键盘缓冲区内容"></p><p>4.再次执行，int 16H检测到键盘缓冲区，发现缓冲区为空，则循环等待，直到缓冲区中有数据。</p><p>5.按下A键后，缓冲区中的内容如下：</p><p><img src="9.jpg" alt="键盘缓冲区内容"></p><p>6.循环等待的int 16H中断例程检测到键盘缓冲区中有数据，将其读出，缓冲区又为空。</p><p><img src="1.jpg" alt="键盘缓冲区内容"></p><p>ah中内容为1EH，al中内容为61H</p><p>从上面我们可以看出，int 16中断例程的0号功能，进行如下的工作：</p><ol><li>检测键盘缓冲区中是否有数据</li><li>没有则继续做第一步</li><li>读取缓冲区第一个字单元中的键盘输入</li><li>将读取的扫描码送入ah，ASCII码送入al</li><li>将已读取的键盘输入从缓冲区中删除</li></ol><p>可见，BIOS的int 9中断例程和int 16H中断例程是一对相互配合的程序，int 9中断例程向键盘缓冲区中写入，int 16H中断例程从缓冲区中读出。它们写入和读出的时机不同，int 9中断例程是在有键按下的时候向键盘缓冲区中写入数据；而int 16H中断例程是在应用程序对其调用的时候，将数据从键盘缓冲区中读出。我们在编写一般的处理键盘输入的程序的时候，可以调用int 16H从键盘缓冲区中读取键盘的输入。</p><h1 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h1><p>用户通过键盘输入的通常不仅仅是单个字符而是字符串。最基本的字符串输入程序，需要具备下面的功能：</p><ol><li>在输入的同时需要显示这个字符串</li><li>一般在输入回车符后，字符串输入结束</li><li>能够删除已经输入的字符</li></ol><p>接下来我们试着编写一个接收字符串输入的子程序，实现上面3个基本功能。因为在输入的过程中需要显示，子程序的参数如下：</p><p>(dh)、(dl)=字符串在屏幕上显示的行、列位置；ds:si指向字符串的存储空间，字符串以0为结尾符。</p><p>首先，我们要先解决字符的输入和删除，每个新输入的字符都存储在前一个输入的字符之后，而删除是从最后面的字符进行的，这一点可以想象我们平时输入输出的场景。可以知道字符的输入和输出是按照栈的访问规则进行的，即后进先出。这样，我们就可以用栈的方式来管理字符串的存储空间，也就是说字符串的存储空间实际上是一个字符栈。字符栈中的所有字符，从栈底到栈顶，组成一个字符串。第二，我们要在输入回车符后，结束这个字符串，这个很好实现，我们可以在输入回车符后在字符串中加入0，表示字符串结束。最后，我们在输入字符串的同时要显示这个字符串，也就是每次有新的字符输入和删除一个字符的时候，都应该重新显示字符串，即从字符栈的栈底到栈顶，显示所有的字符。</p><p>现在我们可以简单地确定程序的处理过程：</p><ol><li>调用int 16H读取键盘输入</li><li>如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行1</li><li>如果是退格键，就从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行1</li><li>如果是enter键，向字符栈中压入0，返回</li></ol><p>可见整个过程中，字符出栈，入栈，显示的操作很频繁，应该写成子程序。完整的接收字符串输入的子程序，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">getstr:push ax</span><br><span class="line">getstrs:mov ah,0</span><br><span class="line">int 16H</span><br><span class="line">cmp al,20H</span><br><span class="line">jb nochar</span><br><span class="line">mov ah,0</span><br><span class="line">call charstack</span><br><span class="line">jmp getstrs</span><br><span class="line">nochar:cmp ah,0eH</span><br><span class="line">je backspace</span><br><span class="line">cmp ah,1cH</span><br><span class="line">je enther</span><br><span class="line">jmp getstrs</span><br><span class="line">backspace:mov ah,1</span><br><span class="line">call charstack</span><br><span class="line">jmp getstrs</span><br><span class="line">enter:mov al,0</span><br><span class="line">mov ah,0</span><br><span class="line">call charstack</span><br><span class="line">mov ah,2</span><br><span class="line">call charstack</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line">charstack:jmp short charstart</span><br><span class="line">table dw charpush,charpop,charshow</span><br><span class="line">top dw 0</span><br><span class="line">charstart:push bx</span><br><span class="line">push dx</span><br><span class="line">push di</span><br><span class="line">push es</span><br><span class="line">cmp ah,2</span><br><span class="line">ja sret</span><br><span class="line">mov bl,ah</span><br><span class="line">mov bh,0</span><br><span class="line">add bx,bx</span><br><span class="line">jmp word ptr table[bx]</span><br><span class="line">charpush:mov bx,top</span><br><span class="line">mov [si][bx],al</span><br><span class="line">inc top</span><br><span class="line">jmp sret</span><br><span class="line">charpop:cmp top,0</span><br><span class="line">je sret</span><br><span class="line">dec top</span><br><span class="line">mov bx,top</span><br><span class="line">mov al,[si][bx]</span><br><span class="line">jmp sret</span><br><span class="line">charshow:mov bx,0b800H</span><br><span class="line">mov es,bx</span><br><span class="line">mov al,160</span><br><span class="line">mov ah,0</span><br><span class="line">mul dh</span><br><span class="line">mov di,ax</span><br><span class="line">add dl,dl</span><br><span class="line">mov dh,0</span><br><span class="line">add di,dx</span><br><span class="line">mov bx,0</span><br><span class="line">charshows:cmp bx,top</span><br><span class="line">jne noempty</span><br><span class="line">mov byte ptr es:[di],&#x27; &#x27;</span><br><span class="line">jmp sret</span><br><span class="line">noempty:mov al,[si][bx]</span><br><span class="line">mov es:[di],al</span><br><span class="line">mov byte ptr es:[di+2],&#x27; &#x27;</span><br><span class="line">inc bx</span><br><span class="line">add di,2</span><br><span class="line">jmp charshows</span><br><span class="line">sret:pop es</span><br><span class="line">pop di</span><br><span class="line">pop dx</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h1 id="应用int-13H中断例程对磁盘进行读写"><a href="#应用int-13H中断例程对磁盘进行读写" class="headerlink" title="应用int 13H中断例程对磁盘进行读写"></a>应用int 13H中断例程对磁盘进行读写</h1><p>我们主要以3.5英寸软盘为例，3.5英寸软盘分为上下两面，每面80个磁道，每个磁道又分为18个扇面，每个扇面区的大小为512字节。所以3.5英寸软盘大约是1.44MB。磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘，只能以扇区为单位对磁盘进行读写。在读写扇区的时候，要给出面号，磁道号和扇区号。面号和磁盘号从0开始，而扇区号从1开始。BIOS提供了一些中断例程可以访问磁盘，比如int 13H。如果我们想读取0面0道1扇区的内容到0:200，那么程序是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200H</span><br><span class="line">mov al,1</span><br><span class="line">mov ch,0</span><br><span class="line">mov cl,1</span><br><span class="line">mov dl,0</span><br><span class="line">mov dh,0</span><br><span class="line">mov ah,2</span><br><span class="line">int 13H</span><br></pre></td></tr></table></figure><p>其中，(ah)表示int 13H的功能号，(al)表示读取的扇区数，(ch)表示磁道号，(cl)表示扇区号，(dh)表示磁头号(对于软盘即面号，因为一个面用一个磁头来读写)，(dl)表示驱动器号软驱从0开始，0：软驱A，1：软驱B，硬盘从80H开始，80H：硬盘C，81H：硬盘D。如果操作成功(ah)=0，(al)=读入的扇区数，如果操作失败(ah)=出错代码。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此，汇编的学习告一段落，感谢各位能耐心阅读！更新完整个系列后有一种如释重负的感觉，好像完成了一件大事一样，虽然只是学完了一本书。博主也只是一个在校大学生，刚刚开始写博客，所有内容都是一点点看书，选择性记录的，虽然看起来还是有点像搬运，而且很古板粗糙。。。不过至少整个过程还是有收获滴！接下来，博主也会慢慢的写一写其他的系列，最后再次感谢，可以耐心看本系列的朋友们，我们下个系列见！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十六）</title>
    <link href="http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <id>http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/</id>
    <published>2022-09-23T07:04:03.000Z</published>
    <updated>2022-10-02T12:20:03.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="描述了单元长度的标号"><a href="#描述了单元长度的标号" class="headerlink" title="描述了单元长度的标号"></a>描述了单元长度的标号</h1><p>我们之前，一直在代码段中使用标号来标记指令、数据、段的起始地址。比如，下面的代码将code段中的a标号处的8个数据累加，结果储存到b标号处的字中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">a: db 1,2,3,4,5,6,7,8</span><br><span class="line">b: dw 0</span><br><span class="line">start:mov si,offset a</span><br><span class="line">mov bx,offset b</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov al,cs:[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add cs:[bx],ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>程序中，code、a、b、start、s都是标号。这些标号仅仅表示了内存单元的地址。我们还可以使用另一种符号，这种符号不仅可以表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。上面程序还可以写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">start:mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov al,a[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add b,ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>在code段中使用的标号a、b后面没有”:”，它们是同时描述内存单元长度和内存地址的标号。标号a，描述了地址code:0，和从这个地址开始，以后的内存单元都是字节单元；而标号b描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元。</p><p>因为这种标号包含了对单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。比如，对于程序中的”b dw 0”：</p><p>指令：mov ax,b 相当于：mov ax,cs:[8]</p><p>指令中，标号b代表了一个内存单元，地址为code:8，长度为两个字节。如果使用指令mov al,b就会引起编译错误，因为b代表的内存单元是字单元。我们称这种标号为数据标号，它标记了存储数据的单元的地址和长度。</p><h1 id="在其他段中使用数据标号"><a href="#在其他段中使用数据标号" class="headerlink" title="在其他段中使用数据标号"></a>在其他段中使用数据标号</h1><p>一般来说，我们不会在代码段里面定义数据，而是将数据定义到其他段中，在其他段中我们也可以使用数据标号来描述存储数据的单元的地址和长度。不过需要注意的是在后面加有“：”的地址标号，只能在代码段中使用，不能在其他段中使用。下面的程序将data段中a标号处的8个数据累加，结果存储到b标号处的字中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov al,a[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add b,ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mob ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>之前我们说将我们定义的段和相关的寄存器使用伪指令assume联系起来，比如上面的程序中我们就讲cs和code段，ds和data段联系在了一起。之所以这样做是因为我们后来在代码段中使用了数据标号，也就是说当我们将数据定义到其他段中后，想要在代码段使用数据标号就必须使用伪指令assume将段和段寄存器联系起来，否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中，当然这种联系是编译器需要的，但绝对不是说，我们因为编译器的工作需要，用assume指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。所以我们为了程序可以正确访问data段，我们会在代码段的开始使用指令，设置ds指向data段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure><p>我们可以将标号当做数据来定义，此时，编译器将标号所表示的地址当作数据的值，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>数据标号c处存储的两个字型数据为标号a、b的偏移地址相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw offset a,offset b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dd a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>数据标号c处存储的两个双字型数据为标号a、b的偏移地址和段地址相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw offset a,seg a,offset b,seg b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>seg操作符功能为获取某一个标号的段地址。</p><h1 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h1><p>接下来我们通过一个问题引入这个小节的学习，我们现在要编写一个子程序，以十六进制的形式在屏幕中间显示给定的字节型数据。首先一个字节需要两个十六进制数来表示，那我们可以将一个字节的高四位和低四位分开，分别用它们的值得到对应的数码字符。比如2BH，我们可以得到高四位的2和低四位的11，但我们怎么能得到对应的数码字符呢？</p><p>最简单的方法就是一个一个比较，0就是0,1就是1……10就是A,11就是B，但这样有太麻烦了，有太多的比较指令和转移指令了。我们要在0-15和0-F之间找到一种映射关系。</p><p>0-9和字符“0”-“9“的关系显而易见：数值+30H=对应字符的ASCII值，同样我们也可以知道10-15和”A“-”F“之间的对应关系：数值+37H=对应字符的ASCII值。现在我们就可以将数值转换为字符了，因为映射关系存在差异，我们要判断数值是否大于9。</p><p>虽然已经简化很多了，但人嘛，总是追求最简单，最省力的办法，因为0-15和字符“0”-“F”之间没有一致的映射关系存在，所以我们应该在它们之间建立新的映射关系。具体做法是建立一张表，表中依次存放字符“0”-“F”,我们可以通过数值0-15直接查找到对应的字符。子程序如下，其中使用al传送要显示的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">showbyte:jmp short show</span><br><span class="line">table db &#x27;0123456789ABCDEF&#x27;</span><br><span class="line">show:push bx</span><br><span class="line">push es</span><br><span class="line">mov ah,al</span><br><span class="line">shr ah,1</span><br><span class="line">shr ah,1</span><br><span class="line">shr ah,1</span><br><span class="line">shr ah,1;右移4位，ah中得到高四位的值</span><br><span class="line">and ah,00001111b;al中为低四位的值</span><br><span class="line">mov bl,ah</span><br><span class="line">mov bh,0</span><br><span class="line">mov ah,table[bx];用高四位的值作为相对于table的偏移，取得对应的字符</span><br><span class="line">mov bx,0B800H</span><br><span class="line">mov es,bx</span><br><span class="line">mov es:[160*12+40*2],ah</span><br><span class="line">mov bl,al</span><br><span class="line">mov bh,0</span><br><span class="line">mov al,table[bx];用低四位的值作为相对于table的偏移，取得对应的字符</span><br><span class="line">mov es:[160*12+40*2+2],al</span><br><span class="line">pop es</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>可以看到我们在子程序中，使用了一个表建立了两个集合之间的关系，这样做的目的一般有以下三个：</p><ol><li>为了算法的清晰和简洁</li><li>为了加快运算速度</li><li>为了使程序易于扩充</li></ol><p>我们的程序通过给出的数据进行比较而得到的结果的问题，转化为用给出的数据作为查表的依据，通过查表得到结果的问题。具体的查表方法，是用查表的依据数据，直接计算出所要查找的元素在表中的位置。像这种可以通过依据数据，直接计算出所要找的元素的位置的表，我们称其为直接定址表。</p><h1 id="程序入口地址的直接定址表"><a href="#程序入口地址的直接定址表" class="headerlink" title="程序入口地址的直接定址表"></a>程序入口地址的直接定址表</h1><p>我们可以在直接定址表中存储子程序的地址，从而方便地实现不同子程序的调用。假设我们现在有四个子程序a，b，c，d，我们可以将这四个子程序的入口地址存储到一个表中，它们在表中的位置和功能号相对应。对应关系为：功能号*2=对应功能子程序在地址表中的偏移。程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setscreen:jmp short set</span><br><span class="line">table dw a,b,c,d</span><br><span class="line">set:push bx</span><br><span class="line">cmp ah,3</span><br><span class="line">ja sret</span><br><span class="line">mov bl,ah</span><br><span class="line">mov bh,0</span><br><span class="line">add bx,bx</span><br><span class="line">call word ptr table[bx]</span><br><span class="line">sret:pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>我们通过使用直接定址表，根据功能号调用对应子程序的做法，使程序结构清晰，便于扩充，如果我们未来想要加入一个新的功能只需要在地址表中加入它的入口地址就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十五）</title>
    <link href="http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://example.com/2022/09/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/</id>
    <published>2022-09-23T07:03:55.000Z</published>
    <updated>2022-10-02T08:50:41.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h1><p>我们知道CPU不仅仅只有运算功能，它还有I/O（Input/Output，输入/输出）能力，比如我们打开文本编辑器，按一下键盘，然后我们就可以看到屏幕出现了我们按下的按键，是CPU将从键盘上的键所对应的字符送到显示器上的。要及时处理外设的输入，显然需要解决两个问题：</p><ol><li>外设的输入可能随时发生，CPU怎么知道呢？</li><li>CPU从何处得到外设的输入？</li></ol><p>这一篇我们就以键盘输入为例，讨论这两个问题。</p><h1 id="接口芯片和端口"><a href="#接口芯片和端口" class="headerlink" title="接口芯片和端口"></a>接口芯片和端口</h1><p>第14篇我们讲过，PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片内部有若干个寄存器，CPU将这些寄存器当做端口来访问。外设的输入不直接进入内存和CPU而是先进入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。CPU还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。可见，CPU通过端口和外部设备进行联系。</p><h1 id="外中断信息"><a href="#外中断信息" class="headerlink" title="外中断信息"></a>外中断信息</h1><p>我们知道外设的输入被放到了端口里，那CPU如何及时的知道并处理呢？CPU提供中断机制来满足这种需求，前面说过，CPU内部有需要处理的事情发生的时候，将产生中断信息，引发中断过程。中断信息来自CPU内部。还有一种中断信息，来自于CPU外部，当CPU外部有需要处理的事情发生时，比如说外设的输入到达。这个时候相关芯片会向CPU发出相应的中断信息。CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。在PC系统中，外中断源一共分为一下两种。</p><h2 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h2><p>可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。当CPU检测到可屏蔽中断信息时，如果IF=1，则CPU在执行完当前指令后响应中断，引发中断过程，如果IF=0,则不响应可屏蔽中断。</p><p>我们来回忆一下内中断所引发的中断过程：</p><ol><li>取中断类型码N</li><li>标志寄存器入栈，IF=0，TF=0</li><li>CS、IP入栈</li><li>(IP)=(n×4)，(CS)=(n×4+2)</li></ol><p>由此转去执行中断处理程序。</p><p>可屏蔽中断所引发的中断过程，除在第1步的是实现上有所不同外，基本上和内中断一样。因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；而内中断的中断类型码是在CPU内部生成的。</p><p>现在我们就可以解释为什么中断过程中要设置IF为0了，因为在进入中断处理程序之后，禁止其他的可屏蔽中断。当然，如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置为1。8086CPU提供了两条指令设置IF分别是：</p><ol><li>sti，设置IF=1</li><li>cli，设置IF=0</li></ol><h2 id="不可屏蔽中断"><a href="#不可屏蔽中断" class="headerlink" title="不可屏蔽中断"></a>不可屏蔽中断</h2><p>不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前的指令后，立即响应，引发中断过程。对于8086CPU，不可屏蔽中断的中断过程类型码固定为2，所以中段过程中，不需要取中断类型码。所以不可屏蔽中断的中断过程为：</p><ol><li>标志寄存器入栈，IF=0，TF=0</li><li>CS、IP入栈</li><li>(IP)=(8)，CS=(0AH)</li></ol><p>几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件（比如说键盘输入）发生时，相关芯片向CPU发出可屏蔽中断信息。不可屏蔽中断是在系统中有必须处理的紧急情况发生时来通知CPU的中断信息。我们主要讨论可屏蔽信息。</p><h1 id="PC机键盘的处理过程"><a href="#PC机键盘的处理过程" class="headerlink" title="PC机键盘的处理过程"></a>PC机键盘的处理过程</h1><p>我们接下来看一下键盘输入的处理过程，并以此来体会一下PC机处理外设输入的基本方法。</p><h2 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h2><p>键盘上的每一个键就相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60H。当我们松开这个键的时候，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也会被送到端口60H中。</p><p>一般来说将按下一个键时产生的扫描码叫做通码，松开一个键时产生的扫描码叫做断码，扫描码的长度为一个字节，通码的第7位为0，断码的第7位为1，即断码=通码+80H。</p><h2 id="引发9号中断"><a href="#引发9号中断" class="headerlink" title="引发9号中断"></a>引发9号中断</h2><p>当键盘的输入到达60H端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。CPU检测到该中断信息后，如果IF=1，则响应中断，引发中断过程，转去执行int 9中断例程。</p><h2 id="执行int-9中断例程"><a href="#执行int-9中断例程" class="headerlink" title="执行int 9中断例程"></a>执行int 9中断例程</h2><p>BIOS提供了int 9中断例程，用来进行基本的键盘输入处理，主要工作如下：</p><ol><li>读出60H端口中的扫描码</li><li>如果是字符键的扫描码，将该扫描码和它所对应的字符码，也就是ASCII码送入内存中的BIOS键盘缓冲区；如果是控制键(比如Ctrl)和切换键(比如CapsLock)的扫描码，则将其转变为状态字节(用二进制位记录控制键和切换键状态的字节)写入内存中储存状态字节的单元。</li><li>对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。</li></ol><p>BIOS键盘缓冲区是系统启动后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区。该内存区可以储存15个键盘输入，因为int 9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，低位字节存放字符码。0040:17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下：</p><p><img src="1.jpg" alt="键盘状态字节各位记录的信息"> </p><h1 id="安装新的int-9中断例程"><a href="#安装新的int-9中断例程" class="headerlink" title="安装新的int 9中断例程"></a>安装新的int 9中断例程</h1><p>接下来我们要安装一个新的int 9中断例程，使原来的int 9中断例程功能得到扩展。我们的任务是在DOS下，按F1键后改变当前屏幕的显示颜色，其他键照常处理。首先我们分别思考几个问题：</p><p>1.改变屏幕的显示颜色</p><p>改变从B800H开始的4000个字节中的所有奇地址单元中的内容，当前屏幕的显示颜色即发生改变。程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0B800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,1</span><br><span class="line">mov cx,2000</span><br><span class="line">s:inc byte ptr es:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>2.其他键照常处理</p><p>可以调用原int 9中断处理程序，来处理其他的键盘输入</p><p>3.原int 9中断例程入口地址的保存</p><p>因为在编写新的int 9中断例程中要调用原int 9中断例程，所以，要保存原int 9中断例程的入口地址。要保存在哪里？显然不能保存在安装程序中，因为安装程序返回后地址将丢失。我们将地址保存在0:200单元处。</p><p>4.新int 9中断例程的安装</p><p>我们可以将新的int 9中断例程安装在0:204处。</p><p>完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,128</span><br><span class="line">push cs</span><br><span class="line">pop ds</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,offset int9;设置ds:si指向源地址</span><br><span class="line">mov di,204H;设置es:di指向目的地址</span><br><span class="line">mov cx,offset int9end-offset int9;设置cx为传输长度</span><br><span class="line">cld;设置传输方向为正</span><br><span class="line">rep movsb</span><br><span class="line">push es:[9*4]</span><br><span class="line">pop es:[200H]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop es:[202H]</span><br><span class="line">cli</span><br><span class="line">mov word ptr es:[9*4],204H</span><br><span class="line">mov word ptr es:[9*4],0H</span><br><span class="line">sti</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">int9:push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">in al,60H</span><br><span class="line">pushf</span><br><span class="line">call dword ptr cs:[200H]</span><br><span class="line">cmp al,3bH</span><br><span class="line">jne int9ret</span><br><span class="line">mov ax,0b800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,1</span><br><span class="line">mov cx,2000</span><br><span class="line">s:inc byte ptr es:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">int9ret:pop es</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line">int9end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这一篇我们通过对键盘输入的处理，讲解了CPU对外设输入的通常处理方法。即：</p><ol><li>外设的输入送入端口</li><li>向CPU发出外中断(可屏蔽中断)信息</li><li>CPU检测到可屏蔽中断信息，如果IF=1，CPU在执行完当前指令后响应中断，执行响应的中断处理程序</li><li>可在中断例程中实现对外设输入的处理</li></ol><p>端口和中断机制，是CPU进行I/O的基础。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十四）</title>
    <link href="http://example.com/2022/09/22/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://example.com/2022/09/22/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/</id>
    <published>2022-09-22T15:26:07.000Z</published>
    <updated>2022-09-23T07:01:38.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>我们前面讲过，各种存储器都和CPU的地址线、数据线、控制线相连。CPU在操控它们的时候，把它们都当作内存来看待，把它们总地看做一个由若干存储单元组成的逻辑存储器，这个逻辑存储器我们称其为内存地址空间。</p><p>在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有一下三种芯片：</p><ol><li>各种接口卡上的接口芯片，它们控制接口卡进行工作</li><li>主板上的接口芯片，CPU通过它们对部分外设尽心访问</li><li>其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。</li></ol><p>这些芯片都有一组可以由CPU读写的寄存器。这些寄存器，它们在物理上可能处于不同的芯片中，但是它们在以下两点上相同：</p><ol><li>都和CPU的总线相连，当然这种连接是通过它们所在的芯片进行的</li><li>CPU对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令。</li></ol><p>可见，从CPU的角度，将这些寄存器都当作端口，对它们统一编址，从而建立了一个统一的端口地址空间。每一个端口都在地址空间中有一个地址。</p><p>CPU可以从以下三个地方直接读写数据：</p><ol><li>CPU内部的寄存器</li><li>内存单元</li><li>端口</li></ol><p>这篇我们就讨论一下端口的读写。</p><h1 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h1><p>在访问端口的时候，CPU通过端口地址定位端口。因为端口所在的芯片和CPU通过地址总线相连，所以，端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口。则端口地址的范围为0~65535。</p><p>对于端口的读写就不能使用mov、push、pop等内存读写指令了，端口的读写指令只有两条：in和out，分别对应从端口读取数据和向端口写入数据。</p><p>我们看一下CPU执行内存访问指令和端口访问指令时，总线上的信息：</p><p>（1）访问内存：</p><p>mov ax,ds:[8]    </p><p>假设执行前(ds)=0，那么执行时与总线相关的操作如下所示：</p><ol><li>CPU通过地址线将地址信息8发出</li><li>CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据</li><li>存储器将8号单元中的数据通过数据线送入CPU</li></ol><p>（2）访问端口：</p><p>in al，60H</p><p>这条指令代表从60H端口读入一个字节，那么执行时与总线相关的操作如下：</p><ol><li>CPU通过地址线将地址信息60H发出</li><li>CPU通过发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据</li><li>端口所在的芯片将60H端口中的数据通过数据线送入CPU</li></ol><p>注意，在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位端口时用ax。</p><p>对0~255以内的端口进行读写时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20H</span><br><span class="line">out 20H,al</span><br></pre></td></tr></table></figure><p>对255~65535以内的端口进行读写时,端口号放在dx中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h;将端口号3f8h送入dx</span><br><span class="line">in al,dx;从3f8h端口读入一个字节</span><br><span class="line">out dx,al;向3f8h端口写入一个字节</span><br></pre></td></tr></table></figure><h1 id="CMOS-RAM芯片"><a href="#CMOS-RAM芯片" class="headerlink" title="CMOS RAM芯片"></a>CMOS RAM芯片</h1><p>下面，我们通过对CMOS RAM芯片的读写体会一下对端口的访问。首先我们介绍一下CMOS RAM芯片，这个芯片其中包含一个实时钟和一个有128个存储单元的RAM存储器（早期的计算机为64个字节）。该芯片靠电池供电。所以，关机后其内部的实时钟仍可以工作，RAM中信息不会丢失。128个字节的RAM中，内部实时钟占用0~0dH来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息。这个芯片内部有两个端口，端口地址为70H和71H。CPU通过这两个端口来读写CMOS RAM。端口70H为地址端口，存放要访问的CMOS RAM单元地址；71H为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。可见，CPU对CMOS RAM的读写分两步进行，比如要读取CMOS RAM的2号单元：</p><ol><li>将2送入端口70H</li><li>从端口71H读出2号单元的内容</li></ol><h1 id="shl和shr指令"><a href="#shl和shr指令" class="headerlink" title="shl和shr指令"></a>shl和shr指令</h1><p>shl是逻辑左移指令，它的功能是：</p><ol><li>将一个寄存器或内存单元中的数据向左移位</li><li>将最后移出的一位写入CF中</li><li>最低位用0补充</li></ol><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000B</span><br><span class="line">shl al,1</span><br></pre></td></tr></table></figure><p>执行后(al)=10010000B，CF=0。注意如果移动的位数大于1时，必须将移动位数放在cl中。CF值只看最后一位被移出的数字，比如移出3位，那么CF的值就看第三位被移出的值是多少就是多少。可以看出将X逻辑左移一位，就相当于执行X=X*2。</p><p>shr是逻辑右移指令，它的功能和shl相反是：</p><ol><li>将一个寄存器或内存单元中的数据向右移位</li><li>将最后移出的一位写入CF中</li><li>最高位用0补充</li></ol><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">shr al,1</span><br></pre></td></tr></table></figure><p>执行后(al)=01000000B，CF=1。同样如果移动的位数大于1时，必须将移动位数放在cl中。可以看出将X逻辑右移一位，就相当于执行X=X/2。</p><h1 id="CMOS-RAM中存储的时间信息"><a href="#CMOS-RAM中存储的时间信息" class="headerlink" title="CMOS RAM中存储的时间信息"></a>CMOS RAM中存储的时间信息</h1><p>在CMOS RAM中，存放着当前的时间：年、月、日、时、分、秒。这6个信息的长度都为1个字节，存放单元为：</p><p>秒：0    分：2    时：4    日：7    月：8    年：9</p><p>这些数据以BCD码的方式存放，BCD码是以4位二进制数表示十进制数码的编码方式，比如，数值26，用BCD码表示就是：0010(2) 0110(6)，可见，一个字节可以表示两个BCD码，高4位表示十位，低4位表示个位。现在我们要做这样的一件事：在屏幕中间显示当前的月份。</p><p>首先，这个程序要先从CMOS RAM的8号单元取出月份的BCD码，那我们要先向端口70H中写入地址信息，然后再端口71H中取出信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,8</span><br><span class="line">out 70H,al</span><br><span class="line">inal,71H</span><br></pre></td></tr></table></figure><p>我们拿到了BCD码后，要以十进制的形式显示到屏幕上，我们可以看出，BCD码值=十进制数码值，则BCD码值+30H=十进制数对应的ASCII码，为了实现这个功能，我们要做这样的两件事：</p><p>1.将从CMOS RAM的8号单元中读出的一个字节，分为两个表示BCD码值的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ah,al;al中为从CMOS RAM的8号单元中读出的数据</span><br><span class="line">mov cl,4</span><br><span class="line">shr ah,cl;ah中为月份的十位数码值</span><br><span class="line">and al,00001111b;al中为月份的个位数码值</span><br></pre></td></tr></table></figure><p>2.显示(ah)+30H和(al)+30H对应的ASCII码字符。</p><p>完整的程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov al,8</span><br><span class="line">out 70H,al</span><br><span class="line">in al,71H</span><br><span class="line">mov ah,al</span><br><span class="line">mov cl,4</span><br><span class="line">shr ah,cl</span><br><span class="line">and al,00001111B</span><br><span class="line">add ah,30H</span><br><span class="line">add al,30H</span><br><span class="line">mov bx,0b800H</span><br><span class="line">mov es,bx</span><br><span class="line">movbyte ptr es:[160*12+40*2],ah</span><br><span class="line">mov byte ptr es:[160*12+40*2+2],al</span><br><span class="line">mov 4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十三）</title>
    <link href="http://example.com/2022/09/20/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2022/09/20/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/</id>
    <published>2022-09-20T14:27:26.000Z</published>
    <updated>2022-09-23T04:50:51.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h1><p>本篇我们将介绍另一种重要的内中断，由int指令引发的中断。</p><p>int指令的格式为：int N，N为中断类型码，它的功能是引发中断过程。当CPU执行一条int指令时就相当于引发一个N号中断的中断过程，执行过程如下：</p><ol><li>取中断类型码N</li><li>标志寄存器入栈，IF=0,TF=0</li><li>CS、IP入栈</li><li>(IP)=(N×4)，(CS)=(N×4+2)</li></ol><p>从此处转去执行N号中断的中断处理程序。</p><p>可以在程序中使用int指令调用任何一个中断的中断处理程序。比如我们修改上一章中的程序，将结束时使用的int指令改为int 0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,offset do0end-offset do0</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200H</span><br><span class="line">mov word ptr es:[0*4+2],0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 0</span><br><span class="line">do0:</span><br><span class="line">jmp short do0start</span><br><span class="line">db &quot;OVERFLOW!&quot;</span><br><span class="line">do0start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,202H</span><br><span class="line">mov ax,0B800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,12*160+36*2</span><br><span class="line">mov cx,9</span><br><span class="line">s:mov al,[si]</span><br><span class="line">mov es:[di],al</span><br><span class="line">inc si</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>我们执行这个程序:</p><p><img src="1.jpg" alt="int指令引发0号中断"></p><p>我们可以看到在屏幕中间出现了”OVERFLOW!”，程序中本来是没有除法出现的，那么按理来讲就不会触发0号中断处理程序，但现在0号中断处理程序被调用了，这印证了我们之前说到的int指令可以根据类型中断码调用任何一个中断的中断处理程序。</p><h1 id="编写供应用程序调用的中断例程"><a href="#编写供应用程序调用的中断例程" class="headerlink" title="编写供应用程序调用的中断例程"></a>编写供应用程序调用的中断例程</h1><p>前面我们已经写过0号中断例程了，现在我们讨论如何编写可以供程序调用的中断例程的编写方法，现在有这样一个场景：</p><p>功能：将一个全是字母，以0结尾的字符串，转化为大写。</p><p>参数：ds:si指向字符串的首地址。</p><p>应用举例：将data段中的字符串转化为大写。</p><p>首先和我们之前做的一样要先将我们的中断例程安装到内存之中，这样才可以供应用程序调用，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset capital</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,offset capitalend-offset capital</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[7cH*4],200H</span><br><span class="line">mov word ptr es:[7cH*4+2],0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">capital:push cx</span><br><span class="line">push si</span><br><span class="line">change:mov cl,[si]</span><br><span class="line">mov ch,0</span><br><span class="line">jcxz ok</span><br><span class="line">and byte ptr [si],11011111B</span><br><span class="line">inc si</span><br><span class="line">jmp short change</span><br><span class="line">ok:pop si</span><br><span class="line">pop cx</span><br><span class="line">iret</span><br><span class="line">capitalend:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里需要注意的是在中断例程capital中使用了寄存器si和cx，编写中断例程和编写子程序是一样的要注意寄存器冲突的问题，这点非常重要。执行完安装程序后，我们就可以使用中断类型码7C来实现字符串转大写的操作啦，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;conversation&#x27;,0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">int 7cH</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="对int、iret和栈的深入理解"><a href="#对int、iret和栈的深入理解" class="headerlink" title="对int、iret和栈的深入理解"></a>对int、iret和栈的深入理解</h1><p>我们在学习这部分内容前，先思考一个问题：我们怎么才可以用中断例程7cH中断例程完成loop指令的功能。我们先思考loop指令，loop的执行需要两个信息，循环次数和到s的位移，所以，7cH中断例程要完成loop指令的功能，也需要这两个信息作为参数，我们用cx存放循环次数，用bx存放位移。现在我们想要在屏幕中间显示80个“!”,我们先给出完整代码然后分析一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,0b800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,160*12</span><br><span class="line">mov bx,offset s-offset se</span><br><span class="line">mov cx,80</span><br><span class="line">s:mov byte ptr es:[di],&#x27;!&#x27;</span><br><span class="line">add di,2</span><br><span class="line">int 7cH</span><br><span class="line">se:nop</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>上面的程序中，用int 7ch调用7ch中断例程进行转移，用bx传递转移的位移。为了模拟loop指令，7ch中断例程应该具有以下两个功能：</p><ol><li>dec cx</li><li>如果(cx)≠0，转到标号s处执行，否则向下执行。</li></ol><p>我们根据这两个功能分析一下7cH中断例程如何实现到目的地址的转移，转到标号s这显然是要使用标号s的地址设置CS和IP，但中断例程怎么才能拿到标号s的段地址和偏移地址呢？还记得吗？当CPU执行int指令后会将CS和IP压入栈中，这里的CS就是当前程序段的段地址，IP是int指令的下一条指令的偏移地址。可见，在中断例程中，可以从栈中取得标号s的段地址和标号se的偏移地址，而用标号se的偏移地址加上bx中存放的转移位移就可以得到标号s的偏移地址。</p><p>现在我们知道，可以从栈中直接和间接的获得标号s的段地址和偏移地址，那么我们要怎么用它们设置CS:IP呢？我们可以使用iret指令，我们将栈中的se的偏移地址加上bx中的转移位移，则栈中的se的偏移地址就变成了s的偏移地址。我们再用iret指令，用栈中的内容设置CS、IP，从而实现转移到标号s处。7cH中断例程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lp:push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">dec cx</span><br><span class="line">jcxz lpret</span><br><span class="line">add [bp+2],bx</span><br><span class="line">lpret:pop bp</span><br><span class="line">iret</span><br></pre></td></tr></table></figure><p>因为要访问栈，使用了bp，在程序开始处将bp入栈保存，结束时出栈恢复。当要修改栈中se的偏移地址的时候，栈中的情况为：栈顶处是bp原来的数值，下面是se的偏移地址，再下面是s的段地址，再下面是标志寄存器的值。而此时，bp中为栈顶的偏移地址，所以((ss)*16+(bp)+2)处为se的偏移地址，将它加上bx中的转移位移就变为s的偏移地址，最后用iret出栈返回，CS:IP即从标号s处开始执行指令。如果(cx)=0，则不需要修改栈中se的偏移地址，直接返回即可。CPU从标号se处向下执行指令。</p><h1 id="BIOS和DOS所提供的中断例程"><a href="#BIOS和DOS所提供的中断例程" class="headerlink" title="BIOS和DOS所提供的中断例程"></a>BIOS和DOS所提供的中断例程</h1><p>在系统板的ROM中存放着一套程序，称为BIOS（基本输入输出系统），BIOS中主要包含一下几部分内容。</p><ol><li>硬件系统的检测和初始化程序</li><li>外部中断和内部中断的中断例程</li><li>用于对硬件设备进行I/O操作的中断例程</li><li>其他和硬件系统相关的中断例程</li></ol><p>操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程时候经常需要用到的功能。程序员在编程的时候，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作。和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。</p><h1 id="BIOS和DOS中断例程的安装过程"><a href="#BIOS和DOS中断例程的安装过程" class="headerlink" title="BIOS和DOS中断例程的安装过程"></a>BIOS和DOS中断例程的安装过程</h1><p>我们通过之前的学习知道中断例程都需要先安装到内存中才可以使用，但是BIOS和DOS中断例程是怎么安装到内存中的呢？我们来简单的讲述一下这个过程：</p><ol><li>开机后，CPU一加电，初始化(CS)=0FFFFH，(IP)=0，自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。</li><li>初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。注意，对于BIOS所提供的中断例程，只需要将入口地址登记在中断向量表中即可，因为它们是固化到ROM中的程序，一直在内存中存在。</li><li>硬件系统检测和初始化完成后，调用int 19H进行操作系统的引导。从此将计算机交由操作系统控制。</li><li>DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存并建立相应的中断向量。</li></ol><h1 id="BIOS中断例程应用"><a href="#BIOS中断例程应用" class="headerlink" title="BIOS中断例程应用"></a>BIOS中断例程应用</h1><p>下面我们举一个例子，来看一下BIOS中断例程的应用。</p><p>int 10H中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。一般来说，一个供程序员调用的中断例程中往往包含多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。BIOS和DOS提供的中断例程，都用ah来传递内部子程序的编号。</p><p>下面看一下int 10H中断例程的设置光标位置功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ah,2;置光标</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov dh,5;dh中放行号</span><br><span class="line">mov dl,12;dl中放列号</span><br><span class="line">int 10H</span><br></pre></td></tr></table></figure><p>(ah)=2表示调用第10H号中断例程的2号子程序，功能为设置光标位置，可以提供光标所在行号（80×25 字符模式下：0-24）、列号（80×25字符模式下：0-79），和页号作为参数。</p><p>(bh)=0，(dh)=5，(dl)=12，设置光标到第0页，第五行，第十二列。</p><p>bh中页号的含义：内存地址空间中，B8000H-BFFFFH共32KB的空间，为80*25彩色字符模式的显示缓冲区。一屏的内容在显示缓存区中共占4000个字节。显示缓冲区分为8页，每页4KB，显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。也就是说，通常情况下，B8000H-B8F9FH中的4000个字节的内容将出现在显示器上。</p><p>再看一下int 10H中断例程的在光标位置显示字符功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ah,9;在光标位置显示字符</span><br><span class="line">mov al,&#x27;a&#x27;;字符</span><br><span class="line">mov dl,7;颜色属性</span><br><span class="line">mov dh,0;第0页</span><br><span class="line">mov cx，3;字符重复个数</span><br><span class="line">int 10H</span><br></pre></td></tr></table></figure><p>(ah)=9表示调用第10h号中断例程的9号子程序，功能为在光标位置显示字符，可以提供要显示的字符、颜色属性、页号、字符重复个数作为参数。</p><p>bl中的颜色属性的格式如下：</p><p><img src="2.jpg" alt="颜色属性的格式"></p><p>可以看出，和显存中的属性字节和格式相同。注意，闪烁的效果必须在全屏DOS方式下才能看到。</p><h1 id="DOS中断例程应用"><a href="#DOS中断例程应用" class="headerlink" title="DOS中断例程应用"></a>DOS中断例程应用</h1><p>int 21H中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。我们前面一直使用的是int 21H中断例程的4cH号功能，即程序返回功能，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4cH;程序返回</span><br><span class="line">mov al,0;返回值</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure><p>(ah)=4cH表示第21H号中断例程的4cH号子程序，功能为程序返回，可以提供返回值作为参数。我们前面使用这个功能的时候经常写做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure><p>我们看一下int 21H中断例程在光标位置显示字符串的功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ds:dx 指向字符串;要显示的字符串需用&quot;$&quot;作为结束符,但&quot;$&quot;本身不显示,只起到边界的作用</span><br><span class="line">mov ah,9;功能号9,表示在光标位置显示字符串</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure><p>(ah)=4cH表示第21H号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。</p><p>接下来给大家看一个应用中断例程的例子，在屏幕的5行12列显示字符串“Welcome to masm!”具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &#x27;Welcome to masm&#x27;,&#x27;$&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ah,2</span><br><span class="line">mov bh,0</span><br><span class="line">mov dh,5</span><br><span class="line">mov dl,12</span><br><span class="line">int 10H</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov dx,0</span><br><span class="line">mov ah,9</span><br><span class="line">int 21H</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>上述程序在屏幕的5行12列显示字符串“Welcome to masm!”，直到遇到’$’(不显示’$’，’$’只起到边界作用)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十二）</title>
    <link href="http://example.com/2022/09/18/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2022/09/18/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/</id>
    <published>2022-09-18T07:51:23.000Z</published>
    <updated>2022-09-21T05:37:05.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h1><p>任何一个通用的CPU都具有一个能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊的信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息我们可以称它为：中断信息。中断的意思是指，CPU不再接着向下执行，而是转头去处理这个特殊信息。</p><h1 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h1><p>什么情况下会产生中断信息呢？我们给出以下四种情况：</p><ol><li>除法错误，比如执行div指令产生的除法溢出</li><li>单步执行</li><li>执行into指令</li><li>执行int指令</li></ol><p>CPU在接收到这些信息的时候需要去处理它们，不同的信息有不同的处理方式，所以CPU要先知道中断信息的来源，所以中断信息中必须包含识别来源的编码。8086CPU用称为中断类型码的数据来标识中断信息的来源。中断类型码是一个字节型数据，可以表示256种中断信息的来源。之后我们的学习里，我们将中断信息的来源，简称为中断源。那么上述4种中断源，在8086CPU中的中断类型码如下：</p><ol><li>除法错误：0</li><li>单步执行：1</li><li>执行into指令：4</li><li>执行int指令：int指令的格式是int idata，其中idata是一个字节型立即数，它是int指令提供给CPU的中断类型码。</li></ol><h1 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h1><p>CPU收到中断信息后，需要对中断信息进行处理。至于如何处理中断信息，可以由我们编程决定，我们所编写出来处理中断信息的程序称为中断处理程序。一般来讲，需要对不同的中断信息编写不同的处理程序。</p><p>CPU在收到中断信息后，应该转去执行该中断信息的处理程序，那就要想办法修改CS:IP指向中断处理程序的第一条指令，所以首要问题是，CPU在接收到中断信息后，如何根据中断信息确定其处理程序的入口。如何根据8位的中断类型码得到中断处理程序的段地址和偏移地址呢？</p><h1 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h1><p>CPU用8位中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表又是啥子东西？中断向量表就是中断向量的列表。那中断向量又是啥子东西？？所谓中断向量，就是中断处理程序的入口地址，所以中断向量表就是中断处理程序的入口地址列表。</p><p>中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口。</p><p><img src="1.jpg" alt="中断向量表"></p><p>可以看到，当CPU知道了中断类型码，就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到中断处理程序的入口地址。可是。。CPU怎么找到中断向量表呢？中断向量表被存放在内存中，8086CPU规定内存0000:0000~0000:03FF的1024个单元内必须存放着中断向量表，只要是8086CPU那么内存的这个区域就一定是中断向量表。中断向量表中的每一个表项大小占两个字，高地址字存放段地址，低地址字存放偏移地址。</p><h1 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h1><p>现在我们知道了可以使用中断类型码，在中断向量表里面找到中断处理程序的入口，并用其修改CS:IP，使CPU执行中断处理程序。用中断类型码在中断向量表里面找到中断处理程序，设置CS:IP的过程是CPU硬件自动完成的。CPU硬件完成这一系列工作的过程被称为中断过程。</p><p>CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令，所以在中断过程中，在设置CS:IP之前还应该将原来的CS和IP中的值保存起来。所以整个中断过程应该是这样的：</p><ol><li>从中断信息中取得中断信息码</li><li>标志寄存器的值入栈</li><li>设置标志寄存器的第8位TF和第9位IF的值为0（下一篇详细介绍）</li><li>CS的内容入栈</li><li>IP的内容入栈</li><li>从内存地址为中断类型码×4和中断类型码×4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS</li></ol><h1 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a>中断处理程序和iret指令</h1><p>由于CPU随时都有可能检测到中断程序，所以中断处理程序必须一直储存在内存的某段空间之中。编写中断处理程序的步骤有以下四点：</p><ol><li>保存用到的寄存器</li><li>处理中断</li><li>恢复用到的寄存器</li><li>用iret指令返回</li></ol><p>iret指令的功能用汇编语法描述为pop IP，pop CS，popf。iret通常和硬件自动完成的中断过程配合使用，它实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作。iret指令执行后CPU回到执行中断处理程序前的执行点继续执行程序。</p><h1 id="除法错误中断的处理"><a href="#除法错误中断的处理" class="headerlink" title="除法错误中断的处理"></a>除法错误中断的处理</h1><p>我们接下来通过0号中断，即除法错误中断的处理，来体会一下前面的内容。</p><p>当CPU执行div等除法指令时，如果发生了除法溢出的错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序。就像这样：</p><p><img src="2.jpg" alt="除法错误中断的处理"></p><p>可能因为DOSBox是一个模拟器，这种虚拟模式下的DOS系统的中断处理程序与其它方式进入的DOS系统的中断处理程序并不相同。所以没有显示我们想要的错误提示。</p><h1 id="编程处理0号中断"><a href="#编程处理0号中断" class="headerlink" title="编程处理0号中断"></a>编程处理0号中断</h1><p>现在我们改写一下0号中断处理程序的功能，让它可以在屏幕中间显示”OVERFLOW!”,然后返回操作系统。</p><p>我们叫这个程序为do0好了，首先我们要考虑的问题是因为0号中断随时都可能发生，所以我们编写的中断处理程序需要放在内存当中，可是具体应该是哪里呢？前面讲到，内存0000:0000~0000:03FF，大小为1KB的空间是系统存放中断处理程序的入口地址的中断向量表。8086支持256个中断，但实际上系统要处理的中断事件远没有256个，所以在中断向量表里很多单元都是空的。这些空间只用来存放中断处理程序的入口地址，DOS系统和其他程序不会随便使用这块空间，所以可以用这块空间来存放我们的中断处理程序。当然这也限制我们的中断处理程序不能超过256字节。我们打算将do0传送到0000:0200，将do0传送到0000:0200还不算完，我们还要将0000:0200登记在中断向量表的对应表项中，因为是0号中断，所以中断程序的段地址应该在0000:0002字单元中，偏移地址应该在0000:0000字单元中。</p><p>综上所述我们要做这样几件事：</p><ol><li>编写可以显示”OVERFLOW!”的中断处理程序do0</li><li>将do0送入内存0000:0200处</li><li>将do0的入口地址0000:0200储存在中断向量表0号表项中</li></ol><p>所以程序的框架应该是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:do0安装程序</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:显示字符串&quot;OVERFLOW!&quot;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这个程序执行过后将我们写好的中断处理程序复制到了内存的0000:0200处，将do0的入口地址储存在中断向量表中了。接下来我们一点点将程序补完吧！</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>我们可以使用之前说的串传送指令movsb，do0的代码送入0000:0200，程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:设置es:di指向目的地址</span><br><span class="line">设置ds:si指向原地址</span><br><span class="line">设置cx为传输长度</span><br><span class="line">设置传输方向为正</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:显示字符串&quot;OVERFLOW!&quot;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>我们看一下程序中我们应该可以对应上的数据：</p><ol><li>传送的原始位置，段地址：code，偏移地址：offset do0</li><li>传送的目的位置：0000:0200</li><li>传送的长度：do0部分代码长度</li><li>传送的方向：正向</li></ol><p>那么我们就可以将程序补充成这样子滴：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,do0部分代码的长度</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:显示字符串&quot;OVERFLOW!&quot;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>现在我们面临了一个问题，我们怎么知道do0部分的代码长度呢？最简单的方法是，计算一下do0中所有指令码的字节长度，但这样做太麻烦了，而且写成确定的数字也不利于我们以后的更改。所以我们可以让编译器为我们代劳计算do0的长度。这样代码又变成了这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,offset do0end-offset do0</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:显示字符串&quot;OVERFLOW!&quot;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0end：nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>“-“是编译器识别的运算符号，编译器可以用它进行两个常数的减法。就好比mov ax,8-4会被编译器翻译成mov ax,4一样。</p><p>接下来我们来补全do0代码。</p><h1 id="do0"><a href="#do0" class="headerlink" title="do0"></a>do0</h1><p>我们已经分析好do0的工作了所以这里直接给出代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,offset do0end-offset do0</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:jmp short do0start</span><br><span class="line">db &quot;OVERFLOW!&quot;</span><br><span class="line">do0start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,202H;设置ds:si指向字符串</span><br><span class="line">mov ax,0B800H</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,12*160+36*2;设置es:di指向显存空间的中间位置</span><br><span class="line">mov cx,9;设置cx为字符串长度</span><br><span class="line">s:mov al,[si]</span><br><span class="line">mov es:[di],al</span><br><span class="line">inc si</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里我们来剖析一下代码：</p><p>首先，“OVERFLOW！”没有被存储在一个数据段里，而是和do0一同储存在了代码段里，这是因为如果将字符串存在数据段里，待程序执行完毕，数据段内容会被释放，这样do0程序以后就找不到字符串了，所以我们将字符串一并的存放在代码段中。</p><p>其次，因为do0程序开始处的“OVERFLOW!”不是可以执行的代码，所以在它之前要加上一个jmp指令，跳转到正式的do0程序。</p><p>最后，do0程序执行过程中必须要能找到“OVERFLOW!”，那么它在哪里呢？首先来看段地址，肯定是code段了和do0在一个段地址，再看偏移地址，0000:0200处指令为jmp short do0start，这条指令占两个字节所以，“OVERFLOW!”的偏移地址为202H。</p><h1 id="设置中断向量"><a href="#设置中断向量" class="headerlink" title="设置中断向量"></a>设置中断向量</h1><p>下面要将do0的入口地址0000:0200写入0号表项中。0号表项地址为0000:0000，其中0000:0000字单元放偏移地址，0000:0002放段地址，所以程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200H</span><br><span class="line">mov word ptr es:[0*4+2],0</span><br></pre></td></tr></table></figure><h1 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h1><p>基本上，CPU在执行完一条指令后，如果检测到标志寄存器TF位为1，则产生单步中断，引发中断过程。单步中断的类型码为1，它引发的中断过程如下：</p><ol><li>取得中断类型码1</li><li>标志寄存器入栈，TF、IF设置为0</li><li>CS、IP入栈</li><li>(IP)=(1×4)，(CS)=(1×4+2)</li></ol><p>如上所述，每执行完一条指令，CPU就要转去执行一次1号中断处理程序，CPU为什么要这样做呢？</p><p>我们在使用debug的T命令时，有没有想过这样的问题，debug凭什么可以让程序执行完一条指令后显示各个寄存器的值？我们知道程序的运行就是CS:IP指向程序入口，然后CPU自动向下读取，如果没有外加其他功能，CPU应该是一加上电，它就从预设的地址开始执行下去，不会出现执行一条停一下的情况，可是在debug中，CPU却是这么做的。其实debug是用到了CPU的一个功能实现的，这个功能支持着T命令的工作。</p><p>下面我们就简要的考虑一下debug到底是如何利用CPU所提供的单步中断的功能的。首先，debug提供了单步中断的中断处理程序，功能为显示所有寄存器内容并且等待后续输入命令。然后，在使用t命令执行指令时，debug将TF设置为1，使得CPU工作于单步中断方式下，然后CPU执行完当前指令后，检测到TF为1，引发单步中断，执行单步中断处理程序。</p><p>但是单步中断处理程序也是一条条指令呀，那执行一条指令就单步中断一次，执行一次单步中断处理程序，这不是没完没了了嘛，CPU当然不会允许这种事情发生啦，CPU会在进入中断处理程序之前，设置TF为0，从而避免这种情况的出现，这就是为什么在中断过程中有TF=0这个步骤。我们再来看一遍中断过程：</p><ol><li>取得中断类型码N</li><li>标志寄存器入栈，TF、IF设置为0</li><li>CS、IP入栈</li><li>(IP)=(N×4)，(CS)=(N×4+2)</li></ol><p>最后，CPU提供单步中断功能的原因，就是为了实现单步跟踪程序的执行过程。</p><h1 id="响应中断的特殊情况"><a href="#响应中断的特殊情况" class="headerlink" title="响应中断的特殊情况"></a>响应中断的特殊情况</h1><p>一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就会响应中断，引发中断过程。但是在某些情况下CPU执行完当前的指令后，即便是发生了中断，也不会响应。比如：</p><p>在执行完向SS寄存器传送数据的指令后，即便发生了中断，CPU也不会响应。这样做的原因是，SS:SP联合指向栈顶，而对它们的设置应该连续完成。如果在执行完设置SS的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器的值、CS和IP的值。而SS改变，SP没改变，那SS:SP指向的位置就是错误的。所以CPU在执行设置完SS的指令后，不响应中断。这给连续设置SS和SP提供了一个时机，我们应该利用这个时机，将设置SS和SP的指令连续存放，也就是应该这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov ax，0</span><br><span class="line">mov sp,0</span><br></pre></td></tr></table></figure><p>相信有些细心的小伙伴在学习过程中会发现，用T命令跟踪程序时，往往设置SP的指令会被跳过，但是SP还是被正确设置了，先在我想你心里已经有了答案！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十一）</title>
    <link href="http://example.com/2022/09/12/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/09/12/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</id>
    <published>2022-09-12T06:09:31.000Z</published>
    <updated>2022-09-18T07:36:56.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h1><p>CPU内部的寄存器中，有一种特殊的寄存器，它具有一下三种作用：</p><ul><li>用来存储相关指令的某些执行成果</li><li>用来为CPU执行相关指令提供行为依据</li><li>用来控制CPU的相关工作方式</li></ul><p>它叫做标志寄存器flag，其中储存的信息通常被叫做程序状态字(PSW)，flag寄存器和其他寄存器不一样，其他寄存器都是整个寄存器具有一个含义，而flag是按位起作用的，每一位都有特定的含义。</p><p><img src="1.jpg" alt="flag寄存器的结构"></p><p>flag寄存器的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义，其余位都具有特殊含义。</p><h1 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h1><p>我们知道flag寄存器的结构后，就分别来介绍一下用到的标志位，首先是ZF标志位。</p><p>flag寄存器中第6位：ZF，零标志位。它记录着相关指令执行后，其结果是否为0，如果为0，则ZF为1，反之ZF为0。这很好理解，只要执行的指令得到的结果是0，那么ZF就是1，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">and ax,0</span><br></pre></td></tr></table></figure><p>这两条指令执行完后ZF就是1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">or ax,0</span><br></pre></td></tr></table></figure><p>这两条指令执行完后ZF就是0。</p><p>注意，在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如add，sub，mul，div，inc，or，and等它们多为运算指令；有的指令对标志寄存器是没有影响的，比如mov，pop，push等它们大多数为传送指令。</p><h1 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h1><p>我们介绍的第二个朋友就是PF标志位。</p><p>flag寄存器中第2位：PF，奇偶标志位，它记录相关指令执行后，其结果的所有bit位中1的个数是奇数个还是偶数个，如果为偶数，那么PF就为1，反之为0，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,1</span><br><span class="line">add AL,10</span><br></pre></td></tr></table></figure><p>这两条指令执行完后，结果为00001011B，其中有三个1，所以ZF就是0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,1</span><br><span class="line">or AL,2</span><br></pre></td></tr></table></figure><p>这两条指令执行完后，结果为00000011B，其中有两个1，所以ZF就是1。</p><p>(Tips：0也是偶数哦)</p><h1 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h1><p>接下来是第三位朋友SF标志位。</p><p>flag寄存器中第7位SF，符号标志位。它记录相关指令执行后，其结果是否为负数，如果为负数，那么SF为1，反之为0，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,10000001B</span><br><span class="line">add AL,1</span><br></pre></td></tr></table></figure><p>这两条指令执行完后，结果为10000010B，如果进行的是有符号数计算，那么SF为1，代表结果为负。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,10000001B</span><br><span class="line">add AL,01111111B</span><br></pre></td></tr></table></figure><p>这两条指令执行完后，结果为0，如果进行的是有符号数计算，那么SF为0，代表结果为正。</p><p>计算机中通常用补码来表示有符号数据，一个数据可以被看成有符号数字也可以被看成无符号数字，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,10000001B</span><br><span class="line">add AL,1</span><br></pre></td></tr></table></figure><p>结果为(AL)=10000010B。我们可以认为add指令进行了一次无符号数运算，那么add指令就相当于计算了129+1，结果为130(10000010B)；当然我们也可以认为add指令进行了一次有符号数运算，那么add指令就相当于计算-127+1，结果为-126(10000010B)。</p><p>SF标志，就是CPU对有符号数运算结果的一种记录，记录了数据的正负，我们进行有符号数计算时，可以将SF标志作为判断数据正负的依据，当我们进行无符号数计算的时候，SF标志没有什么使用价值，因此我们要根据进行的计算，去观察SF标志。</p><h1 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h1><p>接下来介绍大哥，CF标志位。</p><p>flag寄存器第0位CF，进位标志位。一般情况下，进行无符号数计算的时候，注意是无符号数，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p><p>对于位数为N的无符号数来说，其对应的二进制信息的最高位，为N-1位，也就是它的最高有效位，而我们假象出来的第N位，就是相对于最高有效位的更高位。</p><p><img src="2.jpg" alt="最高有效位和假想最高位"></p><p>我们知道，当两个数据相加时，就有可能产生从最高有效位向更高位的进位。比如98H+98H，将产生进位。由于这个进位值在8位数中无法保存，我们之前只是简单的说这个进位丢失了，但其实CPU在运算时，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。8086CPU就使用flag的CF位来记录这个进位值，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov AL,98H</span><br><span class="line">add AL,AL</span><br><span class="line">add AL,AL</span><br></pre></td></tr></table></figure><p>第一条add指令执行后，(AL)=30H，CF=1，CF记录了从最高有效位向更高位的进位值，第二条add指令执行后，(AL)=60H，CF=0。</p><p>同样当进行减法运算时，也可能向更高位借位。比如，两个97H-98H，将产生借位，借位后就相当于计算197H-98H。CF标志为也可以记录这个值，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov AL,97H</span><br><span class="line">sub AL,98H</span><br><span class="line">sub AL,AL</span><br></pre></td></tr></table></figure><p>第一条sub指令执行后，(AL)=FFH，CF=1，CF记录了向更高位的借位值，第二条sub指令执行后，(AL)=0H，CF=0。</p><p>哦对了，inc指令不会影响CF的值，要记住。</p><h1 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h1><p>flag寄存器第11位OF，溢出标志位。在仔细了解它之前我们先来了解一下溢出的问题。</p><p>在进行有符号计算的时候，如果结果超过了机器所能表示的范围称为溢出。那么什么是机器能表示的范围呢？比如说，指令运算的结果用8位寄存器或内存单元来存放，比如，add AL,3，那么对于8位的有符号数据，机器所能表示的范围是-128到127。同理，对于16位有符号数据，机器能表示的范围为-32768到32767。如果运算结果超过了机器所能表达的范围，将产生溢出。注意我们现在所讲的溢出，是针对有符号数而言，下面我们看个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,98</span><br><span class="line">add AL,99</span><br></pre></td></tr></table></figure><p>执行后将产生溢出。因为add AL,99进行的有符号数运算是：98+99=197，而结果197超出了机器能表示的8位有符号数的范围，这就发生了溢出，如果在进行有符号数运算时发生溢出，那么运算结果就不正确，就例子而言，add指令运算完的结果是(AL)=0C5H，因为进行的是有符号数计算，所以AL中存储的是有符号数，C5H是-59的补码，如果我们用add指令进行的是有符号数运算，那我们就得到了98+99=-59，这太夸张了！造成这样的原因是实际结果197无法在8位寄存器中存放，由于这样的事情存在，所以CPU要对指令执行以后是否产生了溢出进行记录。</p><p>现在我们回过头来看一下OF标志，如果指令执行以后发生了溢出OF=1反之OF=0，我们要注意，CF是对无符号数有意义的标志位，而OF是对有符号数有意义的标志位，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,0F0H</span><br><span class="line">add AL,88H</span><br></pre></td></tr></table></figure><p>两条指令执行后：CF=1，OF=1。对于无符号数运算来讲，0F0H+88H有进位，所以CF=1；对于有符号数运算来讲，0F0H+88H发生溢出，所以OF=1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov AL,0F0H</span><br><span class="line">add AL,78H</span><br></pre></td></tr></table></figure><p>两条指令执行后：CF=1，OF=0。对于无符号数运算来讲，0F0H+78H有进位，所以CF=1；对于有符号数运算来讲，0F0H+78H没发生溢出，所以OF=0。</p><p>我们可以看出，CF和OF所表示的进位和溢出，分别是对无符号数计算和有符号数计算而言的，它们之间没有任何关系。</p><h1 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h1><p>adc指令是带进位的加法指令，它利用了CF位上记录的进位值，我们来看一下它的格式：</p><p>adc 操作对象1，操作对象2</p><p>它的功能是：操作对象1=操作对象1+操作对象2+CF，比如说adc  ax,bx，实现的功能是(ax)=(ax)+(bx)+CF，我们看一下例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adc ax,1</span><br></pre></td></tr></table></figure><p>因为sub bx,ax发生了借位，这时CF=1，之后adc指令就计算了：(ax)+1+CF=2+1+1=4，所以(ax)=4。</p><p>为什么要加上CF的值呢？CPU为什么提供了这样的指令呢？我们先来回看一下CF的值的含义，adc指令使用到的CF的值的含义是由adc指令前面的指令决定的，也就是说，关键在于所加上的CF值是被什么设置的，如果CF是被sub设置的那么就是借位值，如果是add设置的那就是进位值，所以CF存在的意义就是用来进行高位数数据计算，比如add ax,bx也可以被看做add AL,BL，adc ah,bh它们是完全等价的。我们看一个例子：</p><p>计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中，很显然add指令做不到计算这样大的数据，所以我们打算先计算低16位相加，然后计算高16位相加再加上CF的值。也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001EH</span><br><span class="line">mov bx,0F000H</span><br><span class="line">add bx,1000H</span><br><span class="line">adc ax,0020H</span><br></pre></td></tr></table></figure><p>我们可以根据这个思路计算更大的数据相加。</p><h1 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h1><p>sbb指令是带借位的减法指令，它利用了CF位上记录的借位值，我们来看一下它的格式：</p><p>sbb 操作对象1，操作对象2</p><p>它的功能是：操作对象1=操作对象1-操作对象2-CF，比如说sbb  ax,bx，实现的功能是(ax)=(ax)-(bx)-CF。同样的我们也可以根据我们之前的思路，进行高位数数据的运算。这里我们不再赘述。</p><h1 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h1><p>cmp指令是比较指令，cmp的功能相当于减法指令，只是不保存结果，cmp指令执行后将对标志寄存器产生影响，其他的指令通过识别这些被影响的标志寄存器位来得知比较结果。老样子我们看一下cmp指令的格式：</p><p>cmp 操作对象1，操作对象2</p><p>cmp指令的功能是这样的，计算操作对象1-操作对象2但并不保存结果，仅仅根据计算的结果对标志寄存器进行设置，比如cmp ax,ax它首先计算了(ax)-(ax)结果为0，但并不在ax中保存，仅根据0来设置flag中的相关位，这条指令执行后，ZF=1,PF=1,SF=0,CF=0,OF=0。</p><p>所以我们可以看出来cmp指令给了我们很多信息：</p><p><img src="3.jpg" alt="cmp指令提供的信息1"></p><p>和add，sub指令一样，CPU执行cmp指令的时候也包含两种含义：对无符号数进行比较，对有符号数进行比较，上面我们讲的是对无符号数进行的比较，下面我们看一下对有符号数的比较：</p><p>我们以cmp ah,bh为例，如果(ah)=(bh)，则(ah)-(bh)=0，所以：ZF=1，反之ZF=0，所以我们根据ZF的值可以知道两个数据是否相等。接下来我们再来看(ah)&lt;(bh)会发生什么，在这个情况下，(ah)-(bh)显然可能引起SF=1，即结果为负，但是我们不能因为SF=1就说明(ah)&lt;(bh)，例如：(ah)-(bh)=34-(-96)=82H(-126)，我们不能因为计算后SF=1就说34&lt;-96这显然是不合理的。当运算发生溢出以后我们逻辑上的得到的结果(130)和实际的结果(-126)是不一样的，所以单单根据SF去判断比较较结果是不可靠的，还要结合OF一起判断，下面我们就来看看SF和OF到底给我们提供了什么样的信息：</p><p><img src="4.jpg" alt="cmp指令提供的信息2"></p><h1 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h1><p>我们在之前的学习过程中，学到过一个条件转移指令jcxz指令，它通过检测(CX)是否为0，来判断是否进行条件转移，当然除了jcxz之外，CPU还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的标志位，这些指令通常和cmp组合使用就像是call和ret的关系。</p><p>因为cmp有两种比较，无符号数比较和有符号数比较，所以和cmp组合的转移动指令也有两种，根据无符号数的比较结果进行转移的条件转移指令(它们检测ZF和CF的值)，根据有符号数的比较结果进行转移的的条件转移指令(它们检测SF、OF、ZF的值)。</p><p>下面是常用的根据无符号数的比较结果进行转移的条件转移指令：</p><p><img src="5.jpg" alt="常用的根据无符号数的比较结果进行转移的条件转移指令"></p><p>这些指令很常用，而且很好记忆，它们的第一个字母j表示jump，之后的e代表equal，ne就是not equal，b是below，a是above。</p><p>当然了，这些指令的含义都是和cmp结合的时候才拥有的，它们做的事情只是检测相关标志位，符合条件就跳转，比如有这样一段程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">add ax,0</span><br><span class="line">je s</span><br><span class="line">inc ax</span><br><span class="line">s:inc ax</span><br></pre></td></tr></table></figure><p>执行过后，(ax)=1，因为add ax,0执行过后设置了ZF=1，je指令检测到ZF=1后跳转到S处，这里就不能说谁等于谁，也就是说je指令没有什么含义，因此我们一般将cmp和这些跳转指令一起使用，它们组合起来就像是高级语言中的IF一样起到一个条件判断的作用。有符号数比较跳转指令的原理就和无符号数比较跳转指令相同了，有兴趣可以查阅相关的指令手册。</p><h1 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h1><p>接下来介绍的是flag寄存器的第10位DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。DF=0每次操作后si、di递增；DF=1每次操作后si、di递减。知道了DF的作用后，我们还得知道串传送指令，我们来看一下movsb指令，首先是movsb的格式就是movsb，当执行movsb指令时就相当于做了这样几件事：</p><ol><li>((es)×16+(di))=((ds)×16+(si))</li><li>如果DF=0则(si)=(si)+1,(di)=(di)+1</li><li>如果DF=1则(si)=(si)-1,(di)=(di)-1</li></ol><p>它实现了将DS:SI指向的内存字节单元的内容送入ES:DI中，然后根据DF的值将SI和DI递增1或者递减1。还有另一个指令，movsw指令，它实现了DS:SI指向的内存字单元的内容送入ES:DI中，然后根据DF的值将SI和DI递增2或者递减2。</p><p>movsb和movsw都是串传送操作的一个步骤，一般来说这两个指令都会和rep指令配合使用，rep指令的格式是rep movsb，它做的事情就像是一个循环即s:movsb；loop s。可见rep的作用是根据CX的值，重复执行后面的串传送指令，因为每执行一次movsb指令si和di都会递增或递减一个单位，所以rep movsb可以循环实现(CX)个字符的传送。同理也有rep movsw。</p><p>因为DF标志位决定了串传送指令执行后，si和di改变的方向，所以CPU给程序员提供了相应修改DF位的指令，让程序员可以修改串传送的方向，这两个指令分别是cld指令(将DF置为0)，std指令(将DF置为1)。</p><h1 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h1><p>pushf的格式很简单就是pushf，它做的事情是将标志寄存器的值压栈，popf的格式也是popf，它做的事情是从栈中弹出数据，送入标志寄存器。这两个指令为直接访问标志寄存器提供了一种方法。</p><h1 id="标志寄存器在Debug中的表示"><a href="#标志寄存器在Debug中的表示" class="headerlink" title="标志寄存器在Debug中的表示"></a>标志寄存器在Debug中的表示</h1><p>最后的最后，我们要了解一下标志寄存器在Debug中怎么表示的，这样方便我们在程序调试的时候，观察这些标志位的变化。</p><p><img src="6.jpg" alt="标志寄存器在debug中显示位置"></p><p>当我们开始debug之后执行r指令，我们可以看到在IP寄存器之后有一串字符，这串字符就表示了几个标志位的值，但是这一些值我也分不清那个是那个标志位呀！没关系，我们给出了标志位中值的表示：</p><p><img src="7.jpg" alt="debug对我们已知的标志位的表示"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（十）</title>
    <link href="http://example.com/2022/09/06/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <id>http://example.com/2022/09/06/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%8D%81%EF%BC%89/</id>
    <published>2022-09-06T15:33:49.000Z</published>
    <updated>2022-09-09T08:13:44.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h1><p>我们书接上回，上一篇我们学习了一些转移指令的原理，接下来我们继续学习一些新的转移指令：</p><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移，当CPU执行ret指令时，进行下面两步操作：(IP)=((SS)×16+(SP))；(SP)=(SP)+2。用汇编语法来解释ref指令相当于进行了pop IP。</p><p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移，当CPU执行retf指令时，进行下面四步操作：(IP)=((SS)×16+(SP))；(SP)=(SP)+2；(CS)=((SS)×16+(SP))；(SP)=(SP)+2。用汇编语法来解释ref指令相当于进行了pop IP，pop CS。</p><h1 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h1><p>call指令也是一种转移指令，当CPU执行call指令的时候，进行两步操作：将下一条指令的IP或CS和IP压入栈中；转移。call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。接下来我们仔细介绍一下。</p><h2 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h2><p>首先，看一下call指令的格式：call 标号，将下一条指令IP压入栈中后，转到标号处执行指令。也就是这么一个过程：(SP)=(SP)-2；((SS)×16+(SP))=(IP)；(IP)=(IP)+16位位移。其中16位位移的计算方法是：位移=标号处偏移地址-call指令下一条指令的偏移地址，结果用补码表示，在编译程序编译时算出。当然了16位位移是有取值范围的，取值范围是-32768~32767，用补码表示。用汇编语法来解释call指令相当于进行了push IP；jmp near ptr 标号。</p><h2 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h2><p>首先，还是看一下call指令的格式：call far ptr 标号，将下一条指令CS和IP压入栈中后，转到标号处执行指令。也就是这么一个过程：(SP)=(SP)-2；((SS)×16+(SP))=(CS)；(SP)=(SP)-2；((SS)×16+(SP))=(IP)；(IP)=(IP)+16位位移；(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址。这样的call指令实现了段间转移，用汇编语法来解释call指令相当于进行了push CS；push IP；jmp far ptr 标号。</p><h2 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h2><p>这个call指令的格式是：call 16位reg。它的过程是：(SP)=(SP)-2；((SS)×16+(SP))=(IP)；(IP)=(16位reg)，用汇编语法来解释call指令相当于进行了push IP；jmp 16位reg。</p><h2 id="转移地址在内存中的call指令"><a href="#转移地址在内存中的call指令" class="headerlink" title="转移地址在内存中的call指令"></a>转移地址在内存中的call指令</h2><p>call指令中的转移地址也可以在内存之中，它也分为两种格式：</p><h3 id="call-word-ptr-内存单元地址"><a href="#call-word-ptr-内存单元地址" class="headerlink" title="call word ptr 内存单元地址"></a>call word ptr 内存单元地址</h3><p>用汇编语言解释这句指令的话，那么当CPU执行这句指令的时候，相当于进行了：push IP；jmp word ptr 内存单元地址。</p><h3 id="call-dword-ptr-内存单元地址"><a href="#call-dword-ptr-内存单元地址" class="headerlink" title="call dword ptr 内存单元地址"></a>call dword ptr 内存单元地址</h3><p>用汇编语言解释这句指令的话，那么当CPU执行这句指令的时候，相当于进行了：push CS；push IP；jmp dword ptr 内存单元地址。</p><h1 id="call和ret的配合使用"><a href="#call和ret的配合使用" class="headerlink" title="call和ret的配合使用"></a>call和ret的配合使用</h1><p>我们学会了ret指令也学会了call指令，学这两个指令的目的是为了实现子程序的机制，什么是子程序呢？直观的来说就是我们在高级语言中写的函数，怎么样是不是一下子就感受到这两个指令的强大了，事不宜迟，我们马上开始。  我们先来看一个程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code内存中的情况（假设程序从内存1000:0处装入）</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 8 dup (0)1000:0000 00 00 00 00 00 00 00 00</span><br><span class="line">db 8 dup (0)1000:0008 00 00 00 00 00 00 00 00</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack1001:0000 B8 00 10</span><br><span class="line">mov ss,ax1001:0003 8E D0</span><br><span class="line">mov sp,161001:0005 BC 10 00</span><br><span class="line">mov ax,10001001:0008 B8 E8 03</span><br><span class="line">call s1001:000B E8 05 00</span><br><span class="line">mov ax,4c00H1001:000E B8 00 4C</span><br><span class="line">int 21H1001:0011 CD 21</span><br><span class="line">s:add ax,ax1001:0013 03 C0</span><br><span class="line">ret1001:0015 C3</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>程序中给出了内存中的情况，我们结合内存的情况一点点分析整个程序做的事情。从start开始前三行执行后，栈的情况如下：</p><p>1000:0000 00 00 00 00 00 00 00 00</p><p>此时SS:SP指向栈底，当call指令读入后，(IP)=000EH，CPU指令缓冲器中的代码为：E8 05 00（call s）</p><p>程序执行完call s后，栈的情况变为</p><p>1000:0000 00 00 00 00 00 00 0E 00</p><p>此时SS:SP指向0E也就是倒数第二个字节，然后(IP)=(IP)+0005=0013H。之后CPU从CS:0013H处(即标号s处)开始执行，ret指令读入后(IP)=0016H，CPU指令缓存器中的代码为：C3 （ret）</p><p>程序执行完C3后，栈的情况变为</p><p>1000:0000 00 00 00 00 00 00 0E 00</p><p>此时SS:SP指向栈底，之后CPU回到CS:000EH处（即call指令后面的指令处）继续执行。</p><p>怎么样，是不是有点像我们在高级程序中做的那个样子，写一个函数，当我们需要它的时候就调用它，不需要的时候我们就不调用它。我们给出一个子程序的源程序的框架：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">main:</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  call sub1         调用子程序sub1</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  mov ax,4C00H</span><br><span class="line">  int 21H</span><br><span class="line">sub1:</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  call sub2调用子程序sub2</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ret子程序返回</span><br><span class="line">sub2:</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ·</span><br><span class="line">  ret子程序返回</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure><p>怎么样现在的汇编语言是不是更有我们高级程序语言的模样啦！</p><h1 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h1><p>我们这里介绍一下mul指令，mul是乘法指令，在使用mul做乘法时要注意两点：</p><ol><li>两个相乘的数：要不都是8位，要不都是16位。如果都是8位那么一个默认放在AL中，另一个默认放在8位reg或者内存字节单元中。如果都是16位那么一个默认放在AX中，另一个默认放在16位reg或者内存字单元中。</li><li>结果：如果8位乘法，结果默认在AX中；如果是16位乘法那么，结果高位默认在dx中，低位在ax中。</li></ol><p>格式如下：</p><ul><li>mul reg</li><li>mul 内存单元</li></ul><p>内存单元可以通过不同的寻址方式给出，比如：</p><p>mul byte ptr ds:[0] 含义是(AX)=(AL)×((DS)×16+0);mul word ptr [BX+SI+8]含义是(AX)=(AX)×((DS)×16+(BX)+(SI)+8)结果的低16位;(DX)=(AX)×((DS)×16+(BX)+(SI)+8)结果的高16位。</p><h1 id="参数与结果传递的问题"><a href="#参数与结果传递的问题" class="headerlink" title="参数与结果传递的问题"></a>参数与结果传递的问题</h1><p>在高级语言中，我们都知道一个函数由返回值类型，函数名称、参数列表组成，我们将参数交给函数，函数在进行了指定的操作后，将结果交付给我们。在我们的汇编语言中也会使用这种模块化的程序设计。</p><p>我们现在思考这样的问题，现在我们有一个数N，设计一个子程序计算N的三次幂。这样一来我们就有了两个问题，参数N应该存放在哪里？得到的结果要存放在哪？很显然，可以用寄存器来存储，可以将参数放到BX中；因为子程序中要计算N的3次幂，所以可以使用多个mul指令，为了方便，可将结果存放到dx和ax中，我们来看程序，这个程序计算了data段第一组数据的3次方，结果保存到后一组的dword单元中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">dw 1,2,3,4,5,6,7,8</span><br><span class="line">dd 0,0,0,0,0,0,0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,16</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov bx,[si]</span><br><span class="line">call cube</span><br><span class="line">mov [di],ax</span><br><span class="line">mov [di].2,dx</span><br><span class="line">add si,2</span><br><span class="line">add di,4</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">cube:mov ax,bx</span><br><span class="line">mul bx</span><br><span class="line">mul bx </span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="批量数据的传递"><a href="#批量数据的传递" class="headerlink" title="批量数据的传递"></a>批量数据的传递</h1><p>上面的程序中子程序cube只有一个参数，放在bx中。如果有两个参数，那么可以使用两个寄存器来放，可是如果需要传递3个，4个，N个怎么办？显然一味地使用寄存器是不可靠的。这种时候，我们将批量的数据放到内存之中，然后将它们所在的内存空间的首地址放在寄存器中，传递给需要的子程序，同样需要返回多个数据，我们也这样做。我们写一个将字符串转为大写的程序，体验一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &#x27;conversation&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,12</span><br><span class="line">call capital</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">capital:and byte ptr [si],11011111B</span><br><span class="line">inc si</span><br><span class="line">loop capital</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>除了使用寄存器传递参数，我们还有更通用的做法，使用栈来传递参数，我们接下来结合C语言的函数调用来看一下使用栈传递参数的思想，我们设定一个场景，我们要设计一个子程序计算(a-b)的3次幂，a和b是字型数据，我们来看用到的程序片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">push ax</span><br><span class="line">mov ax,3</span><br><span class="line">push ax</span><br><span class="line">call difcube</span><br><span class="line">difcube:push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">mov ax,[bp+4]</span><br><span class="line">sub ax,[bp+6]</span><br><span class="line">mov bp,ax</span><br><span class="line">mul bp</span><br><span class="line">mul bp</span><br><span class="line">pop bp</span><br><span class="line">ret 4</span><br></pre></td></tr></table></figure><p>其中ret idata的含义用汇编语法描述为：</p><p>pop IP；add sp,idata</p><p>我们来看看栈的变化，假设栈的初始情况如下：</p><p>1000:0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </p><p>此时SS:SP指向栈底。</p><p>当执行mov ax,1~push ax指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 00 00 00 00 03 00 01 00 </p><p>此时SS:SP指向03。</p><p>当执行call difcube指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 00 00 XP XI 03 00 01 00 </p><p>此时SS:SP指向XI(XIXPH即为call指令的下一条指令IP)。</p><p>执行push bp指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 XB XA XI XP 03 00 01 00 </p><p>此时SS:SP指向XB。</p><p>执行mov bp,sp后，SS:BP指向1000:8</p><p>之后执行mov ax,[bp+4]将栈中a的值送入ax中，sub ax,[bp+6]减去栈中b的值，mov bp,ax将ax中的值赋给bp，mul bp计算三次幂。</p><p>执行pop bp指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 XB XA XI XP 03 00 01 00 </p><p>此时SS:SP指向XI。</p><p>执行ret 4指令后，栈的情况为：</p><p>1000:0000 00 00 00 00 00 00 00 00 XB XA XI XP 03 00 01 00 </p><p>此时SS:SP指向栈底。</p><p>我们接下来通过一个C语言程序编译后的汇编语言程序，看一下栈在参数传递中的应用，在高级语言中，局部变量也在栈中储存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    c=a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">    add(a,b,c);</span><br><span class="line">    c++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的汇编程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mov bp,sp</span><br><span class="line">sub sp,6</span><br><span class="line">mov word ptr [bp-6],0001</span><br><span class="line">mov word ptr [bp-4],0002</span><br><span class="line">mov word ptr [bp-2],0000</span><br><span class="line">push [bp-2]</span><br><span class="line">push [bp-4]</span><br><span class="line">push [bp-6]</span><br><span class="line">call ADDR</span><br><span class="line">add sp,6</span><br><span class="line">inc word ptr [bp-2]</span><br><span class="line">ADDR:</span><br><span class="line">push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">mov ax,[bp+4]</span><br><span class="line">add ax,[bp+6]</span><br><span class="line">mov [bp+8],ax</span><br><span class="line">mov sp,bp</span><br><span class="line">pop bp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>尝试画出栈的情况变化，理解栈在参数传递中的作用。</p><h1 id="寄存器冲突问题"><a href="#寄存器冲突问题" class="headerlink" title="寄存器冲突问题"></a>寄存器冲突问题</h1><p>现在你已经学会了子程序的编写，那么我们思考一个问题当我们循环调用一个子程序时，且子程序中使用了寄存器CX会发生什么？这个问题，我们之前遇到过类似的，当使用嵌套循环时也会出现这样的问题，内层循环更改了寄存器CX使得，外层循环出现了问题。同样，我们的子程序修改了CX使得循环出现了问题，我们要如何解决呢？没错还是使用栈来解决，我们在进入子程序后，立马将CX的值压入栈中，待程序完成后从栈中取出CX的值，不只是CX，只要是主程序用到，子程序重复使用的寄存器，我们都要这样处理一下，当然了要注意出栈入栈的顺序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（九）</title>
    <link href="http://example.com/2022/09/02/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <id>http://example.com/2022/09/02/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B9%9D%EF%BC%89/</id>
    <published>2022-09-02T02:13:13.000Z</published>
    <updated>2022-09-09T07:26:50.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li><li>nop占用一个字节，不进行任何动作</li></ol><p>话不多说我们马上开始。</p><h1 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h1><p>还记得我们之前学习过的jmp指令嘛，就是那个可以用来修改CS，IP的指令。jmp指令就是转移指令的一种，概括的来讲，转移指令就是可以控制CPU执行内存中某处代码的指令。8086CPU的转移行为有以下两种：</p><ul><li>只修改IP时，称为段内转移，比如：jmp AX。</li><li>同时修改CS和IP时，称为段间转移，比如：jmp 1000:0。</li></ul><p>由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。</p><ul><li>短转移IP的修改范围是-128~127。</li><li>近转移IP的修改范围是-32768~32767。</li></ul><p>8086CPU的转移指令可以分为以下几类：</p><ul><li>无条件转移指令（如jmp指令）</li><li>条件转移指令</li><li>循环指令（如loop指令）</li><li>过程</li><li>中断</li></ul><p>这些转移指令的前提条件可能不同，但是其中的原理都大相径庭，我们会在这一章中学习无条件转移指令jmp来理解CPU执行转移指令的基本原理。</p><h1 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h1><p>我们先引入一段简单的程序来介绍操作符offset：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,offset start</span><br><span class="line">s:mov ax,offset s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>现在我们来解释一下上面的程序offset操作符取到了标号处的偏移地址，例如offset得到了start和s的偏移地址分别是0和3，所以指令mov ax,offset start就等同于mov ax,0。</p><h1 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h1><p>jmp为无条件转移指令，可以修改IP也可以同时修改CS和IP。jmp指令要给出两种信息：</p><ol><li>转移的目的地址</li><li>转移的距离（段间转移，段内短转移，段内近转移）</li></ol><p>不同的给出目的地址的方法，不同的转移位置就对应着不同的jmp指令格式。</p><h2 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h2><p>jmp short 标号（转到标号处执行指令），这种格式的jmp指令实现的是段内短转移，之前说过这种转移的方式对IP的修改范围在-128~127，也就是说它最多可以向前跳转最多可以越过128个字节，向后跳转最多可以越过127个字节。short符号就说明了这个jmp指令进行的是一次短转移，标号就代表了这次跳转的目的地，待jmp指令执行完成之后，CS:IP应该指向标号处的指令。我们举一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">jmp short s</span><br><span class="line">add ax,1</span><br><span class="line">s:inc ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>上述程序运行后，ax中的值为1，这是因为执行jmp short s后，越过了add ax,1,IP指向了标号s处的指令inc ax。也就是说实际上程序只对ax进行了一次加1的工作。接下来我们看看jmp short s对应的机器指令，在此之前我们先看看别的汇编指令与其对应的机器指令：</p><p><img src="1.jpg" alt="汇编指令与其对应的机器指令"></p><p>可以看到一般的汇编指令其中的idata，无论它是一个数据还是内存单元的偏移地址，都会在它对应的机器指令中出现，因为CPU执行的是机器指令，它必须要处理这些数据或者地址。</p><p>现在我们回过头，使用debug将我们的程序翻译成机器指令看一下：</p><p><img src="2.jpg" alt="我们的程序与其对应的机器指令"></p><p>我们可以看到debug将jmp short s中的s表示为inc ax,1的偏移地址也就是0008H，并将jmp short s表示为jmp 0008，很合理的行为，但是我们看一下jmp short s对应的机器指令，我们发现它并不像是一般指令做的那样，它的机器码是EB 03,程序的0008H没有出现在机器指令中，这就意味着CPU在执行jmp short s的时候，它并不知道转移的目的地，那它是怎么知道到底要向哪里转移的呢？</p><p>我们修改一下程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">mov bx,0</span><br><span class="line">jmp short s</span><br><span class="line">add ax,1</span><br><span class="line">s:inc ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>然后再一次的使用debug将程序翻译成机器指令：</p><p><img src="3.jpg" alt="修改后的程序与其对应的机器指令"></p><p>OH！jmp指令对应的机器指令还是E8 03。这就说明了CPU在执行jmp指令的时候不需要转移的目的地址。这两次jmp指令转移的目的地址是不同的，如果机器指令中含有转移的目的地址，那么它们的机器指令也应该不同。可事实上它们的机器指令相同，这就说明jmp指令对应的机器指令中不包含转移的目的地址。</p><p>可是CPU不是上仙啊，你不告诉它转移的目的地址它也没办法工作呀，我们使用debug跟踪一下程序结合之前学习CPU执行程序的过程，仔细的看看CPU执行到jmp指令后到底发生了什么吧：</p><ol><li>(CS)=076AH，(IP)=0006H，CS:IP指向EB 03</li><li>读取指令码EB 03进入指令缓冲器</li><li>(IP)=(IP)+2=0008H，CS:IP指向add ax,1</li><li>CPU执行指令缓冲器的指令EB 03</li><li>指令EB 03执行后，(IP)=000BH，CS:IP指向inc ax</li></ol><p>从上面的整个过程我们知道了，CPU将指令EB 03读入后，本来已经将CS:IP指向了add ax,1，下一条指令应该执行</p><p>add ax,1，但在jmp指令执行完后IP变成了000BH，所以EB 03这条机器指令一定修改了IP。没错这条指令确实修改了IP，但是根据什么呢？03！只有03可能了，EB太大了这个数字不可能是修改的关键，没错就是03指导CPU如何修改IP，它们没有告诉CPU目的地址是多少，但却说出了需要转移的位移，03也就是从当前位置向后移动3个字节。那03是如何得到的呢，其实是编译器根据汇编指令中的标号计算出来的，我们给出一个公式：位移=标号处偏移地址-jmp指令下一条指令的偏移地址。对于修改后的程序来讲0003H=000BH-0008H。</p><p>实际上，jmp short 标号的功能为：(IP)=(IP)+8位位移。因为8位位移的取值范围是-128~127所以要使用补码来表示。</p><p>还有一种和jmp short 标号功能相近的指令格式。jmp near ptr 标号，它的功能是(IP)=(IP)+16位位移，实现了段内近转移。16位位移的取值范围是-32768~32767，也是使用补码表示。</p><p>这些位移得来的计算方法相同都是：位移=标号处偏移地址-jmp指令下一条指令的偏移地址。在编译程序编译时算出。</p><h2 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h2><p>我们刚才介绍了一个机器指令中不包含目的地址的jmp指令，那现在我们介绍一个机器指令中包含的目的地址jmp far ptr 标号 实现的是段间转移，又称远转移。功能如下：(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址。far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。我们举一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,0</span><br><span class="line">mov bx,0</span><br><span class="line">jmp far ptr s</span><br><span class="line">db 256 dup(0)</span><br><span class="line">s:add ax,1</span><br><span class="line">inc ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>我们使用debug将程序翻译成机器指令：</p><p><img src="4.jpg" alt="修改后的程序与其对应的机器指令"></p><p>可以看到jmp far ptr s的机器指令，为EA 0B 01 6A 07这其中就包含了目的地址，高地址的076AH为转移的段地址，低地址的010B是偏移地址。</p><h2 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h2><p>我们还是先来看一下指令的格式：jmp 16位reg，它的功能是(IP)=(16位reg)，当然了这已经是我们的老朋友了，我们就不多介绍了。</p><h2 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h2><p>转移指令中的转移地址还可以在内存之中，转移地址在内存中的jmp指令有两种格式：</p><h3 id="jmp-word-ptr-内存单元地址（段内转移）"><a href="#jmp-word-ptr-内存单元地址（段内转移）" class="headerlink" title="jmp word ptr 内存单元地址（段内转移）"></a>jmp word ptr 内存单元地址（段内转移）</h3><p>功能：从内存单元地址处开始存放着一个字，是转移的目的地址的偏移地址，也就是(IP)=(内存单元地址)。内存单元地址可用寻址方式的任一格式给出。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br><span class="line"></span><br><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">jmp word ptr [bx]</span><br></pre></td></tr></table></figure><p>这两种方式最终的结果相同，(IP)=0123H</p><h3 id="jmp-dword-ptr-内存单元地址（段间转移）"><a href="#jmp-dword-ptr-内存单元地址（段间转移）" class="headerlink" title="jmp dword ptr 内存单元地址（段间转移）"></a>jmp dword ptr 内存单元地址（段间转移）</h3><p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址，也就是(CS)=(内存单元地址+2)，(IP)=(内存单元地址)。内存单元地址可用寻址方式的任一格式给出。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">mov word ptr [bx+2],0</span><br><span class="line">jmp dword ptr [bx]</span><br></pre></td></tr></table></figure><p>这两种方式最终的结果相同，(CS)=0000H，(IP)=0123H，CS:IP指向0000:0123。</p><h1 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h1><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围为-128~127。我们来看一下它的格式：jcxz 标号，如果(CX)=0，转移到标号处执行。也就是当(CX)=0时，(IP)=(IP)+8位位移。位移计算方法也是老方法：位移=标号处偏移地址-jcxz指令下一条指令的偏移地址，结果用补码表示，在编译程序编译时算出。当(CX)不等于0时，程序什么也不会做，直接继续向下执行。所以从功能上来讲可以理解成if((CX)==0)jmp short 标号;。</p><p>这里我们给出一个jcxz指令的一种应用场景，在汇编语言编程中，当我们要处理一个字符串的时候，我们在结尾通常会有一个0标志着整个字符串至0为止，这个时候我们就可以使用jcxz指令和循环等方法结合，从字符串的第一个字符开始处理，直至遇到字符串结尾的0。或许char数组以\0结尾的原因也和jcxz指令有些许关系呢，如果小伙伴感兴趣，可以自行查找相关资料，这里不多讨论。</p><h1 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h1><p>loop指令是循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围为-128~127。我们来看一下它的格式：loop 标号（(CX)=(CX)-1，如果(CX)不等于0，转移到标号处执行）。位移计算方法也是老方法：位移=标号处偏移地址-jcxz指令下一条指令的偏移地址，结果用补码表示，在编译程序编译时算出，这些都是大同小异的。当(CX)=0时，程序什么也不会做，直接继续向下执行。所以从功能上我们可以理解为(CX)–；if((CX)!=0)jmp short 标号;。</p><h1 id="根据位移进行转移的意义"><a href="#根据位移进行转移的意义" class="headerlink" title="根据位移进行转移的意义"></a>根据位移进行转移的意义</h1><p>相信有的小伙伴会疑问，为什么要算一下位移，然后通过位移再去确定最终的目的地址呢？其实这种设计，方便了程序段在内存中的浮动装配。我们看一段程序：</p><p><img src="5.jpg" alt="使用位移进行转移的意义"></p><p>这段程序无论装在内存的哪里都可以正确执行，因为loop s在执行时只涉及s的位移（-4，前移四个字节，补码表示为FCH），而不是s的地址。如果loop s的机器码中包含的是s的地址，等s处的指令不在目的地址处，程序的执行就会出错。而loop s的机器码中包含的是转移的位移，就不存在这个问题了，因为无论s处的指令实际地址是多少，loop指令的转移地址是不变的。</p><h1 id="编译器对转移位移超界的检测"><a href="#编译器对转移位移超界的检测" class="headerlink" title="编译器对转移位移超界的检测"></a>编译器对转移位移超界的检测</h1><p>注意，根据我们所学的转移指令发现，它们都有一个转移的范围，如果源程序中出现了超出转移范围的话，在编译阶段，编译器将报错。在我们之前使用的形如jmp 2000:0100的转移指令，这些都会引发编译报错，不过我们之前都是在debug中使用的，汇编编译器不认识而已。所以以后要小心源程序中不要出现这样的指令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的汇编语言（八）</title>
    <link href="http://example.com/2022/08/31/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <id>http://example.com/2022/08/31/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AB%EF%BC%89/</id>
    <published>2022-08-31T15:40:26.000Z</published>
    <updated>2022-09-02T02:12:03.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图片以及思考题供读者阅读，如需详细学习汇编语言可以购入一本，谢谢。</p><p>学习之前我们做如下约定（随着学习深入还会出现新的约定）：</p><ol><li>十六进制数均以H结尾</li><li>使用8086CPU作为案例</li><li>我们使用(地址或寄存器名称)表示一个寄存器或一个内存单元的内容，()内地址是且一定是物理地址</li><li>我们将idata视作常量</li><li>我们以reg表示一个寄存器包括ax、ah、sp、bp、si、di等，sreg表示一个段寄存器包括ds、ss、cs、es。</li></ol><p>话不多说我们马上开始。</p><h1 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h1><p>这一篇可以算的上是一篇总结性的文章。我们知道，计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含其中：</p><ol><li>处理的数据在哪里？</li><li>要处理的数据有多长？</li></ol><p>这两个问题，在机器指令中必须给明确或者隐含的说明，要不然是没有办法工作的，所以我们这篇文章就在8086CPU的基础上进行讨论。</p><h1 id="bx、si、di、bp"><a href="#bx、si、di、bp" class="headerlink" title="bx、si、di、bp"></a>bx、si、di、bp</h1><p>前面三个寄存器我们都已经见过啦，我们来总结一下它们的用法：</p><ol><li>在8086CPU中只有这四个寄存器可以用在[…]中来进行内存单元的寻址。</li><li>在[…]中，这4个寄存器可以单个出现，或者只能以这四种组合出现：bx和si、bx和di、bp和si、bp和di。</li><li>只要在[…]中使用寄存器bp且指令中没有显性的给出段地址，那么段地址就默认在SS中。</li></ol><h1 id="机器指令：我的数据在哪里？"><a href="#机器指令：我的数据在哪里？" class="headerlink" title="机器指令：我的数据在哪里？"></a>机器指令：我的数据在哪里？</h1><p>绝大部分的机器指令都是进行数据处理的指令，处理大致分为三类：读取、写入、运算。但从机器指令这一层来讲，它并不关心数据的值是多少，而关心指令执行前一刻，它要处理的数据在哪里？在指令执行前，所要处理的数据可以在三个地方：CPU内部、内存、端口。</p><h1 id="汇编语言中数据位置的表达"><a href="#汇编语言中数据位置的表达" class="headerlink" title="汇编语言中数据位置的表达"></a>汇编语言中数据位置的表达</h1><p>在汇编语言中如何表达数据的位置呢？我们有三个概念来表达数据的位置。</p><p>1.立即数（idata）</p><p>对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），在汇编语言中成为：立即数（idata），在汇编指令中直接给出，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add bx,2000H</span><br><span class="line">or bx,00100000B</span><br><span class="line">mov AL,&#x27;a&#x27;</span><br></pre></td></tr></table></figure><p>2.寄存器</p><p>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx</span><br><span class="line">mov ds,ax</span><br><span class="line">push bx</span><br><span class="line">mov ds:[0],bx</span><br><span class="line">push ds</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,ax</span><br></pre></td></tr></table></figure><p>3.段地址（SA）和偏移地址（EA）</p><p>指令要处理的数据在内存中，在汇编指令中可以使用[X]的格式给出EA,SA在某个段寄存器中，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br><span class="line">mov ax,[di]</span><br><span class="line">mov ax,[bx+8]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line"></span><br><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bp+8]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+si+8]</span><br><span class="line"></span><br><span class="line">mov ax,ds:[bp]</span><br><span class="line">mov ax,es:[bx]</span><br><span class="line">mov ax,cs:[bx+si]</span><br><span class="line">mov ax,ss:[bx+si+8]</span><br></pre></td></tr></table></figure><p>存放段地址的寄存器可以是默认的，1到4条指令的段地址默认在ds中，5到8条指令的段地址默认在ss中，当然存放段地址的寄存器也可以显性给出，就像9到12条指令所做的。</p><h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p>当数据存放在内存中，我们有很多方式给顶这个内存单元的偏移地址，这种定位内存单元的方法一般被称为寻址方式。我们用一张图片来总结一下这些寻址方式。</p><p><img src="1.jpg" alt="寻址方式"></p><h1 id="指令要处理的数据有多长？"><a href="#指令要处理的数据有多长？" class="headerlink" title="指令要处理的数据有多长？"></a>指令要处理的数据有多长？</h1><p>8086CPU可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明到底是字操作还是字节操作，我们有如下方式处理：</p><p>1.通过寄存器名指明要处理的数据的尺寸，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">mov bx,ds:[0]</span><br><span class="line">mov ds,ax</span><br><span class="line">inc ax</span><br><span class="line"></span><br><span class="line">mov AL,1</span><br><span class="line">mov AL,BL</span><br><span class="line">mov AL,ds:[0]</span><br><span class="line">inc AL</span><br></pre></td></tr></table></figure><p>其中1到4条指令指明了是字操作，5到8条指明了是对字节操作。</p><p>2.用操作符 X ptr 指明内存单元的长度，X在汇编指令中可以为word或byte，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br><span class="line">inc word ptr ds:[0]</span><br><span class="line">add word ptr [bx],2</span><br><span class="line"></span><br><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">inc byte ptr [bx]</span><br><span class="line">inc byte ptr ds:[0]</span><br><span class="line">add byte ptr [bx],2</span><br></pre></td></tr></table></figure><p>其中1到4条指令指明了是字操作，5到8条指明了是对字节操作。在没有寄存器指明数据尺寸时，使用操作符指明时非常必要的，如果没有指明是无法正常工作的。</p><p>3.其他方法</p><p>有些指令默认了访问的是字节单元还是字单元，比如push [1000H]就不需要指明访问单元是字单元还是字节单元，push指令只进行字操作。</p><h1 id="寻址方式的综合应用"><a href="#寻址方式的综合应用" class="headerlink" title="寻址方式的综合应用"></a>寻址方式的综合应用</h1><p>我们通过一个问题来体验一下各种寻址方式的作用。</p><p>1982年，DEC公司有一条数据如下：</p><p>公司名称：DEC</p><p>总裁姓名：Ken Oslen</p><p>排       名：137</p><p>收       入：40（40亿美元）</p><p>著名产品：PDP</p><p>这些数据在内存中存放方式如下：</p><p><img src="2.jpg" alt="DEC公司数据"></p><p>根据图片可以知道，数据被存放在seg段中从偏移地址60H起始的位置，从seg:60+0开始存放了3个字节的公司名称；从seg:60+3开始存放了9个字节的总裁姓名；从seg:60+C开始存放了一个字型数据，排名；从seg:60+E开始存放了一个字型数据，公司的收入；从seg:60+10开始存放了3个字节的著名产品。</p><p>直到1988年DEC公司的信息有了如下变化：</p><ol><li>Ken Olsen在富豪榜上上升到了38位。</li><li>DEC的收入增加了70亿美元。</li><li>该公司的著名产品已变为VAX系列计算机。</li></ol><p>我们的任务就是把过时的数据修改掉。</p><p>我们直接看code段的关键代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov ax,seg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,60H</span><br><span class="line">mov word ptr [bx+0CH],38</span><br><span class="line">add word ptr [bx+0EH],70</span><br><span class="line">mov si,0</span><br><span class="line">mov byte ptr [bx+10H+si],&#x27;V&#x27;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx+10H+si],&#x27;A&#x27;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx+10H+si],&#x27;X&#x27;</span><br></pre></td></tr></table></figure><p>为了让大家对这段代码有更好的理解，我们用C语言写一下该程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">company</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> cn[<span class="number">3</span>];</span><br><span class="line">    <span class="type">char</span> hn[<span class="number">9</span>];</span><br><span class="line">    <span class="type">int</span> pm;</span><br><span class="line">    <span class="type">int</span> sr;</span><br><span class="line">    <span class="type">char</span> cp[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">company</span> <span class="title">dec</span>=</span>&#123;<span class="string">&quot;DEC&quot;</span>,<span class="string">&quot;Ken Oslen&quot;</span>,<span class="number">137</span>,<span class="number">40</span>,<span class="string">&quot;PDP&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    dec.pm=<span class="number">38</span>;</span><br><span class="line">    dec.sr=dec.sr+<span class="number">70</span>;</span><br><span class="line">    dec.cp[i]=<span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">    i++;</span><br><span class="line">    dec.cp[i]=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    i++;</span><br><span class="line">    dec.cp[i]=<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将两种代码的一些部分对应起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr [bx+0CH],38dec.pm=38;</span><br><span class="line">add word ptr [bx+0EH],70dec.sr=dec.sr+70;</span><br><span class="line">mov si,0   </span><br><span class="line">mov byte ptr [bx].10H[si],&#x27;V&#x27;dec.cp[i]=&#x27;V&#x27;;</span><br><span class="line">inc si    i++;</span><br><span class="line">mov byte ptr [bx].10H[si],&#x27;A&#x27;     dec.cp[i]=&#x27;A&#x27;;</span><br><span class="line">inc si   i++;</span><br><span class="line">mov byte ptr [bx].10H[si],&#x27;X&#x27;dec.cp[i]=&#x27;X&#x27;;</span><br></pre></td></tr></table></figure><p>怎么样是不是很直观，根据对比的结构，我们可以得知8086CPU提供如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便。一个结构化的数据包含了多个数据项，而且数据项的类型又不相同。这个时候我们就可以使用[bx+si+idata]来访问结构体中的数据。用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每一个元素。所以汇编语言提供了更为贴切的书写格式如[bx].idata、[bx].idata[si]。</p><p>在C语言中我们又可以看到，如dec.cp[i]，dec是一个变量名，指明了结构体变量的地址，cp是结构体中的一个变量，指明了数据项cp的地址，而i用来定位cp中的每一个字符。所以看看dec.cp[i]和[bx].10H[si]是不是很像呢？</p><h1 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h1><p>div指令是除法指令，使用div要注意如下事情：</p><ol><li>除数：有8位和16位，在一个reg或内存单元中。</li><li>被除数：默认放在AX或者DX和AX中，如果除数是8位，被除数为16位，默认存放在AX中；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。注意！被除数的位数一定是除数的两倍。</li><li>结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</li></ol><p>div指令的格式是这样的：div reg 或 div 内存单元</p><p>我们举几个例子来看一下div指令：</p><p>div byte ptr ds:[0]</p><p>首先，我们根据操作符确定了除数是8位的，所以被除数是16位的，被存放在AX中了，执行后商被存储在AL中，余数被存放在AH中。用符号表达就是 (AL)=(AX)/((ds)×16+0)的商， (AH)=(AX)/((ds)×16+0)的余数。</p><p>div  word ptr es:[0]</p><p>首先，我们还是根据操作符确定了除数是16位的，所以被除数就是32位的，需要AX和DX共同存储，其中DX存储了高16位，AX存储了低16位，执行时DX中的数据要先乘10000H（左移四位）再加上AX中的数据才能组成被除数，例如被除数是8b1d7eecH那么就意味着(DX)=8b1dH,(AX)=7eecH，所以被除数就等于(DX)×10000H+(AX)。用符号表达就是 (AX)=[(DX)×10000H+(AX)]/((es)×16+0)的商， (DX)=[(DX)×10000H+(AX)]/((es)×16+0)的余数。</p><h1 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a>伪指令dd</h1><p>前面我们用db和dw定义字节型数据和字型数据，dd是用来定义dword（双字）型数据的，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">db 1</span><br><span class="line">dw 1</span><br><span class="line">dd 1</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>在data段定义了3个数据：</p><p>第一个数据为01H,在data:0处，占1个字节；</p><p>第一个数据为0001H,在data:1处，占1个字；</p><p>第一个数据为00000001H,在data:3处，占2个字。</p><h1 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h1><p>dup是一个操作符，在汇编语言中和db、dw、dd等一样，也是编译器识别处理的符号。它是和db、dw、dd等数据定义伪指令配合使用的，用来数据的重复。例如：</p><p>db 3 dup(0) 就是定义了三个字节，它们的值都是0，相当于db 0,0,0</p><p>db 3 dup(1,2,3) 就是定义了九个字节，它们的值是0,1,2,0,1,2,0,1,2，相当于db 0,1,2,0,1,2,0,1,2</p><p>可见dup的使用格式如下：</p><p>db 重复的次数 dup （重复的字节型数据）</p><p>dw 重复的次数 dup （重复的字型数据）</p><p>dd 重复的次数 dup （重复的双字型数据）</p><p>dup是一个非常实用的操作符，比如要定义一个200个字节大小的栈段，原本你需要使用dw声明100个字型数据，但现在你可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack segment</span><br><span class="line">db 200 dup(0)</span><br><span class="line">stack ends</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从0开始的汇编语言系列，选用的参考书籍是清华大学出版社，王爽老师的《汇编语言第四版》。该系列属于博主的笔记系列，文中会采用一些书中的例子，图</summary>
      
    
    
    
    <category term="Assembly Language" scheme="http://example.com/categories/Assembly-Language/"/>
    
    
    <category term="Assembly Language" scheme="http://example.com/tags/Assembly-Language/"/>
    
  </entry>
  
</feed>
